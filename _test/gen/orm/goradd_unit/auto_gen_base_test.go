// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"strconv"
	"testing"
	"time"

	"github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createMinimalSampleAutoGen creates an unsaved minimal version of a AutoGen object
// for testing.
func createMinimalSampleAutoGen() *AutoGen {
	obj := NewAutoGen()
	updateMinimalSampleAutoGen(obj)

	return obj
}

// updateMinimalSampleAutoGen sets the values of a minimal sample to new, random values.
func updateMinimalSampleAutoGen(obj *AutoGen) {

	obj.SetName(test.RandomValue[string](10))

}

// createMaximalSampleAutoGen creates an unsaved version of a AutoGen object
// for testing that includes references to minimal objects.
func createMaximalSampleAutoGen(ctx context.Context) *AutoGen {
	obj := NewAutoGen()
	updateMaximalSampleAutoGen(ctx, obj)
	return obj
}

// updateMaximalSampleAutoGen sets all the maximal sample values to new values.
// This will set new values for references, so save the old values and delete them.
func updateMaximalSampleAutoGen(ctx context.Context, obj *AutoGen) {
	updateMinimalSampleAutoGen(obj)

}

// deleteSampleAutoGen deletes an object created and saved by one of the sample creator functions.
func deleteSampleAutoGen(ctx context.Context, obj *AutoGen) {
	if obj == nil {
		return
	}

	_ = obj.Delete(ctx)
}

// assertEqualFieldsAutoGen compares two objects and asserts that the basic fields are equal.
func assertEqualFieldsAutoGen(t *testing.T, obj1, obj2 *AutoGen) {
	if obj1.IDIsLoaded() && obj2.IDIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.ID(), obj2.ID())
	}
	if obj1.GroLockIsLoaded() && obj2.GroLockIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.GroLock(), obj2.GroLock())
	}
	if obj1.GroTimestampIsLoaded() && obj2.GroTimestampIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.GroTimestamp(), obj2.GroTimestamp())
	}
	if obj1.CreatedIsLoaded() && obj2.CreatedIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Created(), obj2.Created(), time.Second)
	}
	if obj1.ModifiedIsLoaded() && obj2.ModifiedIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Modified(), obj2.Modified(), time.Second)
	}
	if obj1.NameIsLoaded() && obj2.NameIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.Name(), obj2.Name())
	}

}

func TestAutoGen_SetID(t *testing.T) {

	obj := NewAutoGen()

	assert.True(t, obj.IsNew())
	val := test.RandomNumberString()
	obj.SetID(val)
	assert.Equal(t, val, obj.ID())

	// test default
	obj.SetID("")
	assert.EqualValues(t, "", obj.ID(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](33)
	assert.Panics(t, func() {
		obj.SetID(val)
	})
}
func TestAutoGen_SetName(t *testing.T) {

	obj := NewAutoGen()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](10)
	obj.SetName(val)
	assert.Equal(t, val, obj.Name())

	// test default
	obj.SetName("")
	assert.EqualValues(t, "", obj.Name(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](11)
	assert.Panics(t, func() {
		obj.SetName(val)
	})
}

func TestAutoGen_Copy(t *testing.T) {
	obj := createMinimalSampleAutoGen()

	obj2 := obj.Copy()

	assert.Equal(t, obj.Name(), obj2.Name())

}

func TestAutoGen_BasicInsert(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	// Test retrieval
	obj2, err := LoadAutoGen(ctx, obj.PrimaryKey())
	require.NotNil(t, obj2)
	assert.NoError(t, err)

	assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

	assert.True(t, obj2.IDIsLoaded())
	assert.Panics(t, func() {
		obj2.SetID(obj2.ID())
	})

	assert.True(t, obj2.GroLockIsLoaded())

	assert.True(t, obj2.GroTimestampIsLoaded())

	assert.True(t, obj2.CreatedIsLoaded())

	assert.True(t, obj2.ModifiedIsLoaded())
	assert.False(t, obj2.ModifiedIsNull())

	assert.True(t, obj2.NameIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.nameIsDirty)
	obj2.SetName(obj2.Name())
	assert.False(t, obj2.nameIsDirty)

}

func TestAutoGen_InsertPanics(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	_ = obj
	ctx := context.Background()
	_ = ctx

	obj.nameIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.nameIsLoaded = true

}

func TestAutoGen_BasicUpdate(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)
	updateMinimalSampleAutoGen(obj)
	assert.NoError(t, obj.Save(ctx))
	obj2, err := LoadAutoGen(ctx, obj.PrimaryKey())
	assert.NoError(t, err)

	assert.Equal(t, obj2.ID(), obj.ID(), "ID did not update")
	assert.Equal(t, obj2.GroLock(), obj.GroLock(), "GroLock did not update")
	assert.Equal(t, obj2.GroTimestamp(), obj.GroTimestamp(), "GroTimestamp did not update")

	assert.WithinDuration(t, obj2.Created(), obj.Created(), time.Second, "Created not within one second")

	assert.WithinDuration(t, obj2.Modified(), obj.Modified(), time.Second, "Modified not within one second")
	assert.Equal(t, obj2.Name(), obj.Name(), "Name did not update")
}

func TestAutoGen_ReferenceLoad(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleAutoGen(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	// Test that referenced objects were saved and assigned ids

	// Test lazy loading
	obj2, err := LoadAutoGen(ctx, obj.PrimaryKey())
	assert.NoError(t, err)
	assert.NotNil(t, obj2)
	objPkOnly, err2 := LoadAutoGen(ctx, obj.PrimaryKey(),
		node.AutoGen().ID())
	assert.NoError(t, err2)
	_ = objPkOnly

	// test eager loading
	obj3, _ := LoadAutoGen(ctx, obj.PrimaryKey())
	_ = obj3 // avoid error if there are no references

}

func TestAutoGen_ReferenceUpdateNewObjects(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleAutoGen(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	obj2, _ := LoadAutoGen(ctx, obj.PrimaryKey())
	updateMaximalSampleAutoGen(ctx, obj2)
	assert.NoError(t, obj2.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj2)

	obj3, _ := LoadAutoGen(ctx, obj2.PrimaryKey())
	_ = obj3 // avoid error if there are no references

}

func TestAutoGen_ReferenceUpdateOldObjects(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleAutoGen(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	assert.NoError(t, obj.Save(ctx))

	obj2, _ := LoadAutoGen(ctx, obj.PrimaryKey())
	_ = obj2 // avoid error if there are no references

}
func TestAutoGen_EmptyPrimaryKeyGetter(t *testing.T) {
	obj := NewAutoGen()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)
}

func TestAutoGen_Getters(t *testing.T) {
	obj := createMinimalSampleAutoGen()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)

	ctx := context.Background()
	require.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	has, _ := HasAutoGen(ctx, obj.PrimaryKey())
	assert.True(t, has)

	obj2, _ := LoadAutoGen(ctx, obj.PrimaryKey(),
		node.AutoGen().ID())

	assert.Equal(t, obj.ID(), obj.Get(AutoGenIDField))
	assert.Equal(t, obj.GroLock(), obj.Get(AutoGenGroLockField))
	assert.Panics(t, func() { obj2.GroLock() })
	assert.Nil(t, obj2.Get(AutoGenGroLockField))
	assert.Equal(t, obj.GroTimestamp(), obj.Get(AutoGenGroTimestampField))
	assert.Panics(t, func() { obj2.GroTimestamp() })
	assert.Nil(t, obj2.Get(AutoGenGroTimestampField))
	assert.Equal(t, obj.Created(), obj.Get(AutoGenCreatedField))
	assert.Panics(t, func() { obj2.Created() })
	assert.Nil(t, obj2.Get(AutoGenCreatedField))
	assert.Equal(t, obj.Modified(), obj.Get(AutoGenModifiedField))
	assert.Panics(t, func() { obj2.Modified() })
	assert.Nil(t, obj2.Get(AutoGenModifiedField))
	assert.Equal(t, obj.Name(), obj.Get(AutoGenNameField))
	assert.Panics(t, func() { obj2.Name() })
	assert.Nil(t, obj2.Get(AutoGenNameField))

}

func TestAutoGen_QueryLoad(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	objs, err := QueryAutoGens(ctx).
		Where(op.Equal(node.AutoGen().ID(), obj.ID())).
		OrderBy(node.AutoGen().ID()). // exercise order by
		Limit(1, 0).                  // exercise limit
		Calculation(node.AutoGen(), "IsTrue", op.Equal("A", "A")).
		Load()
	assert.NoError(t, err)
	assert.Equal(t, obj.PrimaryKey(), objs[0].PrimaryKey())
	assert.True(t, objs[0].GetAlias("IsTrue").Bool())
}
func TestAutoGen_QueryLoadI(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	ctx := context.Background()
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleAutoGen(ctx, obj)

	objs, _ := QueryAutoGens(ctx).
		Where(op.Equal(node.AutoGen().ID(), obj.ID())).
		LoadI()

	assert.Equal(t, obj.PrimaryKey(), objs[0].(*AutoGen).PrimaryKey())
}
func TestAutoGen_QueryCursor(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleAutoGen(ctx, obj)

	cursor, err := QueryAutoGens(ctx).
		Where(op.Equal(node.AutoGen().ID(), obj.ID())).
		LoadCursor()
	require.NoError(t, err)
	obj2, err2 := cursor.Next()
	assert.Equal(t, obj.PrimaryKey(), obj2.PrimaryKey())
	require.NoError(t, err2)
	obj2, err2 = cursor.Next()
	assert.Nil(t, obj2)
	require.NoError(t, err2)
	assert.NoError(t, cursor.Close())

	// test empty cursor result
	cursor, err = QueryAutoGens(ctx).
		Where(op.Equal("B", "A")).
		LoadCursor()
	require.NoError(t, err)

	obj2, err = cursor.Next()
	assert.Nil(t, obj2)
	require.NoError(t, err)
	assert.NoError(t, cursor.Close())
}
func TestAutoGen_Count(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleAutoGen(ctx)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleAutoGen(ctx, obj)
	assert.Positive(t, func() int { i, _ := CountAutoGens(ctx); return i }())

}

func TestAutoGen_MarshalJSON(t *testing.T) {
	obj := createMinimalSampleAutoGen()

	b, err := json.Marshal(obj)
	assert.NoError(t, err)

	obj2 := NewAutoGen()
	err = json.Unmarshal(b, &obj2)
	assert.NoError(t, err)

	assertEqualFieldsAutoGen(t, obj, obj2)
}

func TestAutoGen_MarshalBinary(t *testing.T) {
	obj := createMinimalSampleAutoGen()

	b, err := obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 := NewAutoGen()
	err = obj2.UnmarshalBinary(b)
	assert.NoError(t, err)

	assertEqualFieldsAutoGen(t, obj, obj2)
}

func TestAutoGen_FailingMarshalBinary(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	var err error

	for i := 0; i < 18; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
	// do it again with aliases
	obj._aliases = make(map[string]any)
	for i := 0; i < 19; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
}

func TestAutoGen_FailingUnmarshalBinary(t *testing.T) {
	obj := createMinimalSampleAutoGen()
	b, err := obj.MarshalBinary()
	assert.NoError(t, err)
	obj2 := NewAutoGen()
	for i := 0; i < 18; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}

	// do it again with aliases
	obj = createMinimalSampleAutoGen()
	obj._aliases = map[string]any{"a": 1}
	b, err = obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 = NewAutoGen()
	for i := 0; i < 19; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}
}
