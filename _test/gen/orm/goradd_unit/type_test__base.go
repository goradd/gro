// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"time"
	"unicode/utf8"

	"github.com/goradd/all"
	"github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
	"github.com/goradd/orm/pkg/broadcast"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/query"
)

// TypeTestBase is embedded in a TypeTest object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the TypeTest embedder.
// Instead, use the accessor functions.
type typeTestBase struct {
	id        string
	idIsValid bool
	idIsDirty bool

	date        time.Time
	dateIsNull  bool
	dateIsValid bool
	dateIsDirty bool

	time        time.Time
	timeIsNull  bool
	timeIsValid bool
	timeIsDirty bool

	dateTime        time.Time
	dateTimeIsNull  bool
	dateTimeIsValid bool
	dateTimeIsDirty bool

	ts        time.Time
	tsIsNull  bool
	tsIsValid bool
	tsIsDirty bool

	testInt        int
	testIntIsNull  bool
	testIntIsValid bool
	testIntIsDirty bool

	testFloat        float32
	testFloatIsNull  bool
	testFloatIsValid bool
	testFloatIsDirty bool

	testDouble        float64
	testDoubleIsValid bool
	testDoubleIsDirty bool

	testText        string
	testTextIsNull  bool
	testTextIsValid bool
	testTextIsDirty bool

	testBit        bool
	testBitIsNull  bool
	testBitIsValid bool
	testBitIsDirty bool

	testVarchar        string
	testVarcharIsNull  bool
	testVarcharIsValid bool
	testVarcharIsDirty bool

	testBlob        []byte
	testBlobIsValid bool
	testBlobIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

	_originalPK string
}

// IDs used to access the TypeTest object fields by name using the Get function.
// doc: type=TypeTest
const (
	TypeTest_ID          = `ID`
	TypeTest_Date        = `Date`
	TypeTest_Time        = `Time`
	TypeTest_DateTime    = `DateTime`
	TypeTest_Ts          = `Ts`
	TypeTest_TestInt     = `TestInt`
	TypeTest_TestFloat   = `TestFloat`
	TypeTest_TestDouble  = `TestDouble`
	TypeTest_TestText    = `TestText`
	TypeTest_TestBit     = `TestBit`
	TypeTest_TestVarchar = `TestVarchar`
	TypeTest_TestBlob    = `TestBlob`
)

const TypeTestTestIntMax = 2147483647
const TypeTestTestIntMin = -2147483648
const TypeTestTestTextMaxLength = 65535 // The number of runes the column can hold
const TypeTestTestVarcharMaxLength = 10 // The number of runes the column can hold
const TypeTestTestBlobMaxLength = 65535 // The number of bytes the column can hold

// Initialize or re-initialize a TypeTest database object to default values.
// The primary key will get a temporary negative number which will be replaced when the object is saved.
// Multiple calls to Initialize are not guaranteed to create sequential values for the primary key.
func (o *typeTestBase) Initialize() {

	newObjectPkCounter = newObjectPkCounter - 1
	o.id = fmt.Sprintf("%d", newObjectPkCounter)

	o.idIsValid = false
	o.idIsDirty = false

	o.date = time.Time{}

	o.dateIsNull = true
	o.dateIsValid = true
	o.dateIsDirty = true

	o.time = time.Time{}

	o.timeIsNull = true
	o.timeIsValid = true
	o.timeIsDirty = true

	o.dateTime = time.Time{}

	o.dateTimeIsNull = true
	o.dateTimeIsValid = true
	o.dateTimeIsDirty = true

	o.ts = time.Time{}

	o.tsIsNull = false
	o.tsIsValid = true
	o.tsIsDirty = true

	o.testInt = 5

	o.testIntIsNull = false
	o.testIntIsValid = true
	o.testIntIsDirty = true

	o.testFloat = 0

	o.testFloatIsNull = true
	o.testFloatIsValid = true
	o.testFloatIsDirty = true

	o.testDouble = 0

	o.testDoubleIsValid = false
	o.testDoubleIsDirty = false

	o.testText = ""

	o.testTextIsNull = true
	o.testTextIsValid = true
	o.testTextIsDirty = true

	o.testBit = false

	o.testBitIsNull = true
	o.testBitIsValid = true
	o.testBitIsDirty = true

	o.testVarchar = ""

	o.testVarcharIsNull = true
	o.testVarcharIsValid = true
	o.testVarcharIsDirty = true

	o.testBlob = []byte(nil)

	o.testBlobIsValid = false
	o.testBlobIsDirty = false

	o._restored = false
}

// PrimaryKey returns the current value of the primary key field.
func (o *typeTestBase) PrimaryKey() string {
	return o.id
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *typeTestBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// Copy copies all valid fields to a new TypeTest object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *typeTestBase) Copy() (newObject *TypeTest) {
	newObject = NewTypeTest()
	if o.dateIsValid {
		newObject.SetDate(o.date)
	}
	if o.timeIsValid {
		newObject.SetTime(o.time)
	}
	if o.dateTimeIsValid {
		newObject.SetDateTime(o.dateTime)
	}
	if o.testIntIsValid {
		newObject.SetTestInt(o.testInt)
	}
	if o.testFloatIsValid {
		newObject.SetTestFloat(o.testFloat)
	}
	if o.testDoubleIsValid {
		newObject.SetTestDouble(o.testDouble)
	}
	if o.testTextIsValid {
		newObject.SetTestText(o.testText)
	}
	if o.testBitIsValid {
		newObject.SetTestBit(o.testBit)
	}
	if o.testVarcharIsValid {
		newObject.SetTestVarchar(o.testVarchar)
	}
	if o.testBlobIsValid {
		newObject.SetTestBlob(o.testBlob)
	}
	return
}

// ID returns the loaded value of ID or
// the zero value if not loaded. Call IDIsValid() to determine
// if it is loaded.
func (o *typeTestBase) ID() string {
	return fmt.Sprint(o.id)
}

// IDIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) IDIsValid() bool {
	return o._restored && o.idIsValid
}

// Date returns the loaded value of Date.
func (o *typeTestBase) Date() time.Time {
	if o._restored && !o.dateIsValid {
		panic("Date was not selected in the last query and has not been set, and so is not valid")
	}
	return o.date
}

// DateIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) DateIsValid() bool {
	return o.dateIsValid
}

// DateIsNull returns true if the related database value is null.
func (o *typeTestBase) DateIsNull() bool {
	return o.dateIsNull
}

// Date_I returns the loaded value of Date as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) Date_I() interface{} {
	if o._restored && !o.dateIsValid {
		panic("date was not selected in the last query and has not been set, and so is not valid")
	} else if o.dateIsNull {
		return nil
	}
	return o.date
}

// SetDate prepares for setting the date value in the database.
//
// Pass nil to set it to a NULL value in the database.
//
// The input will immediately be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *typeTestBase) SetDate(i interface{}) {
	o.dateIsValid = true
	if i == nil {
		if !o.dateIsNull {
			o.dateIsNull = true
			o.dateIsDirty = true
			o.date = time.Time{}
		}
	} else {
		v := i.(time.Time)
		v = v.UTC()

		v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())

		if o.dateIsNull ||
			!o._restored ||
			o.date != v {
			o.dateIsNull = false
			o.date = v
			o.dateIsDirty = true
		}
	}
}

// Time returns the loaded value of Time.
func (o *typeTestBase) Time() time.Time {
	if o._restored && !o.timeIsValid {
		panic("Time was not selected in the last query and has not been set, and so is not valid")
	}
	return o.time
}

// TimeIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TimeIsValid() bool {
	return o.timeIsValid
}

// TimeIsNull returns true if the related database value is null.
func (o *typeTestBase) TimeIsNull() bool {
	return o.timeIsNull
}

// Time_I returns the loaded value of Time as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) Time_I() interface{} {
	if o._restored && !o.timeIsValid {
		panic("time was not selected in the last query and has not been set, and so is not valid")
	} else if o.timeIsNull {
		return nil
	}
	return o.time
}

// SetTime prepares for setting the time value in the database.
//
// Pass nil to set it to a NULL value in the database.
//
// The input will immediately be converted to UTC time.
// The date will also be zeroed. This process may cause the time value to change. To prevent this, be sure that the time given is already in UTC time.
func (o *typeTestBase) SetTime(i interface{}) {
	o.timeIsValid = true
	if i == nil {
		if !o.timeIsNull {
			o.timeIsNull = true
			o.timeIsDirty = true
			o.time = time.Time{}
		}
	} else {
		v := i.(time.Time)
		v = v.UTC()

		v = time.Date(0, 1, 1, v.Hour(), v.Minute(), v.Second(), v.Nanosecond(), time.UTC)

		if o.timeIsNull ||
			!o._restored ||
			o.time != v {
			o.timeIsNull = false
			o.time = v
			o.timeIsDirty = true
		}
	}
}

// DateTime returns the loaded value of DateTime.
func (o *typeTestBase) DateTime() time.Time {
	if o._restored && !o.dateTimeIsValid {
		panic("DateTime was not selected in the last query and has not been set, and so is not valid")
	}
	return o.dateTime
}

// DateTimeIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) DateTimeIsValid() bool {
	return o.dateTimeIsValid
}

// DateTimeIsNull returns true if the related database value is null.
func (o *typeTestBase) DateTimeIsNull() bool {
	return o.dateTimeIsNull
}

// DateTime_I returns the loaded value of DateTime as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) DateTime_I() interface{} {
	if o._restored && !o.dateTimeIsValid {
		panic("dateTime was not selected in the last query and has not been set, and so is not valid")
	} else if o.dateTimeIsNull {
		return nil
	}
	return o.dateTime
}

// SetDateTime prepares for setting the date_time value in the database.
//
// Pass nil to set it to a NULL value in the database.
//
// The input will immediately be converted to UTC time.
func (o *typeTestBase) SetDateTime(i interface{}) {
	o.dateTimeIsValid = true
	if i == nil {
		if !o.dateTimeIsNull {
			o.dateTimeIsNull = true
			o.dateTimeIsDirty = true
			o.dateTime = time.Time{}
		}
	} else {
		v := i.(time.Time)
		v = v.UTC()

		if o.dateTimeIsNull ||
			!o._restored ||
			o.dateTime != v {
			o.dateTimeIsNull = false
			o.dateTime = v
			o.dateTimeIsDirty = true
		}
	}
}

// Ts returns the loaded value of Ts.
func (o *typeTestBase) Ts() time.Time {
	if o._restored && !o.tsIsValid {
		panic("Ts was not selected in the last query and has not been set, and so is not valid")
	}
	return o.ts
}

// TsIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TsIsValid() bool {
	return o.tsIsValid
}

// TsIsNull returns true if the related database value is null.
func (o *typeTestBase) TsIsNull() bool {
	return o.tsIsNull
}

// Ts_I returns the loaded value of Ts as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) Ts_I() interface{} {
	if o._restored && !o.tsIsValid {
		panic("ts was not selected in the last query and has not been set, and so is not valid")
	} else if o.tsIsNull {
		return nil
	}
	return o.ts
}

// TestInt returns the loaded value of TestInt.
func (o *typeTestBase) TestInt() int {
	if o._restored && !o.testIntIsValid {
		panic("TestInt was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testInt
}

// TestIntIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestIntIsValid() bool {
	return o.testIntIsValid
}

// TestIntIsNull returns true if the related database value is null.
func (o *typeTestBase) TestIntIsNull() bool {
	return o.testIntIsNull
}

// TestInt_I returns the loaded value of TestInt as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) TestInt_I() interface{} {
	if o._restored && !o.testIntIsValid {
		panic("testInt was not selected in the last query and has not been set, and so is not valid")
	} else if o.testIntIsNull {
		return nil
	}
	return o.testInt
}

// SetTestInt prepares for setting the test_int value in the database.
//
// Pass nil to set it to a NULL value in the database.
func (o *typeTestBase) SetTestInt(i interface{}) {
	o.testIntIsValid = true
	if i == nil {
		if !o.testIntIsNull {
			o.testIntIsNull = true
			o.testIntIsDirty = true
			o.testInt = 5
		}
	} else {
		v := i.(int)

		if o.testIntIsNull ||
			!o._restored ||
			o.testInt != v {
			o.testIntIsNull = false
			o.testInt = v
			o.testIntIsDirty = true
		}
	}
}

// TestFloat returns the loaded value of TestFloat.
func (o *typeTestBase) TestFloat() float32 {
	if o._restored && !o.testFloatIsValid {
		panic("TestFloat was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testFloat
}

// TestFloatIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestFloatIsValid() bool {
	return o.testFloatIsValid
}

// TestFloatIsNull returns true if the related database value is null.
func (o *typeTestBase) TestFloatIsNull() bool {
	return o.testFloatIsNull
}

// TestFloat_I returns the loaded value of TestFloat as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) TestFloat_I() interface{} {
	if o._restored && !o.testFloatIsValid {
		panic("testFloat was not selected in the last query and has not been set, and so is not valid")
	} else if o.testFloatIsNull {
		return nil
	}
	return o.testFloat
}

// SetTestFloat prepares for setting the test_float value in the database.
//
// Pass nil to set it to a NULL value in the database.
func (o *typeTestBase) SetTestFloat(i interface{}) {
	o.testFloatIsValid = true
	if i == nil {
		if !o.testFloatIsNull {
			o.testFloatIsNull = true
			o.testFloatIsDirty = true
			o.testFloat = 0
		}
	} else {
		v := i.(float32)

		if o.testFloatIsNull ||
			!o._restored ||
			o.testFloat != v {
			o.testFloatIsNull = false
			o.testFloat = v
			o.testFloatIsDirty = true
		}
	}
}

// TestDouble returns the loaded value of TestDouble.
func (o *typeTestBase) TestDouble() float64 {
	if o._restored && !o.testDoubleIsValid {
		panic("TestDouble was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testDouble
}

// TestDoubleIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestDoubleIsValid() bool {
	return o.testDoubleIsValid
}

// SetTestDouble sets the value of TestDouble in the object, to be saved later using the Save() function.
func (o *typeTestBase) SetTestDouble(testDouble float64) {
	o.testDoubleIsValid = true
	if o.testDouble != testDouble || !o._restored {
		o.testDouble = testDouble
		o.testDoubleIsDirty = true
	}

}

// TestText returns the loaded value of TestText.
func (o *typeTestBase) TestText() string {
	if o._restored && !o.testTextIsValid {
		panic("TestText was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testText
}

// TestTextIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestTextIsValid() bool {
	return o.testTextIsValid
}

// TestTextIsNull returns true if the related database value is null.
func (o *typeTestBase) TestTextIsNull() bool {
	return o.testTextIsNull
}

// TestText_I returns the loaded value of TestText as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) TestText_I() interface{} {
	if o._restored && !o.testTextIsValid {
		panic("testText was not selected in the last query and has not been set, and so is not valid")
	} else if o.testTextIsNull {
		return nil
	}
	return o.testText
}

// SetTestText prepares for setting the test_text value in the database.
//
// Pass nil to set it to a NULL value in the database.
func (o *typeTestBase) SetTestText(i interface{}) {
	o.testTextIsValid = true
	if i == nil {
		if !o.testTextIsNull {
			o.testTextIsNull = true
			o.testTextIsDirty = true
			o.testText = ""
		}
	} else {
		v := i.(string)

		if utf8.RuneCountInString(v) > TypeTestTestTextMaxLength {
			panic("attempted to set TypeTest.TestText to a value larger than its maximum length in runes")
		}
		if o.testTextIsNull ||
			!o._restored ||
			o.testText != v {
			o.testTextIsNull = false
			o.testText = v
			o.testTextIsDirty = true
		}
	}
}

// TestBit returns the loaded value of TestBit.
func (o *typeTestBase) TestBit() bool {
	if o._restored && !o.testBitIsValid {
		panic("TestBit was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testBit
}

// TestBitIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestBitIsValid() bool {
	return o.testBitIsValid
}

// TestBitIsNull returns true if the related database value is null.
func (o *typeTestBase) TestBitIsNull() bool {
	return o.testBitIsNull
}

// TestBit_I returns the loaded value of TestBit as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) TestBit_I() interface{} {
	if o._restored && !o.testBitIsValid {
		panic("testBit was not selected in the last query and has not been set, and so is not valid")
	} else if o.testBitIsNull {
		return nil
	}
	return o.testBit
}

// SetTestBit prepares for setting the test_bit value in the database.
//
// Pass nil to set it to a NULL value in the database.
func (o *typeTestBase) SetTestBit(i interface{}) {
	o.testBitIsValid = true
	if i == nil {
		if !o.testBitIsNull {
			o.testBitIsNull = true
			o.testBitIsDirty = true
			o.testBit = false
		}
	} else {
		v := i.(bool)
		if o.testBitIsNull ||
			!o._restored ||
			o.testBit != v {
			o.testBitIsNull = false
			o.testBit = v
			o.testBitIsDirty = true
		}
	}
}

// TestVarchar returns the loaded value of TestVarchar.
func (o *typeTestBase) TestVarchar() string {
	if o._restored && !o.testVarcharIsValid {
		panic("TestVarchar was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testVarchar
}

// TestVarcharIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestVarcharIsValid() bool {
	return o.testVarcharIsValid
}

// TestVarcharIsNull returns true if the related database value is null.
func (o *typeTestBase) TestVarcharIsNull() bool {
	return o.testVarcharIsNull
}

// TestVarchar_I returns the loaded value of TestVarchar as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *typeTestBase) TestVarchar_I() interface{} {
	if o._restored && !o.testVarcharIsValid {
		panic("testVarchar was not selected in the last query and has not been set, and so is not valid")
	} else if o.testVarcharIsNull {
		return nil
	}
	return o.testVarchar
}

// SetTestVarchar prepares for setting the test_varchar value in the database.
//
// Pass nil to set it to a NULL value in the database.
func (o *typeTestBase) SetTestVarchar(i interface{}) {
	o.testVarcharIsValid = true
	if i == nil {
		if !o.testVarcharIsNull {
			o.testVarcharIsNull = true
			o.testVarcharIsDirty = true
			o.testVarchar = ""
		}
	} else {
		v := i.(string)

		if utf8.RuneCountInString(v) > TypeTestTestVarcharMaxLength {
			panic("attempted to set TypeTest.TestVarchar to a value larger than its maximum length in runes")
		}
		if o.testVarcharIsNull ||
			!o._restored ||
			o.testVarchar != v {
			o.testVarcharIsNull = false
			o.testVarchar = v
			o.testVarcharIsDirty = true
		}
	}
}

// TestBlob returns the loaded value of TestBlob.
func (o *typeTestBase) TestBlob() []byte {
	if o._restored && !o.testBlobIsValid {
		panic("TestBlob was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testBlob
}

// TestBlobIsValid returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestBlobIsValid() bool {
	return o.testBlobIsValid
}

// SetTestBlob sets the value of TestBlob in the object, to be saved later using the Save() function.
func (o *typeTestBase) SetTestBlob(testBlob []byte) {
	o.testBlobIsValid = true
	if len(testBlob) > TypeTestTestBlobMaxLength {
		panic("attempted to set TypeTest.TestBlob to a value larger than its maximum length")
	}
	o.testBlob = testBlob // TODO: Copy bytes??
	o.testBlobIsDirty = true

}

// GetAlias returns the alias for the given key.
func (o *typeTestBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *typeTestBase) IsNew() bool {
	return !o._restored
}

// LoadTypeTest returns a TypeTest from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [TypeTestsBuilder.Select] for more info.
func LoadTypeTest(ctx context.Context, id string, selectNodes ...query.Node) *TypeTest {
	return queryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().ID(), id)).
		Select(selectNodes...).
		Get()
}

// HasTypeTest returns true if a TypeTest with the given primaryKey exists in the database.
// doc: type=TypeTest
func HasTypeTest(ctx context.Context, id string) bool {
	return queryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().ID(), id)).
		Count(false) == 1
}

// The TypeTestBuilder uses the query.BuilderI interface to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, LoadCursor, Get, Count, or Delete
type TypeTestBuilder interface {
	// Join(alias string, joinedTable query.Node, condition query.Node) TypeTestBuilder

	// Expand turns a Reverse or ManyMany node into individual rows.
	Expand(n query.Expander) TypeTestBuilder

	// Where adds a condition to filter what gets selected.
	// Calling Where multiple times will AND the conditions together.
	Where(c query.Node) TypeTestBuilder

	// OrderBy specifies how the resulting data should be sorted.
	// By default, the given nodes are sorted in ascending order.
	// Add Descending() to the node to specify that it should be sorted in descending order.
	OrderBy(nodes ...query.Sorter) TypeTestBuilder

	// Limit will return a subset of the data, limited to the offset and number of rows specified.
	// For large data sets and specific types of queries, this can be slow, because it will perform
	// the entire query before computing the limit.
	// You cannot limit a query that has embedded arrays.
	Limit(maxRowCount int, offset int) TypeTestBuilder

	// Select optimizes the query to only return the specified fields.
	// Once you put a Select in your query, you must specify all the fields that you will eventually read out.
	// Some fields, like primary keys, are always selected.
	// If you are using a GroupBy, most database drivers will only allow selecting on fields in the GroupBy, and
	// doing otherwise will result in an error.
	Select(nodes ...query.Node) TypeTestBuilder

	// Calculation adds a calculation node with an aliased name.
	// After the query, you can read the data using GetAlias() on a returned object.
	Calculation(name string, n query.Aliaser) TypeTestBuilder

	// Distinct removes duplicates from the results of the query.
	// Adding a Select() is usually required.
	Distinct() TypeTestBuilder

	// GroupBy controls how results are grouped when using aggregate functions with Calculation.
	GroupBy(nodes ...query.Node) TypeTestBuilder

	// Having does additional filtering on the results of the query after the query is performed.
	Having(node query.Node) TypeTestBuilder

	// Load terminates the query builder, performs the query, and returns a slice of TypeTest objects.
	// If there are any errors, nil is returned and the specific error is stored in the context.
	// If no results come back from the query, it will return a non-nil empty slice.
	Load() []*TypeTest
	// Load terminates the query builder, performs the query, and returns a slice of interfaces.
	// This can then satisfy a general interface that loads arrays of objects.
	// If there are any errors, nil is returned and the specific error is stored in the context.
	// If no results come back from the query, it will return a non-nil empty slice.
	LoadI() []any

	// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
	//
	// A query cursor is useful for dealing with large amounts of query results. However, there are some
	// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
	// many-to-many or reverse relationships that will create an array of values.
	//
	// Call Next() on the returned cursor object to step through the results. Make sure you call Close
	// on the cursor object when you are done. You should use
	//   defer cursor.Close()
	// to make sure the cursor gets closed.
	LoadCursor() typeTestsCursor

	// Get is a convenience method to return only the first item found in a query.
	// The entire query is performed, so you should generally use this only if you know
	// you are selecting on one or very few items.
	//
	// If an error occurs, or no results are found, a nil is returned.
	// In the case of an error, the error is returned in the context.
	Get() *TypeTest

	// Count terminates a query and returns just the number of items selected.
	// distinct wll count the number of distinct items, ignoring duplicates.
	// nodes will select individual fields, and should be accompanied by a GroupBy.
	Count(distinct bool, nodes ...query.Node) int

	// Delete uses the query builder to delete a group of records that match the criteria
	Delete()

	// Subquery terminates the query builder and tags it as a subquery within a larger query.
	// You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
	// Generally you would use this as a node to a Calculation function on the surrounding query builder.
	// Subquery() *query.SubqueryNode

}

type typeTestQueryBuilder struct {
	builder *query.Builder
}

func newTypeTestBuilder(ctx context.Context) TypeTestBuilder {
	b := typeTestQueryBuilder{
		builder: query.NewBuilder(ctx, node.TypeTest()),
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of TypeTest objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *typeTestQueryBuilder) Load() (typeTests []*TypeTest) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
	if results == nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(TypeTest)
		o.load(item, o)
		typeTests = append(typeTests, o)
	}
	return
}

// Load terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a general interface that loads arrays of objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *typeTestQueryBuilder) LoadI() (typeTests []any) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
	if results == nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(TypeTest)
		o.load(item, o)
		typeTests = append(typeTests, o)
	}
	return
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *typeTestQueryBuilder) LoadCursor() typeTestsCursor {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd_unit")
	result := database.BuilderQuery(b.builder.Ctx, b.builder)
	if result == nil {
		return typeTestsCursor{}
	}
	cursor := result.(query.CursorI)

	return typeTestsCursor{cursor}
}

type typeTestsCursor struct {
	query.CursorI
}

// Next returns the current TypeTest object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c typeTestsCursor) Next() *TypeTest {
	if c.CursorI == nil {
		return nil
	}

	row := c.CursorI.Next()
	if row == nil {
		return nil
	}
	o := new(TypeTest)
	o.load(row, o)
	return o
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
//
// If an error occurs, or no results are found, a nil is returned.
// In the case of an error, the error is returned in the context.
func (b *typeTestQueryBuilder) Get() *TypeTest {
	results := b.Load()
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *typeTestQueryBuilder) Expand(n query.Expander) TypeTestBuilder {
	b.builder.Expand(n)
	return b
}

/*
// Join attaches the table referred to by joinedTable, filtering the join process using the operation node specified
// by condition.
// The joinedTable node will be modified by this process so that you can use it in subsequent builder operations.
// Call GetAlias to return the resulting object from the query result.
func (b *typeTestQueryBuilder) Join(alias string, joinedTable query.Node, condition query.Node) TypeTestBuilder {
    if query.RootNode(n).TableName_() != "type_test" {
        panic("you can only join a node that is rooted at node.TypeTest()")
    }
    // TODO: make sure joinedTable is a table node
	b.builder.Join(alias, joinedTable, condition)
	return b
}
*/

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *typeTestQueryBuilder) Where(c query.Node) TypeTestBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *typeTestQueryBuilder) OrderBy(nodes ...query.Sorter) TypeTestBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *typeTestQueryBuilder) Limit(maxRowCount int, offset int) TypeTestBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the type_test table will be queried and loaded.
// If nodes contains columns from the type_test table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *typeTestQueryBuilder) Select(nodes ...query.Node) TypeTestBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds a calculation node with an aliased name.
// After the query, you can read the data using GetAlias() on the returned object.
func (b *typeTestQueryBuilder) Calculation(name string, n query.Aliaser) TypeTestBuilder {
	b.builder.Calculation(name, n)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *typeTestQueryBuilder) Distinct() TypeTestBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *typeTestQueryBuilder) GroupBy(nodes ...query.Node) TypeTestBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *typeTestQueryBuilder) Having(node query.Node) TypeTestBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items selected.
// distinct wll count the number of distinct items, ignoring duplicates.
// nodes will select individual fields, and should be accompanied by a GroupBy.
func (b *typeTestQueryBuilder) Count(distinct bool, nodes ...query.Node) int {
	b.builder.Command = query.BuilderCommandCount
	if distinct {
		b.builder.Distinct()
	}
	database := db.GetDatabase("goradd_unit")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
	if results == nil {
		return 0
	}
	return results.(int)
}

// Delete uses the query builder to delete a group of records that match the criteria.
func (b *typeTestQueryBuilder) Delete() {
	b.builder.Command = query.BuilderCommandDelete
	database := db.GetDatabase("goradd_unit")
	database.BuilderQuery(b.builder.Ctx, b.builder)
	broadcast.BulkChange(b.builder.Context(), "goradd_unit", "type_test")
}

/*
// Subquery terminates the query builder and tags it as a subquery within a larger query.
// You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
// Generally you would use this as a node to a Calculation function on the surrounding query builder.
func (b *typeTestQueryBuilder)  Subquery() *query.SubqueryNode {
	 return b.builder.Subquery()
}
*/

// CountTypeTestByID queries the database and returns the number of TypeTest objects that
// have id.
// doc: type=TypeTest
func CountTypeTestByID(ctx context.Context, id string) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().ID(), id)).Count(false))
}

// CountTypeTestByDate queries the database and returns the number of TypeTest objects that
// have date.
// doc: type=TypeTest
func CountTypeTestByDate(ctx context.Context, date time.Time) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().Date(), date)).Count(false))
}

// CountTypeTestByTime queries the database and returns the number of TypeTest objects that
// have time.
// doc: type=TypeTest
func CountTypeTestByTime(ctx context.Context, time time.Time) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().Time(), time)).Count(false))
}

// CountTypeTestByDateTime queries the database and returns the number of TypeTest objects that
// have dateTime.
// doc: type=TypeTest
func CountTypeTestByDateTime(ctx context.Context, dateTime time.Time) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().DateTime(), dateTime)).Count(false))
}

// CountTypeTestByTs queries the database and returns the number of TypeTest objects that
// have ts.
// doc: type=TypeTest
func CountTypeTestByTs(ctx context.Context, ts time.Time) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().Ts(), ts)).Count(false))
}

// CountTypeTestByTestInt queries the database and returns the number of TypeTest objects that
// have testInt.
// doc: type=TypeTest
func CountTypeTestByTestInt(ctx context.Context, testInt int) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestInt(), testInt)).Count(false))
}

// CountTypeTestByTestFloat queries the database and returns the number of TypeTest objects that
// have testFloat.
// doc: type=TypeTest
func CountTypeTestByTestFloat(ctx context.Context, testFloat float32) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestFloat(), testFloat)).Count(false))
}

// CountTypeTestByTestDouble queries the database and returns the number of TypeTest objects that
// have testDouble.
// doc: type=TypeTest
func CountTypeTestByTestDouble(ctx context.Context, testDouble float64) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestDouble(), testDouble)).Count(false))
}

// CountTypeTestByTestText queries the database and returns the number of TypeTest objects that
// have testText.
// doc: type=TypeTest
func CountTypeTestByTestText(ctx context.Context, testText string) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestText(), testText)).Count(false))
}

// CountTypeTestByTestBit queries the database and returns the number of TypeTest objects that
// have testBit.
// doc: type=TypeTest
func CountTypeTestByTestBit(ctx context.Context, testBit bool) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestBit(), testBit)).Count(false))
}

// CountTypeTestByTestVarchar queries the database and returns the number of TypeTest objects that
// have testVarchar.
// doc: type=TypeTest
func CountTypeTestByTestVarchar(ctx context.Context, testVarchar string) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestVarchar(), testVarchar)).Count(false))
}

// CountTypeTestByTestBlob queries the database and returns the number of TypeTest objects that
// have testBlob.
// doc: type=TypeTest
func CountTypeTestByTestBlob(ctx context.Context, testBlob []byte) int {
	return int(queryTypeTests(ctx).Where(op.Equal(node.TypeTest().TestBlob(), testBlob)).Count(false))
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
func (o *typeTestBase) load(m map[string]interface{}, objThis *TypeTest) {

	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsValid = true
			o.idIsDirty = false

			o._originalPK = o.id

		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsValid = false
		o.id = ""
	}

	if v, ok := m["date"]; ok {
		if v == nil {
			o.date = time.Time{}
			o.dateIsNull = true
			o.dateIsValid = true
			o.dateIsDirty = false
		} else if o.date, ok = v.(time.Time); ok {
			o.dateIsNull = false
			o.dateIsValid = true
			o.dateIsDirty = false
		} else {
			panic("Wrong type found for date.")
		}
	} else {
		o.dateIsValid = false
		o.dateIsNull = true
		o.date = time.Time{}
	}

	if v, ok := m["time"]; ok {
		if v == nil {
			o.time = time.Time{}
			o.timeIsNull = true
			o.timeIsValid = true
			o.timeIsDirty = false
		} else if o.time, ok = v.(time.Time); ok {
			o.timeIsNull = false
			o.timeIsValid = true
			o.timeIsDirty = false
		} else {
			panic("Wrong type found for time.")
		}
	} else {
		o.timeIsValid = false
		o.timeIsNull = true
		o.time = time.Time{}
	}

	if v, ok := m["date_time"]; ok {
		if v == nil {
			o.dateTime = time.Time{}
			o.dateTimeIsNull = true
			o.dateTimeIsValid = true
			o.dateTimeIsDirty = false
		} else if o.dateTime, ok = v.(time.Time); ok {
			o.dateTimeIsNull = false
			o.dateTimeIsValid = true
			o.dateTimeIsDirty = false
		} else {
			panic("Wrong type found for date_time.")
		}
	} else {
		o.dateTimeIsValid = false
		o.dateTimeIsNull = true
		o.dateTime = time.Time{}
	}

	if v, ok := m["ts"]; ok {
		if v == nil {
			o.ts = time.Time{}
			o.tsIsNull = true
			o.tsIsValid = true
			o.tsIsDirty = false
		} else if o.ts, ok = v.(time.Time); ok {
			o.tsIsNull = false
			o.tsIsValid = true
			o.tsIsDirty = false
		} else {
			panic("Wrong type found for ts.")
		}
	} else {
		o.tsIsValid = false
		o.tsIsNull = true
		o.ts = time.Time{}
	}

	if v, ok := m["test_int"]; ok {
		if v == nil {
			o.testInt = 5
			o.testIntIsNull = true
			o.testIntIsValid = true
			o.testIntIsDirty = false
		} else if o.testInt, ok = v.(int); ok {
			o.testIntIsNull = false
			o.testIntIsValid = true
			o.testIntIsDirty = false
		} else {
			panic("Wrong type found for test_int.")
		}
	} else {
		o.testIntIsValid = false
		o.testIntIsNull = true
		o.testInt = 5
	}

	if v, ok := m["test_float"]; ok {
		if v == nil {
			o.testFloat = 0
			o.testFloatIsNull = true
			o.testFloatIsValid = true
			o.testFloatIsDirty = false
		} else if o.testFloat, ok = v.(float32); ok {
			o.testFloatIsNull = false
			o.testFloatIsValid = true
			o.testFloatIsDirty = false
		} else {
			panic("Wrong type found for test_float.")
		}
	} else {
		o.testFloatIsValid = false
		o.testFloatIsNull = true
		o.testFloat = 0
	}

	if v, ok := m["test_double"]; ok && v != nil {
		if o.testDouble, ok = v.(float64); ok {
			o.testDoubleIsValid = true
			o.testDoubleIsDirty = false

		} else {
			panic("Wrong type found for test_double.")
		}
	} else {
		o.testDoubleIsValid = false
		o.testDouble = 0
	}

	if v, ok := m["test_text"]; ok {
		if v == nil {
			o.testText = ""
			o.testTextIsNull = true
			o.testTextIsValid = true
			o.testTextIsDirty = false
		} else if o.testText, ok = v.(string); ok {
			o.testTextIsNull = false
			o.testTextIsValid = true
			o.testTextIsDirty = false
		} else {
			panic("Wrong type found for test_text.")
		}
	} else {
		o.testTextIsValid = false
		o.testTextIsNull = true
		o.testText = ""
	}

	if v, ok := m["test_bit"]; ok {
		if v == nil {
			o.testBit = false
			o.testBitIsNull = true
			o.testBitIsValid = true
			o.testBitIsDirty = false
		} else if o.testBit, ok = v.(bool); ok {
			o.testBitIsNull = false
			o.testBitIsValid = true
			o.testBitIsDirty = false
		} else {
			panic("Wrong type found for test_bit.")
		}
	} else {
		o.testBitIsValid = false
		o.testBitIsNull = true
		o.testBit = false
	}

	if v, ok := m["test_varchar"]; ok {
		if v == nil {
			o.testVarchar = ""
			o.testVarcharIsNull = true
			o.testVarcharIsValid = true
			o.testVarcharIsDirty = false
		} else if o.testVarchar, ok = v.(string); ok {
			o.testVarcharIsNull = false
			o.testVarcharIsValid = true
			o.testVarcharIsDirty = false
		} else {
			panic("Wrong type found for test_varchar.")
		}
	} else {
		o.testVarcharIsValid = false
		o.testVarcharIsNull = true
		o.testVarchar = ""
	}

	if v, ok := m["test_blob"]; ok && v != nil {
		if o.testBlob, ok = v.([]byte); ok {
			o.testBlobIsValid = true
			o.testBlobIsDirty = false

		} else {
			panic("Wrong type found for test_blob.")
		}
	} else {
		o.testBlobIsValid = false
		o.testBlob = []byte(nil)
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = map[string]interface{}(v.(db.ValueMap))
	}

	o._restored = true

}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
func (o *typeTestBase) Save(ctx context.Context) {
	if o._restored {
		o.update(ctx)
	} else {
		o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
func (o *typeTestBase) update(ctx context.Context) {
	if !o._restored {
		panic("cannot update a record that was not originally read from the database.")
	}

	var modifiedFields map[string]interface{}
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {

		// TODO: Perform all reads and consistency checks before saves

		// Save all modified fields to the database
		modifiedFields = o.getModifiedFields()
		if len(modifiedFields) != 0 {
			d.Update(ctx, "type_test", modifiedFields, map[string]any{"id": o._originalPK})
		}

	}) // transaction

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd_unit", "type_test", o._originalPK, all.SortedKeys(modifiedFields)...)
	}
}

// insert will insert the object into the database. Related items will be saved.
func (o *typeTestBase) insert(ctx context.Context) {
	d := Database()
	db.ExecuteTransaction(ctx, d, func() {

		if !o.testDoubleIsValid {
			panic("a value for TestDouble is required, and there is no default value. Call SetTestDouble() before inserting the record.")
		}

		if !o.testBlobIsValid {
			panic("a value for TestBlob is required, and there is no default value. Call SetTestBlob() before inserting the record.")
		}

		m := o.getValidFields()

		id := d.Insert(ctx, "type_test", m)
		o.id = id
		o._originalPK = id

	}) // transaction

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd_unit", "type_test", o.PrimaryKey())
}

// getModifiedFields returns the database columns that have been modified. This
// will determine which specific fields are sent to the database to be changed.
func (o *typeTestBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}
	if o.dateIsDirty {
		if o.dateIsNull {
			fields["date"] = nil
		} else {
			fields["date"] = o.date
		}
	}
	if o.timeIsDirty {
		if o.timeIsNull {
			fields["time"] = nil
		} else {
			fields["time"] = o.time
		}
	}
	if o.dateTimeIsDirty {
		if o.dateTimeIsNull {
			fields["date_time"] = nil
		} else {
			fields["date_time"] = o.dateTime
		}
	}
	if o.tsIsDirty {
		if o.tsIsNull {
			fields["ts"] = nil
		} else {
			fields["ts"] = o.ts
		}
	}
	if o.testIntIsDirty {
		if o.testIntIsNull {
			fields["test_int"] = nil
		} else {
			fields["test_int"] = o.testInt
		}
	}
	if o.testFloatIsDirty {
		if o.testFloatIsNull {
			fields["test_float"] = nil
		} else {
			fields["test_float"] = o.testFloat
		}
	}
	if o.testDoubleIsDirty {
		fields["test_double"] = o.testDouble
	}
	if o.testTextIsDirty {
		if o.testTextIsNull {
			fields["test_text"] = nil
		} else {
			fields["test_text"] = o.testText
		}
	}
	if o.testBitIsDirty {
		if o.testBitIsNull {
			fields["test_bit"] = nil
		} else {
			fields["test_bit"] = o.testBit
		}
	}
	if o.testVarcharIsDirty {
		if o.testVarcharIsNull {
			fields["test_varchar"] = nil
		} else {
			fields["test_varchar"] = o.testVarchar
		}
	}
	if o.testBlobIsDirty {
		fields["test_blob"] = o.testBlob
	}
	return
}

// getValidFields returns the fields that have valid data in them in a form ready to send to the database.
func (o *typeTestBase) getValidFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.dateIsValid {
		if o.dateIsNull {
			fields["date"] = nil
		} else {
			fields["date"] = o.date
		}
	}
	if o.timeIsValid {
		if o.timeIsNull {
			fields["time"] = nil
		} else {
			fields["time"] = o.time
		}
	}
	if o.dateTimeIsValid {
		if o.dateTimeIsNull {
			fields["date_time"] = nil
		} else {
			fields["date_time"] = o.dateTime
		}
	}
	if o.tsIsValid {
		if o.tsIsNull {
			fields["ts"] = nil
		} else {
			fields["ts"] = o.ts
		}
	}
	if o.testIntIsValid {
		if o.testIntIsNull {
			fields["test_int"] = nil
		} else {
			fields["test_int"] = o.testInt
		}
	}
	if o.testFloatIsValid {
		if o.testFloatIsNull {
			fields["test_float"] = nil
		} else {
			fields["test_float"] = o.testFloat
		}
	}
	if o.testDoubleIsValid {
		fields["test_double"] = o.testDouble
	}
	if o.testTextIsValid {
		if o.testTextIsNull {
			fields["test_text"] = nil
		} else {
			fields["test_text"] = o.testText
		}
	}
	if o.testBitIsValid {
		if o.testBitIsNull {
			fields["test_bit"] = nil
		} else {
			fields["test_bit"] = o.testBit
		}
	}
	if o.testVarcharIsValid {
		if o.testVarcharIsNull {
			fields["test_varchar"] = nil
		} else {
			fields["test_varchar"] = o.testVarchar
		}
	}
	if o.testBlobIsValid {
		fields["test_blob"] = o.testBlob
	}
	return
}

// Delete deletes the record from the database.
func (o *typeTestBase) Delete(ctx context.Context) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()
	d.Delete(ctx, "type_test", map[string]any{"ID": o.id})
	broadcast.Delete(ctx, "goradd_unit", "type_test", fmt.Sprint(o.id))
}

// deleteTypeTest deletes the associated record from the database.
func deleteTypeTest(ctx context.Context, pk string) {
	d := db.GetDatabase("goradd_unit")
	d.Delete(ctx, "type_test", map[string]any{"ID": pk})
	broadcast.Delete(ctx, "goradd_unit", "type_test", fmt.Sprint(pk))
}

// resetDirtyStatus resets the dirty status of every field in the object.
func (o *typeTestBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.dateIsDirty = false
	o.timeIsDirty = false
	o.dateTimeIsDirty = false
	o.tsIsDirty = false
	o.testIntIsDirty = false
	o.testFloatIsDirty = false
	o.testDoubleIsDirty = false
	o.testTextIsDirty = false
	o.testBitIsDirty = false
	o.testVarcharIsDirty = false
	o.testBlobIsDirty = false

}

// IsDirty returns true if the object has been changed since it was read from the database.
func (o *typeTestBase) IsDirty() (dirty bool) {
	dirty = o.idIsDirty ||
		o.dateIsDirty ||
		o.timeIsDirty ||
		o.dateTimeIsDirty ||
		o.tsIsDirty ||
		o.testIntIsDirty ||
		o.testFloatIsDirty ||
		o.testDoubleIsDirty ||
		o.testTextIsDirty ||
		o.testBitIsDirty ||
		o.testVarcharIsDirty ||
		o.testBlobIsDirty

	return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *typeTestBase) Get(key string) interface{} {

	switch key {

	case "ID":
		if !o.idIsValid {
			return nil
		}
		return o.id

	case "Date":
		if !o.dateIsValid {
			return nil
		}
		return o.date

	case "Time":
		if !o.timeIsValid {
			return nil
		}
		return o.time

	case "DateTime":
		if !o.dateTimeIsValid {
			return nil
		}
		return o.dateTime

	case "Ts":
		if !o.tsIsValid {
			return nil
		}
		return o.ts

	case "TestInt":
		if !o.testIntIsValid {
			return nil
		}
		return o.testInt

	case "TestFloat":
		if !o.testFloatIsValid {
			return nil
		}
		return o.testFloat

	case "TestDouble":
		if !o.testDoubleIsValid {
			return nil
		}
		return o.testDouble

	case "TestText":
		if !o.testTextIsValid {
			return nil
		}
		return o.testText

	case "TestBit":
		if !o.testBitIsValid {
			return nil
		}
		return o.testBit

	case "TestVarchar":
		if !o.testVarcharIsValid {
			return nil
		}
		return o.testVarchar

	case "TestBlob":
		if !o.testBlobIsValid {
			return nil
		}
		return o.testBlob

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *typeTestBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err := encoder.Encode(o.id); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.id: %w", err)
	}
	if err := encoder.Encode(o.idIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.idIsValid: %w", err)
	}
	if err := encoder.Encode(o.idIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.idIsDirty: %w", err)
	}

	if err := encoder.Encode(o.date); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.date: %w", err)
	}
	if err := encoder.Encode(o.dateIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateIsNull: %w", err)
	}
	if err := encoder.Encode(o.dateIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateIsValid: %w", err)
	}
	if err := encoder.Encode(o.dateIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateIsDirty: %w", err)
	}

	if err := encoder.Encode(o.time); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.time: %w", err)
	}
	if err := encoder.Encode(o.timeIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.timeIsNull: %w", err)
	}
	if err := encoder.Encode(o.timeIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.timeIsValid: %w", err)
	}
	if err := encoder.Encode(o.timeIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.timeIsDirty: %w", err)
	}

	if err := encoder.Encode(o.dateTime); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateTime: %w", err)
	}
	if err := encoder.Encode(o.dateTimeIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateTimeIsNull: %w", err)
	}
	if err := encoder.Encode(o.dateTimeIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateTimeIsValid: %w", err)
	}
	if err := encoder.Encode(o.dateTimeIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.dateTimeIsDirty: %w", err)
	}

	if err := encoder.Encode(o.ts); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.ts: %w", err)
	}
	if err := encoder.Encode(o.tsIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.tsIsNull: %w", err)
	}
	if err := encoder.Encode(o.tsIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.tsIsValid: %w", err)
	}
	if err := encoder.Encode(o.tsIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.tsIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testInt); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testInt: %w", err)
	}
	if err := encoder.Encode(o.testIntIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testIntIsNull: %w", err)
	}
	if err := encoder.Encode(o.testIntIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testIntIsValid: %w", err)
	}
	if err := encoder.Encode(o.testIntIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testIntIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testFloat); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testFloat: %w", err)
	}
	if err := encoder.Encode(o.testFloatIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testFloatIsNull: %w", err)
	}
	if err := encoder.Encode(o.testFloatIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testFloatIsValid: %w", err)
	}
	if err := encoder.Encode(o.testFloatIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testFloatIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testDouble); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testDouble: %w", err)
	}
	if err := encoder.Encode(o.testDoubleIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testDoubleIsValid: %w", err)
	}
	if err := encoder.Encode(o.testDoubleIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testDoubleIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testText); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testText: %w", err)
	}
	if err := encoder.Encode(o.testTextIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testTextIsNull: %w", err)
	}
	if err := encoder.Encode(o.testTextIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testTextIsValid: %w", err)
	}
	if err := encoder.Encode(o.testTextIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testTextIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testBit); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBit: %w", err)
	}
	if err := encoder.Encode(o.testBitIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBitIsNull: %w", err)
	}
	if err := encoder.Encode(o.testBitIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBitIsValid: %w", err)
	}
	if err := encoder.Encode(o.testBitIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBitIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testVarchar); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testVarchar: %w", err)
	}
	if err := encoder.Encode(o.testVarcharIsNull); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testVarcharIsNull: %w", err)
	}
	if err := encoder.Encode(o.testVarcharIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testVarcharIsValid: %w", err)
	}
	if err := encoder.Encode(o.testVarcharIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testVarcharIsDirty: %w", err)
	}

	if err := encoder.Encode(o.testBlob); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBlob: %w", err)
	}
	if err := encoder.Encode(o.testBlobIsValid); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBlobIsValid: %w", err)
	}
	if err := encoder.Encode(o.testBlobIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest.testBlobIsDirty: %w", err)
	}

	if o._aliases == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o._aliases); err != nil {
			return nil, fmt.Errorf("error encoding TypeTest._aliases: %w", err)
		}
	}

	if err := encoder.Encode(o._restored); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest._restored: %w", err)
	}
	if err := encoder.Encode(o._originalPK); err != nil {
		return nil, fmt.Errorf("error encoding TypeTest._originalPK: %w", err)
	}

	return buf.Bytes(), nil

	return buf.Bytes(), nil
}

// UnmarshalBinary converts a structure that was created with MarshalBinary into a TypeTest object.
func (o *typeTestBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)
	var isPtr bool

	_ = isPtr
	if err = dec.Decode(&o.id); err != nil {
		return fmt.Errorf("error decoding TypeTest.id: %w", err)
	}
	if err = dec.Decode(&o.idIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.idIsValid: %w", err)
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.idIsDirty: %w", err)
	}

	if err = dec.Decode(&o.date); err != nil {
		return fmt.Errorf("error decoding TypeTest.date: %w", err)
	}
	if err = dec.Decode(&o.dateIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsNull: %w", err)
	}
	if err = dec.Decode(&o.dateIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsValid: %w", err)
	}
	if err = dec.Decode(&o.dateIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsDirty: %w", err)
	}

	if err = dec.Decode(&o.time); err != nil {
		return fmt.Errorf("error decoding TypeTest.time: %w", err)
	}
	if err = dec.Decode(&o.timeIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsNull: %w", err)
	}
	if err = dec.Decode(&o.timeIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsValid: %w", err)
	}
	if err = dec.Decode(&o.timeIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsDirty: %w", err)
	}

	if err = dec.Decode(&o.dateTime); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTime: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsNull: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsValid: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsDirty: %w", err)
	}

	if err = dec.Decode(&o.ts); err != nil {
		return fmt.Errorf("error decoding TypeTest.ts: %w", err)
	}
	if err = dec.Decode(&o.tsIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.tsIsNull: %w", err)
	}
	if err = dec.Decode(&o.tsIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.tsIsValid: %w", err)
	}
	if err = dec.Decode(&o.tsIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.tsIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testInt); err != nil {
		return fmt.Errorf("error decoding TypeTest.testInt: %w", err)
	}
	if err = dec.Decode(&o.testIntIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsNull: %w", err)
	}
	if err = dec.Decode(&o.testIntIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsValid: %w", err)
	}
	if err = dec.Decode(&o.testIntIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testFloat); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat: %w", err)
	}
	if err = dec.Decode(&o.testFloatIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloatIsNull: %w", err)
	}
	if err = dec.Decode(&o.testFloatIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloatIsValid: %w", err)
	}
	if err = dec.Decode(&o.testFloatIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloatIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testDouble); err != nil {
		return fmt.Errorf("error decoding TypeTest.testDouble: %w", err)
	}
	if err = dec.Decode(&o.testDoubleIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testDoubleIsValid: %w", err)
	}
	if err = dec.Decode(&o.testDoubleIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testDoubleIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testText); err != nil {
		return fmt.Errorf("error decoding TypeTest.testText: %w", err)
	}
	if err = dec.Decode(&o.testTextIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testTextIsNull: %w", err)
	}
	if err = dec.Decode(&o.testTextIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testTextIsValid: %w", err)
	}
	if err = dec.Decode(&o.testTextIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testTextIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testBit); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBit: %w", err)
	}
	if err = dec.Decode(&o.testBitIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBitIsNull: %w", err)
	}
	if err = dec.Decode(&o.testBitIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBitIsValid: %w", err)
	}
	if err = dec.Decode(&o.testBitIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBitIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testVarchar); err != nil {
		return fmt.Errorf("error decoding TypeTest.testVarchar: %w", err)
	}
	if err = dec.Decode(&o.testVarcharIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testVarcharIsNull: %w", err)
	}
	if err = dec.Decode(&o.testVarcharIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testVarcharIsValid: %w", err)
	}
	if err = dec.Decode(&o.testVarcharIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testVarcharIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testBlob); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBlob: %w", err)
	}
	if err = dec.Decode(&o.testBlobIsValid); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBlobIsValid: %w", err)
	}
	if err = dec.Decode(&o.testBlobIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBlobIsDirty: %w", err)
	}

	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *typeTestBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *typeTestBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsValid {
		v["id"] = o.id
	}

	if o.dateIsValid {
		if o.dateIsNull {
			v["date"] = nil
		} else {
			v["date"] = o.date
		}
	}

	if o.timeIsValid {
		if o.timeIsNull {
			v["time"] = nil
		} else {
			v["time"] = o.time
		}
	}

	if o.dateTimeIsValid {
		if o.dateTimeIsNull {
			v["dateTime"] = nil
		} else {
			v["dateTime"] = o.dateTime
		}
	}

	if o.tsIsValid {
		if o.tsIsNull {
			v["ts"] = nil
		} else {
			v["ts"] = o.ts
		}
	}

	if o.testIntIsValid {
		if o.testIntIsNull {
			v["testInt"] = nil
		} else {
			v["testInt"] = o.testInt
		}
	}

	if o.testFloatIsValid {
		if o.testFloatIsNull {
			v["testFloat"] = nil
		} else {
			v["testFloat"] = o.testFloat
		}
	}

	if o.testDoubleIsValid {
		v["testDouble"] = o.testDouble
	}

	if o.testTextIsValid {
		if o.testTextIsNull {
			v["testText"] = nil
		} else {
			v["testText"] = o.testText
		}
	}

	if o.testBitIsValid {
		if o.testBitIsNull {
			v["testBit"] = nil
		} else {
			v["testBit"] = o.testBit
		}
	}

	if o.testVarcharIsValid {
		if o.testVarcharIsNull {
			v["testVarchar"] = nil
		} else {
			v["testVarchar"] = o.testVarchar
		}
	}

	if o.testBlobIsValid {
		v["testBlob"] = o.testBlob
	}

	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the TypeTest. The TypeTest can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//
//	"id" - string
//	"date" - time.Time, nullable
//	"time" - time.Time, nullable
//	"dateTime" - time.Time, nullable
//	"ts" - time.Time, nullable
//	"testInt" - int, nullable
//	"testFloat" - float32, nullable
//	"testDouble" - float64
//	"testText" - string, nullable
//	"testBit" - bool, nullable
//	"testVarchar" - string, nullable
//	"testBlob" - []byte
func (o *typeTestBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if err = json.Unmarshal(data, &v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in TypeTest to modify the json before sending it here.
func (o *typeTestBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {

		case "date":
			{
				if v == nil {
					o.SetDate(v)
					continue
				}

				switch d := v.(type) {
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}

		case "time":
			{
				if v == nil {
					o.SetTime(v)
					continue
				}

				switch d := v.(type) {
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetTime(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetTime(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}

		case "dateTime":
			{
				if v == nil {
					o.SetDateTime(v)
					continue
				}

				switch d := v.(type) {
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetDateTime(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetDateTime(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}

		case "testInt":
			{
				if v == nil {
					o.SetTestInt(v)
					continue
				}

				if n, ok := v.(int); ok {
					o.SetTestInt(int(n))
				} else if n, ok := v.(float64); ok {
					o.SetTestInt(int(n))
				} else {
					return fmt.Errorf("json field %s must be a number", k)
				}
			}

		case "testFloat":
			{
				if v == nil {
					o.SetTestFloat(v)
					continue
				}

				if n, ok := v.(float64); ok {
					o.SetTestFloat(float32(n))
				} else {
					return fmt.Errorf("json field %s must be a number", k)
				}
			}

		case "testDouble":
			{
				if v == nil {
					return fmt.Errorf("json field %s cannot be null", k)
				}

				if n, ok := v.(float64); ok {
					o.SetTestDouble(n)
				} else {
					return fmt.Errorf("json field %s must be a number", k)
				}
			}

		case "testText":
			{
				if v == nil {
					o.SetTestText(v)
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestText(s)
				}
			}

		case "testBit":
			{
				if v == nil {
					o.SetTestBit(v)
					continue
				}

				if b, ok := v.(bool); !ok {
					return fmt.Errorf("json field %s must be a boolean", k)
				} else {
					o.SetTestBit(b)
				}
			}

		case "testVarchar":
			{
				if v == nil {
					o.SetTestVarchar(v)
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestVarchar(s)
				}
			}

		case "testBlob":
			{
				if v == nil {
					return fmt.Errorf("json field %s cannot be null", k)
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetTestBlob(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetTestBlob(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}

		}
	}
	return
}
