// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"slices"
	"time"
	"unicode/utf8"

	"github.com/goradd/anyutil"
	"github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
	"github.com/goradd/orm/pkg/broadcast"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/query"
)

// TypeTestBase is embedded in a TypeTest object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the TypeTest embedder.
// Instead, use the accessor functions.
type typeTestBase struct {
	id                          string
	idIsLoaded                  bool
	idIsDirty                   bool
	date                        time.Time
	dateIsNull                  bool
	dateIsLoaded                bool
	dateIsDirty                 bool
	time                        time.Time
	timeIsNull                  bool
	timeIsLoaded                bool
	timeIsDirty                 bool
	dateTime                    time.Time
	dateTimeIsNull              bool
	dateTimeIsLoaded            bool
	dateTimeIsDirty             bool
	creationTime                time.Time
	creationTimeIsLoaded        bool
	modifiedTime                time.Time
	modifiedTimeIsLoaded        bool
	testInt                     int
	testIntIsNull               bool
	testIntIsLoaded             bool
	testIntIsDirty              bool
	testUnsigned                uint
	testUnsignedIsLoaded        bool
	testUnsignedIsDirty         bool
	testInt64                   int64
	testInt64IsLoaded           bool
	testInt64IsDirty            bool
	testUint64                  uint64
	testUint64IsLoaded          bool
	testUint64IsDirty           bool
	testFloat32                 float32
	testFloat32IsNull           bool
	testFloat32IsLoaded         bool
	testFloat32IsDirty          bool
	testFloat64                 float64
	testFloat64IsLoaded         bool
	testFloat64IsDirty          bool
	testNumeric                 string
	testNumericIsLoaded         bool
	testNumericIsDirty          bool
	testBool                    bool
	testBoolIsLoaded            bool
	testBoolIsDirty             bool
	testUnlimitedString         string
	testUnlimitedStringIsLoaded bool
	testUnlimitedStringIsDirty  bool
	testLimitedString           string
	testLimitedStringIsLoaded   bool
	testLimitedStringIsDirty    bool
	testLongstring              string
	testLongstringIsLoaded      bool
	testLongstringIsDirty       bool
	testUnlimitedBytes          []byte
	testUnlimitedBytesIsLoaded  bool
	testUnlimitedBytesIsDirty   bool
	testLimitedBytes            []byte
	testLimitedBytesIsLoaded    bool
	testLimitedBytesIsDirty     bool
	typeLongBytes               []byte
	typeLongBytesIsLoaded       bool
	typeLongBytesIsDirty        bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

	_originalPK string
}

// IDs used to access the TypeTest object fields by name using the Get function.
// doc: type=TypeTest
const (
	TypeTestIDField                  = `id`
	TypeTestDateField                = `date`
	TypeTestTimeField                = `time`
	TypeTestDateTimeField            = `dateTime`
	TypeTestCreationTimeField        = `creationTime`
	TypeTestModifiedTimeField        = `modifiedTime`
	TypeTestTestIntField             = `testInt`
	TypeTestTestUnsignedField        = `testUnsigned`
	TypeTestTestInt64Field           = `testInt64`
	TypeTestTestUint64Field          = `testUint64`
	TypeTestTestFloat32Field         = `testFloat32`
	TypeTestTestFloat64Field         = `testFloat64`
	TypeTestTestNumericField         = `testNumeric`
	TypeTestTestBoolField            = `testBool`
	TypeTestTestUnlimitedStringField = `testUnlimitedString`
	TypeTestTestLimitedStringField   = `testLimitedString`
	TypeTestTestLongstringField      = `testLongstring`
	TypeTestTestUnlimitedBytesField  = `testUnlimitedBytes`
	TypeTestTestLimitedBytesField    = `testLimitedBytes`
	TypeTestTypeLongBytesField       = `typeLongBytes`
)

const TypeTestIDMaxLength = 64 // The number of runes the column can hold
const TypeTestTestIntMax = 2147483647
const TypeTestTestIntMin = -2147483648
const TypeTestTestUnsignedMax = 4294967295
const TypeTestTestUnsignedMin = 0
const TypeTestTestNumericMaxLength = 12            // The number of runes the column can hold
const TypeTestTestLimitedStringMaxLength = 10      // The number of runes the column can hold
const TypeTestTestLongstringMaxLength = 1000000000 // The number of runes the column can hold
const TypeTestTestLimitedBytesMaxLength = 10       // The number of bytes the column can hold
const TypeTestTypeLongBytesMaxLength = 4294967295  // The number of bytes the column can hold

// Initialize or re-initialize a TypeTest database object to default values.
// The primary key will get a temporary unique value which will be replaced when the object is saved.
func (o *typeTestBase) Initialize() {
	o.id = db.TemporaryPrimaryKey()
	o.idIsLoaded = true
	o.idIsDirty = false

	o.date = time.Time{}
	o.dateIsNull = true
	o.dateIsLoaded = false
	o.dateIsDirty = false

	o.time = time.Time{}
	o.timeIsNull = true
	o.timeIsLoaded = false
	o.timeIsDirty = false

	o.dateTime = time.Time{}
	o.dateTimeIsNull = true
	o.dateTimeIsLoaded = false
	o.dateTimeIsDirty = false

	o.creationTime = time.Time{}
	o.creationTimeIsLoaded = true

	o.modifiedTime = time.Time{}
	o.modifiedTimeIsLoaded = true

	o.testInt = 5
	o.testIntIsNull = false
	o.testIntIsLoaded = true
	o.testIntIsDirty = false

	o.testUnsigned = 0x0
	o.testUnsignedIsLoaded = false
	o.testUnsignedIsDirty = false

	o.testInt64 = 0
	o.testInt64IsLoaded = false
	o.testInt64IsDirty = false

	o.testUint64 = 0x0
	o.testUint64IsLoaded = false
	o.testUint64IsDirty = false

	o.testFloat32 = 0
	o.testFloat32IsNull = true
	o.testFloat32IsLoaded = false
	o.testFloat32IsDirty = false

	o.testFloat64 = 0
	o.testFloat64IsLoaded = false
	o.testFloat64IsDirty = false

	o.testNumeric = ""
	o.testNumericIsLoaded = false
	o.testNumericIsDirty = false

	o.testBool = true
	o.testBoolIsLoaded = true
	o.testBoolIsDirty = false

	o.testUnlimitedString = ""
	o.testUnlimitedStringIsLoaded = false
	o.testUnlimitedStringIsDirty = false

	o.testLimitedString = ""
	o.testLimitedStringIsLoaded = false
	o.testLimitedStringIsDirty = false

	o.testLongstring = ""
	o.testLongstringIsLoaded = false
	o.testLongstringIsDirty = false

	o.testUnlimitedBytes = []byte{}
	o.testUnlimitedBytesIsLoaded = false
	o.testUnlimitedBytesIsDirty = false

	o.testLimitedBytes = []byte{}
	o.testLimitedBytesIsLoaded = false
	o.testLimitedBytesIsDirty = false

	o.typeLongBytes = []byte{}
	o.typeLongBytesIsLoaded = false
	o.typeLongBytesIsDirty = false

	o._aliases = nil
	o._restored = false
}

// Copy copies most fields to a new TypeTest object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Automatically generated fields will not be included in the copy.
// The primary key field will not be copied, since it is normally auto-generated.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *typeTestBase) Copy() (newObject *TypeTest) {
	newObject = NewTypeTest()
	if o.idIsLoaded {
		newObject.SetID(o.id)
	}
	if o.dateIsLoaded {
		newObject.SetDate(o.date)
	}
	if o.timeIsLoaded {
		newObject.SetTime(o.time)
	}
	if o.dateTimeIsLoaded {
		newObject.SetDateTime(o.dateTime)
	}
	if o.testIntIsLoaded {
		newObject.SetTestInt(o.testInt)
	}
	if o.testUnsignedIsLoaded {
		newObject.SetTestUnsigned(o.testUnsigned)
	}
	if o.testInt64IsLoaded {
		newObject.SetTestInt64(o.testInt64)
	}
	if o.testUint64IsLoaded {
		newObject.SetTestUint64(o.testUint64)
	}
	if o.testFloat32IsLoaded {
		newObject.SetTestFloat32(o.testFloat32)
	}
	if o.testFloat64IsLoaded {
		newObject.SetTestFloat64(o.testFloat64)
	}
	if o.testNumericIsLoaded {
		newObject.SetTestNumeric(o.testNumeric)
	}
	if o.testBoolIsLoaded {
		newObject.SetTestBool(o.testBool)
	}
	if o.testUnlimitedStringIsLoaded {
		newObject.SetTestUnlimitedString(o.testUnlimitedString)
	}
	if o.testLimitedStringIsLoaded {
		newObject.SetTestLimitedString(o.testLimitedString)
	}
	if o.testLongstringIsLoaded {
		newObject.SetTestLongstring(o.testLongstring)
	}
	if o.testUnlimitedBytesIsLoaded {
		newObject.SetTestUnlimitedBytes(o.testUnlimitedBytes)
	}
	if o.testLimitedBytesIsLoaded {
		newObject.SetTestLimitedBytes(o.testLimitedBytes)
	}
	if o.typeLongBytesIsLoaded {
		newObject.SetTypeLongBytes(o.typeLongBytes)
	}
	return
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *typeTestBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// PrimaryKey returns the value of the primary key of the record.
func (o *typeTestBase) PrimaryKey() string {
	if o._restored && !o.idIsLoaded {
		panic("Value was not selected in the last query and has not been set, and so PrimaryKey is not valid")
	}
	return o.id
}

// SetPrimaryKey sets the value of the primary key in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the primary key value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *typeTestBase) SetPrimaryKey(v string) {
	if o._restored {
		panic("error: Do not change a primary key for a record that has been saved. Instead, save a copy and delete the original.")
	}
	if utf8.RuneCountInString(v) > TypeTestIDMaxLength {
		panic("attempted to set TypeTest.Value to a value larger than its maximum length in runes")
	}
	o.idIsLoaded = true
	o.idIsDirty = true
	o.id = v
}

// ID returns the value of ID.
func (o *typeTestBase) ID() string {
	return o.PrimaryKey()
}

// IDIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) IDIsLoaded() bool {
	return o.idIsLoaded
}

// SetID sets the value of ID in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the ID value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *typeTestBase) SetID(v string) {
	o.SetPrimaryKey(v)
}

// Date returns the value of Date.
func (o *typeTestBase) Date() time.Time {
	if o._restored && !o.dateIsLoaded {
		panic("Date was not selected in the last query and has not been set, and so is not valid")
	}
	return o.date
}

// DateIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) DateIsLoaded() bool {
	return o.dateIsLoaded
}

// DateIsNull returns true if the related database value is null.
func (o *typeTestBase) DateIsNull() bool {
	return o.dateIsNull
}

// SetDate sets the value of Date in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *typeTestBase) SetDate(v time.Time) {
	if o._restored &&
		o.dateIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.dateIsNull && // if the db value is null, force a set of value
		o.date.Equal(v) {
		// no change
		return
	}

	o.dateIsLoaded = true
	v = v.UTC()
	v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())
	o.date = v
	o.dateIsDirty = true
	o.dateIsNull = false
}

// SetDateToNull() will set the date value in the database to NULL.
// Date() will return the column's default value after this.
func (o *typeTestBase) SetDateToNull() {
	if !o.dateIsLoaded || !o.dateIsNull {
		// If we know it is null in the database, don't save it
		o.dateIsDirty = true
	}
	o.dateIsLoaded = true
	o.dateIsNull = true
	o.date = time.Time{}
}

// Time returns the value of Time.
func (o *typeTestBase) Time() time.Time {
	if o._restored && !o.timeIsLoaded {
		panic("Time was not selected in the last query and has not been set, and so is not valid")
	}
	return o.time
}

// TimeIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TimeIsLoaded() bool {
	return o.timeIsLoaded
}

// TimeIsNull returns true if the related database value is null.
func (o *typeTestBase) TimeIsNull() bool {
	return o.timeIsNull
}

// SetTime sets the value of Time in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The date will also be zeroed. This process may cause the time value to change. To prevent this, be sure that the time given is already in UTC time.
func (o *typeTestBase) SetTime(v time.Time) {
	if o._restored &&
		o.timeIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.timeIsNull && // if the db value is null, force a set of value
		o.time.Equal(v) {
		// no change
		return
	}

	o.timeIsLoaded = true
	v = v.UTC()
	v = time.Date(1, 1, 1, v.Hour(), v.Minute(), v.Second(), v.Nanosecond(), time.UTC)
	o.time = v
	o.timeIsDirty = true
	o.timeIsNull = false
}

// SetTimeToNull() will set the time value in the database to NULL.
// Time() will return the column's default value after this.
func (o *typeTestBase) SetTimeToNull() {
	if !o.timeIsLoaded || !o.timeIsNull {
		// If we know it is null in the database, don't save it
		o.timeIsDirty = true
	}
	o.timeIsLoaded = true
	o.timeIsNull = true
	o.time = time.Time{}
}

// DateTime returns the value of DateTime.
func (o *typeTestBase) DateTime() time.Time {
	if o._restored && !o.dateTimeIsLoaded {
		panic("DateTime was not selected in the last query and has not been set, and so is not valid")
	}
	return o.dateTime
}

// DateTimeIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) DateTimeIsLoaded() bool {
	return o.dateTimeIsLoaded
}

// DateTimeIsNull returns true if the related database value is null.
func (o *typeTestBase) DateTimeIsNull() bool {
	return o.dateTimeIsNull
}

// SetDateTime sets the value of DateTime in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
func (o *typeTestBase) SetDateTime(v time.Time) {
	if o._restored &&
		o.dateTimeIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.dateTimeIsNull && // if the db value is null, force a set of value
		o.dateTime.Equal(v) {
		// no change
		return
	}

	o.dateTimeIsLoaded = true
	v = v.UTC()
	o.dateTime = v
	o.dateTimeIsDirty = true
	o.dateTimeIsNull = false
}

// SetDateTimeToNull() will set the date_time value in the database to NULL.
// DateTime() will return the column's default value after this.
func (o *typeTestBase) SetDateTimeToNull() {
	if !o.dateTimeIsLoaded || !o.dateTimeIsNull {
		// If we know it is null in the database, don't save it
		o.dateTimeIsDirty = true
	}
	o.dateTimeIsLoaded = true
	o.dateTimeIsNull = true
	o.dateTime = time.Time{}
}

// CreationTime returns the value of CreationTime.
func (o *typeTestBase) CreationTime() time.Time {
	if o._restored && !o.creationTimeIsLoaded {
		panic("CreationTime was not selected in the last query and has not been set, and so is not valid")
	}
	return o.creationTime
}

// CreationTimeIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) CreationTimeIsLoaded() bool {
	return o.creationTimeIsLoaded
}

// ModifiedTime returns the value of ModifiedTime.
func (o *typeTestBase) ModifiedTime() time.Time {
	if o._restored && !o.modifiedTimeIsLoaded {
		panic("ModifiedTime was not selected in the last query and has not been set, and so is not valid")
	}
	return o.modifiedTime
}

// ModifiedTimeIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) ModifiedTimeIsLoaded() bool {
	return o.modifiedTimeIsLoaded
}

// TestInt returns the value of TestInt.
func (o *typeTestBase) TestInt() int {
	if o._restored && !o.testIntIsLoaded {
		panic("TestInt was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testInt
}

// TestIntIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestIntIsLoaded() bool {
	return o.testIntIsLoaded
}

// TestIntIsNull returns true if the related database value is null.
func (o *typeTestBase) TestIntIsNull() bool {
	return o.testIntIsNull
}

// SetTestInt sets the value of TestInt in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestInt(v int) {
	if o._restored &&
		o.testIntIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.testIntIsNull && // if the db value is null, force a set of value
		o.testInt == v {
		// no change
		return
	}

	o.testIntIsLoaded = true
	o.testInt = v
	o.testIntIsDirty = true
	o.testIntIsNull = false
}

// SetTestIntToNull() will set the test_int value in the database to NULL.
// TestInt() will return the column's default value after this.
func (o *typeTestBase) SetTestIntToNull() {
	if !o.testIntIsLoaded || !o.testIntIsNull {
		// If we know it is null in the database, don't save it
		o.testIntIsDirty = true
	}
	o.testIntIsLoaded = true
	o.testIntIsNull = true
	o.testInt = 5
}

// TestUnsigned returns the value of TestUnsigned.
func (o *typeTestBase) TestUnsigned() uint {
	if o._restored && !o.testUnsignedIsLoaded {
		panic("TestUnsigned was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testUnsigned
}

// TestUnsignedIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestUnsignedIsLoaded() bool {
	return o.testUnsignedIsLoaded
}

// SetTestUnsigned sets the value of TestUnsigned in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestUnsigned(v uint) {
	if o._restored &&
		o.testUnsignedIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testUnsigned == v {
		// no change
		return
	}

	o.testUnsignedIsLoaded = true
	o.testUnsigned = v
	o.testUnsignedIsDirty = true
}

// TestInt64 returns the value of TestInt64.
func (o *typeTestBase) TestInt64() int64 {
	if o._restored && !o.testInt64IsLoaded {
		panic("TestInt64 was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testInt64
}

// TestInt64IsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestInt64IsLoaded() bool {
	return o.testInt64IsLoaded
}

// SetTestInt64 sets the value of TestInt64 in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestInt64(v int64) {
	if o._restored &&
		o.testInt64IsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testInt64 == v {
		// no change
		return
	}

	o.testInt64IsLoaded = true
	o.testInt64 = v
	o.testInt64IsDirty = true
}

// TestUint64 returns the value of TestUint64.
func (o *typeTestBase) TestUint64() uint64 {
	if o._restored && !o.testUint64IsLoaded {
		panic("TestUint64 was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testUint64
}

// TestUint64IsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestUint64IsLoaded() bool {
	return o.testUint64IsLoaded
}

// SetTestUint64 sets the value of TestUint64 in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestUint64(v uint64) {
	if o._restored &&
		o.testUint64IsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testUint64 == v {
		// no change
		return
	}

	o.testUint64IsLoaded = true
	o.testUint64 = v
	o.testUint64IsDirty = true
}

// TestFloat32 returns the value of TestFloat32.
func (o *typeTestBase) TestFloat32() float32 {
	if o._restored && !o.testFloat32IsLoaded {
		panic("TestFloat32 was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testFloat32
}

// TestFloat32IsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestFloat32IsLoaded() bool {
	return o.testFloat32IsLoaded
}

// TestFloat32IsNull returns true if the related database value is null.
func (o *typeTestBase) TestFloat32IsNull() bool {
	return o.testFloat32IsNull
}

// SetTestFloat32 sets the value of TestFloat32 in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestFloat32(v float32) {
	if o._restored &&
		o.testFloat32IsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.testFloat32IsNull && // if the db value is null, force a set of value
		o.testFloat32 == v {
		// no change
		return
	}

	o.testFloat32IsLoaded = true
	o.testFloat32 = v
	o.testFloat32IsDirty = true
	o.testFloat32IsNull = false
}

// SetTestFloat32ToNull() will set the test_float32 value in the database to NULL.
// TestFloat32() will return the column's default value after this.
func (o *typeTestBase) SetTestFloat32ToNull() {
	if !o.testFloat32IsLoaded || !o.testFloat32IsNull {
		// If we know it is null in the database, don't save it
		o.testFloat32IsDirty = true
	}
	o.testFloat32IsLoaded = true
	o.testFloat32IsNull = true
	o.testFloat32 = 0
}

// TestFloat64 returns the value of TestFloat64.
func (o *typeTestBase) TestFloat64() float64 {
	if o._restored && !o.testFloat64IsLoaded {
		panic("TestFloat64 was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testFloat64
}

// TestFloat64IsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestFloat64IsLoaded() bool {
	return o.testFloat64IsLoaded
}

// SetTestFloat64 sets the value of TestFloat64 in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestFloat64(v float64) {
	if o._restored &&
		o.testFloat64IsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testFloat64 == v {
		// no change
		return
	}

	o.testFloat64IsLoaded = true
	o.testFloat64 = v
	o.testFloat64IsDirty = true
}

// TestNumeric returns the value of TestNumeric.
func (o *typeTestBase) TestNumeric() string {
	if o._restored && !o.testNumericIsLoaded {
		panic("TestNumeric was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testNumeric
}

// TestNumericIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestNumericIsLoaded() bool {
	return o.testNumericIsLoaded
}

// SetTestNumeric sets the value of TestNumeric in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestNumeric(v string) {
	if utf8.RuneCountInString(v) > TypeTestTestNumericMaxLength {
		panic("attempted to set TypeTest.TestNumeric to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.testNumericIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testNumeric == v {
		// no change
		return
	}

	o.testNumericIsLoaded = true
	o.testNumeric = v
	o.testNumericIsDirty = true
}

// TestBool returns the value of TestBool.
func (o *typeTestBase) TestBool() bool {
	if o._restored && !o.testBoolIsLoaded {
		panic("TestBool was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testBool
}

// TestBoolIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestBoolIsLoaded() bool {
	return o.testBoolIsLoaded
}

// SetTestBool sets the value of TestBool in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestBool(v bool) {
	if o._restored &&
		o.testBoolIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testBool == v {
		// no change
		return
	}

	o.testBoolIsLoaded = true
	o.testBool = v
	o.testBoolIsDirty = true
}

// TestUnlimitedString returns the value of TestUnlimitedString.
func (o *typeTestBase) TestUnlimitedString() string {
	if o._restored && !o.testUnlimitedStringIsLoaded {
		panic("TestUnlimitedString was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testUnlimitedString
}

// TestUnlimitedStringIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestUnlimitedStringIsLoaded() bool {
	return o.testUnlimitedStringIsLoaded
}

// SetTestUnlimitedString sets the value of TestUnlimitedString in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestUnlimitedString(v string) {
	if o._restored &&
		o.testUnlimitedStringIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testUnlimitedString == v {
		// no change
		return
	}

	o.testUnlimitedStringIsLoaded = true
	o.testUnlimitedString = v
	o.testUnlimitedStringIsDirty = true
}

// TestLimitedString returns the value of TestLimitedString.
func (o *typeTestBase) TestLimitedString() string {
	if o._restored && !o.testLimitedStringIsLoaded {
		panic("TestLimitedString was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testLimitedString
}

// TestLimitedStringIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestLimitedStringIsLoaded() bool {
	return o.testLimitedStringIsLoaded
}

// SetTestLimitedString sets the value of TestLimitedString in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestLimitedString(v string) {
	if utf8.RuneCountInString(v) > TypeTestTestLimitedStringMaxLength {
		panic("attempted to set TypeTest.TestLimitedString to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.testLimitedStringIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testLimitedString == v {
		// no change
		return
	}

	o.testLimitedStringIsLoaded = true
	o.testLimitedString = v
	o.testLimitedStringIsDirty = true
}

// TestLongstring returns the value of TestLongstring.
func (o *typeTestBase) TestLongstring() string {
	if o._restored && !o.testLongstringIsLoaded {
		panic("TestLongstring was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testLongstring
}

// TestLongstringIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestLongstringIsLoaded() bool {
	return o.testLongstringIsLoaded
}

// SetTestLongstring sets the value of TestLongstring in the object, to be saved later in the database using the Save() function.
func (o *typeTestBase) SetTestLongstring(v string) {
	if utf8.RuneCountInString(v) > TypeTestTestLongstringMaxLength {
		panic("attempted to set TypeTest.TestLongstring to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.testLongstringIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.testLongstring == v {
		// no change
		return
	}

	o.testLongstringIsLoaded = true
	o.testLongstring = v
	o.testLongstringIsDirty = true
}

// TestUnlimitedBytes returns the value of TestUnlimitedBytes.
func (o *typeTestBase) TestUnlimitedBytes() []byte {
	if o._restored && !o.testUnlimitedBytesIsLoaded {
		panic("TestUnlimitedBytes was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testUnlimitedBytes
}

// TestUnlimitedBytesIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestUnlimitedBytesIsLoaded() bool {
	return o.testUnlimitedBytesIsLoaded
}

// SetTestUnlimitedBytes copies the value of TestUnlimitedBytes, to be saved later in the database using the Save() function.
// Passing nil will set test_unlimited_bytes to an empty array.
func (o *typeTestBase) SetTestUnlimitedBytes(v []byte) {

	if o._restored &&
		o.testUnlimitedBytesIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		bytes.Equal(o.testUnlimitedBytes, v) {
		// no change
		return
	}

	o.testUnlimitedBytesIsLoaded = true
	if v == nil {
		o.testUnlimitedBytes = []byte{}
	} else {
		o.testUnlimitedBytes = slices.Clone(v)
	}
	o.testUnlimitedBytesIsDirty = true
}

// TestLimitedBytes returns the value of TestLimitedBytes.
func (o *typeTestBase) TestLimitedBytes() []byte {
	if o._restored && !o.testLimitedBytesIsLoaded {
		panic("TestLimitedBytes was not selected in the last query and has not been set, and so is not valid")
	}
	return o.testLimitedBytes
}

// TestLimitedBytesIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TestLimitedBytesIsLoaded() bool {
	return o.testLimitedBytesIsLoaded
}

// SetTestLimitedBytes copies the value of TestLimitedBytes, to be saved later in the database using the Save() function.
// Passing nil will set test_limited_bytes to an empty array.
func (o *typeTestBase) SetTestLimitedBytes(v []byte) {

	if len(v) > TypeTestTestLimitedBytesMaxLength {
		panic("attempted to set TypeTest.TestLimitedBytes to a value larger than its maximum length")
	}

	if o._restored &&
		o.testLimitedBytesIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		bytes.Equal(o.testLimitedBytes, v) {
		// no change
		return
	}

	o.testLimitedBytesIsLoaded = true
	if v == nil {
		o.testLimitedBytes = []byte{}
	} else {
		o.testLimitedBytes = slices.Clone(v)
	}
	o.testLimitedBytesIsDirty = true
}

// TypeLongBytes returns the value of TypeLongBytes.
func (o *typeTestBase) TypeLongBytes() []byte {
	if o._restored && !o.typeLongBytesIsLoaded {
		panic("TypeLongBytes was not selected in the last query and has not been set, and so is not valid")
	}
	return o.typeLongBytes
}

// TypeLongBytesIsLoaded returns true if the value was loaded from the database or has been set.
func (o *typeTestBase) TypeLongBytesIsLoaded() bool {
	return o.typeLongBytesIsLoaded
}

// SetTypeLongBytes copies the value of TypeLongBytes, to be saved later in the database using the Save() function.
// Passing nil will set type_long_bytes to an empty array.
func (o *typeTestBase) SetTypeLongBytes(v []byte) {

	if len(v) > TypeTestTypeLongBytesMaxLength {
		panic("attempted to set TypeTest.TypeLongBytes to a value larger than its maximum length")
	}

	if o._restored &&
		o.typeLongBytesIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		bytes.Equal(o.typeLongBytes, v) {
		// no change
		return
	}

	o.typeLongBytesIsLoaded = true
	if v == nil {
		o.typeLongBytes = []byte{}
	} else {
		o.typeLongBytes = slices.Clone(v)
	}
	o.typeLongBytesIsDirty = true
}

// GetAlias returns the value for the Alias node aliasKey that was returned in the most
// recent query.
func (o *typeTestBase) GetAlias(aliasKey string) query.AliasValue {
	if a, ok := o._aliases[aliasKey]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + aliasKey + " not found.")
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *typeTestBase) IsNew() bool {
	return !o._restored
}

// LoadTypeTest returns a TypeTest from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [TypeTestsBuilder.Select] for more info.
func LoadTypeTest(ctx context.Context, id string, selectNodes ...query.Node) (*TypeTest, error) {
	return queryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().ID(), id)).
		Select(selectNodes...).
		Get()
}

// HasTypeTest returns true if a TypeTest with the given primary key exists in the database.
// doc: type=TypeTest
func HasTypeTest(ctx context.Context, id string) (bool, error) {
	v, err := queryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().ID(), id)).
		Count()
	return v > 0, err
}

// The TypeTestBuilder uses a builder pattern to create a query on the database.
// Create a TypeTestBuilder by calling QueryTypeTests, which will select all
// the TypeTest object in the database. Then filter and arrange those objects
// by calling Where, Select, etc.
// End a query by calling either Load, LoadI, LoadCursor, Get, or Count.
// A TypeTestBuilder stores the context it will use to perform the query, and thus is
// meant to be a short-lived object. You should not save it for later use.
type TypeTestBuilder struct {
	builder *query.Builder
	ctx     context.Context
}

func newTypeTestBuilder(ctx context.Context) *TypeTestBuilder {
	b := TypeTestBuilder{
		builder: query.NewBuilder(node.TypeTest()),
		ctx:     ctx,
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of TypeTest objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *TypeTestBuilder) Load() (typeTests []*TypeTest, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	var results any

	ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(TypeTest)
		o.unpack(item, o)
		typeTests = append(typeTests, o)
	}
	return
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a variety of interfaces that load arrays of objects, including KeyLabeler.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *TypeTestBuilder) LoadI() (typeTests []query.OrmObj, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	var results any

	ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(TypeTest)
		o.unpack(item, o)
		typeTests = append(typeTests, o)
	}
	return
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *TypeTestBuilder) LoadCursor() (typeTestsCursor, error) {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd_unit")
	result, err := database.BuilderQuery(b.ctx, b.builder)
	var cursor query.CursorI
	if result != nil {
		cursor = result.(query.CursorI)
	}
	return typeTestsCursor{cursor}, err
}

type typeTestsCursor struct {
	query.CursorI
}

// Next returns the current TypeTest object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c typeTestsCursor) Next() (*TypeTest, error) {
	if c.CursorI == nil {
		return nil, nil
	}

	row, err := c.CursorI.Next()
	if row == nil || err != nil {
		return nil, err
	}
	o := new(TypeTest)
	o.unpack(row, o)
	return o, nil
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
// If an error occurs, or no results are found, a nil is returned.
func (b *TypeTestBuilder) Get() (*TypeTest, error) {
	results, err := b.Load()
	if err != nil || len(results) == 0 {
		return nil, err
	}
	return results[0], nil
}

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *TypeTestBuilder) Where(c query.Node) *TypeTestBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *TypeTestBuilder) OrderBy(nodes ...query.Sorter) *TypeTestBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *TypeTestBuilder) Limit(maxRowCount int, offset int) *TypeTestBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the type_test table will be queried and loaded.
// If nodes contains columns from the type_test table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *TypeTestBuilder) Select(nodes ...query.Node) *TypeTestBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *TypeTestBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) *TypeTestBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *TypeTestBuilder) Distinct() *TypeTestBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *TypeTestBuilder) GroupBy(nodes ...query.Node) *TypeTestBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *TypeTestBuilder) Having(node query.Node) *TypeTestBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *TypeTestBuilder) Count() (int, error) {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd_unit")

	ctx := b.ctx
	results, err := database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return 0, err
	}
	return results.(int), nil
}

// CountTypeTests returns the total number of items in the type_test table.
func CountTypeTests(ctx context.Context) (int, error) {
	return QueryTypeTests(ctx).Count()
}

// unpack recursively transforms data coming from the database into ORM objects.
func (o *typeTestBase) unpack(m map[string]interface{}, objThis *TypeTest) {

	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsLoaded = true
			o.idIsDirty = false
			o._originalPK = o.id
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsLoaded = false
		o.id = ""
		o.idIsDirty = false
	}

	if v, ok := m["date"]; ok {
		if v == nil {
			o.date = time.Time{}
			o.dateIsNull = true
			o.dateIsLoaded = true
			o.dateIsDirty = false
		} else if o.date, ok = v.(time.Time); ok {
			o.dateIsNull = false
			o.dateIsLoaded = true
			o.dateIsDirty = false
		} else {
			panic("Wrong type found for date.")
		}
	} else {
		o.dateIsLoaded = false
		o.dateIsNull = true
		o.date = time.Time{}
		o.dateIsDirty = false
	}

	if v, ok := m["time"]; ok {
		if v == nil {
			o.time = time.Time{}
			o.timeIsNull = true
			o.timeIsLoaded = true
			o.timeIsDirty = false
		} else if o.time, ok = v.(time.Time); ok {
			o.timeIsNull = false
			o.timeIsLoaded = true
			o.timeIsDirty = false
		} else {
			panic("Wrong type found for time.")
		}
	} else {
		o.timeIsLoaded = false
		o.timeIsNull = true
		o.time = time.Time{}
		o.timeIsDirty = false
	}

	if v, ok := m["date_time"]; ok {
		if v == nil {
			o.dateTime = time.Time{}
			o.dateTimeIsNull = true
			o.dateTimeIsLoaded = true
			o.dateTimeIsDirty = false
		} else if o.dateTime, ok = v.(time.Time); ok {
			o.dateTimeIsNull = false
			o.dateTimeIsLoaded = true
			o.dateTimeIsDirty = false
		} else {
			panic("Wrong type found for date_time.")
		}
	} else {
		o.dateTimeIsLoaded = false
		o.dateTimeIsNull = true
		o.dateTime = time.Time{}
		o.dateTimeIsDirty = false
	}

	if v, ok := m["creation_time"]; ok && v != nil {
		if o.creationTime, ok = v.(time.Time); ok {
			o.creationTimeIsLoaded = true
		} else {
			panic("Wrong type found for creation_time.")
		}
	} else {
		o.creationTimeIsLoaded = false
		o.creationTime = time.Time{}
	}

	if v, ok := m["modified_time"]; ok && v != nil {
		if o.modifiedTime, ok = v.(time.Time); ok {
			o.modifiedTimeIsLoaded = true
		} else {
			panic("Wrong type found for modified_time.")
		}
	} else {
		o.modifiedTimeIsLoaded = false
		o.modifiedTime = time.Time{}
	}

	if v, ok := m["test_int"]; ok {
		if v == nil {
			o.testInt = 5
			o.testIntIsNull = true
			o.testIntIsLoaded = true
			o.testIntIsDirty = false
		} else if o.testInt, ok = v.(int); ok {
			o.testIntIsNull = false
			o.testIntIsLoaded = true
			o.testIntIsDirty = false
		} else {
			panic("Wrong type found for test_int.")
		}
	} else {
		o.testIntIsLoaded = false
		o.testIntIsNull = true
		o.testInt = 5
		o.testIntIsDirty = false
	}

	if v, ok := m["test_unsigned"]; ok && v != nil {
		if o.testUnsigned, ok = v.(uint); ok {
			o.testUnsignedIsLoaded = true
			o.testUnsignedIsDirty = false
		} else {
			panic("Wrong type found for test_unsigned.")
		}
	} else {
		o.testUnsignedIsLoaded = false
		o.testUnsigned = 0x0
		o.testUnsignedIsDirty = false
	}

	if v, ok := m["test_int64"]; ok && v != nil {
		if o.testInt64, ok = v.(int64); ok {
			o.testInt64IsLoaded = true
			o.testInt64IsDirty = false
		} else {
			panic("Wrong type found for test_int64.")
		}
	} else {
		o.testInt64IsLoaded = false
		o.testInt64 = 0
		o.testInt64IsDirty = false
	}

	if v, ok := m["test_uint64"]; ok && v != nil {
		if o.testUint64, ok = v.(uint64); ok {
			o.testUint64IsLoaded = true
			o.testUint64IsDirty = false
		} else {
			panic("Wrong type found for test_uint64.")
		}
	} else {
		o.testUint64IsLoaded = false
		o.testUint64 = 0x0
		o.testUint64IsDirty = false
	}

	if v, ok := m["test_float32"]; ok {
		if v == nil {
			o.testFloat32 = 0
			o.testFloat32IsNull = true
			o.testFloat32IsLoaded = true
			o.testFloat32IsDirty = false
		} else if o.testFloat32, ok = v.(float32); ok {
			o.testFloat32IsNull = false
			o.testFloat32IsLoaded = true
			o.testFloat32IsDirty = false
		} else {
			panic("Wrong type found for test_float32.")
		}
	} else {
		o.testFloat32IsLoaded = false
		o.testFloat32IsNull = true
		o.testFloat32 = 0
		o.testFloat32IsDirty = false
	}

	if v, ok := m["test_float64"]; ok && v != nil {
		if o.testFloat64, ok = v.(float64); ok {
			o.testFloat64IsLoaded = true
			o.testFloat64IsDirty = false
		} else {
			panic("Wrong type found for test_float64.")
		}
	} else {
		o.testFloat64IsLoaded = false
		o.testFloat64 = 0
		o.testFloat64IsDirty = false
	}

	if v, ok := m["test_numeric"]; ok && v != nil {
		if o.testNumeric, ok = v.(string); ok {
			o.testNumericIsLoaded = true
			o.testNumericIsDirty = false
		} else {
			panic("Wrong type found for test_numeric.")
		}
	} else {
		o.testNumericIsLoaded = false
		o.testNumeric = ""
		o.testNumericIsDirty = false
	}

	if v, ok := m["test_bool"]; ok && v != nil {
		if o.testBool, ok = v.(bool); ok {
			o.testBoolIsLoaded = true
			o.testBoolIsDirty = false
		} else {
			panic("Wrong type found for test_bool.")
		}
	} else {
		o.testBoolIsLoaded = false
		o.testBool = true
		o.testBoolIsDirty = false
	}

	if v, ok := m["test_unlimited_string"]; ok && v != nil {
		if o.testUnlimitedString, ok = v.(string); ok {
			o.testUnlimitedStringIsLoaded = true
			o.testUnlimitedStringIsDirty = false
		} else {
			panic("Wrong type found for test_unlimited_string.")
		}
	} else {
		o.testUnlimitedStringIsLoaded = false
		o.testUnlimitedString = ""
		o.testUnlimitedStringIsDirty = false
	}

	if v, ok := m["test_limited_string"]; ok && v != nil {
		if o.testLimitedString, ok = v.(string); ok {
			o.testLimitedStringIsLoaded = true
			o.testLimitedStringIsDirty = false
		} else {
			panic("Wrong type found for test_limited_string.")
		}
	} else {
		o.testLimitedStringIsLoaded = false
		o.testLimitedString = ""
		o.testLimitedStringIsDirty = false
	}

	if v, ok := m["test_longstring"]; ok && v != nil {
		if o.testLongstring, ok = v.(string); ok {
			o.testLongstringIsLoaded = true
			o.testLongstringIsDirty = false
		} else {
			panic("Wrong type found for test_longstring.")
		}
	} else {
		o.testLongstringIsLoaded = false
		o.testLongstring = ""
		o.testLongstringIsDirty = false
	}

	if v, ok := m["test_unlimited_bytes"]; ok && v != nil {
		if o.testUnlimitedBytes, ok = v.([]byte); ok {
			o.testUnlimitedBytesIsLoaded = true
			o.testUnlimitedBytesIsDirty = false
		} else {
			panic("Wrong type found for test_unlimited_bytes.")
		}
	} else {
		o.testUnlimitedBytesIsLoaded = false
		o.testUnlimitedBytes = []byte{}
		o.testUnlimitedBytesIsDirty = false
	}

	if v, ok := m["test_limited_bytes"]; ok && v != nil {
		if o.testLimitedBytes, ok = v.([]byte); ok {
			o.testLimitedBytesIsLoaded = true
			o.testLimitedBytesIsDirty = false
		} else {
			panic("Wrong type found for test_limited_bytes.")
		}
	} else {
		o.testLimitedBytesIsLoaded = false
		o.testLimitedBytes = []byte{}
		o.testLimitedBytesIsDirty = false
	}

	if v, ok := m["type_long_bytes"]; ok && v != nil {
		if o.typeLongBytes, ok = v.([]byte); ok {
			o.typeLongBytesIsLoaded = true
			o.typeLongBytesIsDirty = false
		} else {
			panic("Wrong type found for type_long_bytes.")
		}
	} else {
		o.typeLongBytesIsLoaded = false
		o.typeLongBytes = []byte{}
		o.typeLongBytesIsDirty = false
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}

// save will update or insert the object, depending on the state of the object.
func (o *typeTestBase) save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *typeTestBase) update(ctx context.Context) error {
	if !o._restored {
		panic("cannot update a record that was not originally read from the database.")
	}
	if !o.IsDirty() {
		return nil // nothing to save
	}

	var modifiedFields map[string]interface{}

	d := Database()
	err := db.WithTransaction(ctx, d, func(ctx context.Context) error {

		modifiedFields = getTypeTestUpdateFields(o)
		if len(modifiedFields) != 0 {
			var err2 error

			_, err2 = d.Update(ctx, "type_test", "id", o._originalPK, modifiedFields, "", 0)
			if err2 != nil {
				return err2
			}
		}

		return nil
	}) // transaction
	if err != nil {
		return err
	}
	if t, ok := modifiedFields["modified_time"]; ok {
		o.modifiedTime = t.(time.Time)
		o.modifiedTimeIsLoaded = true
	}

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd_unit", "type_test", o._originalPK, anyutil.SortedKeys(modifiedFields)...)
	}

	return nil
}

// insert will insert the object into the database. Related items will be saved.
func (o *typeTestBase) insert(ctx context.Context) (err error) {
	var insertFields map[string]interface{}
	d := Database()
	err = db.WithTransaction(ctx, d, func(context.Context) error {
		if !o.testUnsignedIsLoaded {
			panic("a value for TestUnsigned is required, and there is no default value. Call SetTestUnsigned() before inserting the record.")
		}
		if !o.testInt64IsLoaded {
			panic("a value for TestInt64 is required, and there is no default value. Call SetTestInt64() before inserting the record.")
		}
		if !o.testUint64IsLoaded {
			panic("a value for TestUint64 is required, and there is no default value. Call SetTestUint64() before inserting the record.")
		}
		if !o.testFloat64IsLoaded {
			panic("a value for TestFloat64 is required, and there is no default value. Call SetTestFloat64() before inserting the record.")
		}
		if !o.testNumericIsLoaded {
			panic("a value for TestNumeric is required, and there is no default value. Call SetTestNumeric() before inserting the record.")
		}
		if !o.testBoolIsLoaded {
			panic("a value for TestBool is required, and there is no default value. Call SetTestBool() before inserting the record.")
		}
		if !o.testUnlimitedStringIsLoaded {
			panic("a value for TestUnlimitedString is required, and there is no default value. Call SetTestUnlimitedString() before inserting the record.")
		}
		if !o.testLimitedStringIsLoaded {
			panic("a value for TestLimitedString is required, and there is no default value. Call SetTestLimitedString() before inserting the record.")
		}
		if !o.testLongstringIsLoaded {
			panic("a value for TestLongstring is required, and there is no default value. Call SetTestLongstring() before inserting the record.")
		}
		if !o.testUnlimitedBytesIsLoaded {
			panic("a value for TestUnlimitedBytes is required, and there is no default value. Call SetTestUnlimitedBytes() before inserting the record.")
		}
		if !o.testLimitedBytesIsLoaded {
			panic("a value for TestLimitedBytes is required, and there is no default value. Call SetTestLimitedBytes() before inserting the record.")
		}
		if !o.typeLongBytesIsLoaded {
			panic("a value for TypeLongBytes is required, and there is no default value. Call SetTypeLongBytes() before inserting the record.")
		}
		insertFields = getTypeTestInsertFields(o)
		var newPK string
		newPK, err = d.Insert(ctx, "type_test", "id", insertFields)
		if err != nil {
			return err
		}
		o.id = newPK
		o._originalPK = newPK
		o.idIsLoaded = true

		return nil

	}) // transaction

	if err != nil {
		return
	}
	if t, ok := insertFields["creation_time"]; ok {
		o.creationTime = t.(time.Time)
		o.creationTimeIsLoaded = true
	}
	if t, ok := insertFields["modified_time"]; ok {
		o.modifiedTime = t.(time.Time)
		o.modifiedTimeIsLoaded = true
	}

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd_unit", "type_test", o.PrimaryKey())
	return
}

// getUpdateFields returns the database columns that will be sent to the update process.
// This will include timestamp fields only if some other column has changed.
func (o *typeTestBase) getUpdateFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}
	if o.dateIsDirty {
		if o.dateIsNull {
			fields["date"] = nil
		} else {
			fields["date"] = o.date
		}
	}
	if o.timeIsDirty {
		if o.timeIsNull {
			fields["time"] = nil
		} else {
			fields["time"] = o.time
		}
	}
	if o.dateTimeIsDirty {
		if o.dateTimeIsNull {
			fields["date_time"] = nil
		} else {
			fields["date_time"] = o.dateTime
		}
	}
	if o.testIntIsDirty {
		if o.testIntIsNull {
			fields["test_int"] = nil
		} else {
			fields["test_int"] = o.testInt
		}
	}
	if o.testUnsignedIsDirty {
		fields["test_unsigned"] = o.testUnsigned
	}
	if o.testInt64IsDirty {
		fields["test_int64"] = o.testInt64
	}
	if o.testUint64IsDirty {
		fields["test_uint64"] = o.testUint64
	}
	if o.testFloat32IsDirty {
		if o.testFloat32IsNull {
			fields["test_float32"] = nil
		} else {
			fields["test_float32"] = o.testFloat32
		}
	}
	if o.testFloat64IsDirty {
		fields["test_float64"] = o.testFloat64
	}
	if o.testNumericIsDirty {
		fields["test_numeric"] = o.testNumeric
	}
	if o.testBoolIsDirty {
		fields["test_bool"] = o.testBool
	}
	if o.testUnlimitedStringIsDirty {
		fields["test_unlimited_string"] = o.testUnlimitedString
	}
	if o.testLimitedStringIsDirty {
		fields["test_limited_string"] = o.testLimitedString
	}
	if o.testLongstringIsDirty {
		fields["test_longstring"] = o.testLongstring
	}
	if o.testUnlimitedBytesIsDirty {
		fields["test_unlimited_bytes"] = o.testUnlimitedBytes
	}
	if o.testLimitedBytesIsDirty {
		fields["test_limited_bytes"] = o.testLimitedBytes
	}
	if o.typeLongBytesIsDirty {
		fields["type_long_bytes"] = o.typeLongBytes
	}
	if len(fields) > 0 {
		fields["modified_time"] = time.Now().UTC()
	}
	return
}

// getInsertFields returns the fields that will be specified in an insert operation.
// Optional fields that have not been set and have no default will be returned as nil.
// NoSql databases should interpret this as no value. Sql databases should interpret this as
// explicitly setting a NULL value, which would override any database specific default value.
// Auto-generated fields will be returned with their generated values, except AutoPK fields, which are generated by the
// database driver and updated after the insert.
func (o *typeTestBase) getInsertFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}
	if o.dateIsNull {
		fields["date"] = nil
	} else {
		fields["date"] = o.date
	}
	if o.timeIsNull {
		fields["time"] = nil
	} else {
		fields["time"] = o.time
	}
	if o.dateTimeIsNull {
		fields["date_time"] = nil
	} else {
		fields["date_time"] = o.dateTime
	}
	fields["creation_time"] = time.Now().UTC()
	fields["modified_time"] = time.Now().UTC()
	if o.testIntIsNull {
		fields["test_int"] = nil
	} else {
		fields["test_int"] = o.testInt
	}

	fields["test_unsigned"] = o.testUnsigned

	fields["test_int64"] = o.testInt64

	fields["test_uint64"] = o.testUint64
	if o.testFloat32IsNull {
		fields["test_float32"] = nil
	} else {
		fields["test_float32"] = o.testFloat32
	}

	fields["test_float64"] = o.testFloat64

	fields["test_numeric"] = o.testNumeric

	fields["test_bool"] = o.testBool

	fields["test_unlimited_string"] = o.testUnlimitedString

	fields["test_limited_string"] = o.testLimitedString

	fields["test_longstring"] = o.testLongstring

	fields["test_unlimited_bytes"] = o.testUnlimitedBytes

	fields["test_limited_bytes"] = o.testLimitedBytes

	fields["type_long_bytes"] = o.typeLongBytes
	return
}

// Delete deletes the record from the database.
func (o *typeTestBase) Delete(ctx context.Context) (err error) {
	if o == nil {
		return // allow deleting of a nil object to be a noop
	}
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()
	err = d.Delete(ctx, "type_test", "id", o.id, "", 0)
	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd_unit", "type_test", fmt.Sprint(o.id))
	return
}

// deleteTypeTest deletes the TypeTest with primary key pk from the database
// and handles associated records.
func deleteTypeTest(ctx context.Context, pk string) error {
	d := db.GetDatabase("goradd_unit")
	err := d.Delete(ctx, "type_test", "id", pk, "", 0)
	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd_unit", "type_test", fmt.Sprint(pk))
	return err
}

// resetDirtyStatus resets the dirty status of every field in the object.
func (o *typeTestBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.dateIsDirty = false
	o.timeIsDirty = false
	o.dateTimeIsDirty = false
	o.testIntIsDirty = false
	o.testUnsignedIsDirty = false
	o.testInt64IsDirty = false
	o.testUint64IsDirty = false
	o.testFloat32IsDirty = false
	o.testFloat64IsDirty = false
	o.testNumericIsDirty = false
	o.testBoolIsDirty = false
	o.testUnlimitedStringIsDirty = false
	o.testLimitedStringIsDirty = false
	o.testLongstringIsDirty = false
	o.testUnlimitedBytesIsDirty = false
	o.testLimitedBytesIsDirty = false
	o.typeLongBytesIsDirty = false

}

// IsDirty returns true if the object has been changed since it was read from the database or created.
func (o *typeTestBase) IsDirty() (dirty bool) {
	dirty = o.idIsDirty ||
		o.dateIsDirty ||
		o.timeIsDirty ||
		o.dateTimeIsDirty ||
		o.testIntIsDirty ||
		o.testUnsignedIsDirty ||
		o.testInt64IsDirty ||
		o.testUint64IsDirty ||
		o.testFloat32IsDirty ||
		o.testFloat64IsDirty ||
		o.testNumericIsDirty ||
		o.testBoolIsDirty ||
		o.testUnlimitedStringIsDirty ||
		o.testLimitedStringIsDirty ||
		o.testLongstringIsDirty ||
		o.testUnlimitedBytesIsDirty ||
		o.testLimitedBytesIsDirty ||
		o.typeLongBytesIsDirty

	return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil.
// Get can be used to retrieve a value by using the Identifier of a node.
func (o *typeTestBase) Get(key string) interface{} {
	switch key {
	case "id":
		if !o.idIsLoaded {
			return nil
		}
		return o.id
	case "date":
		if !o.dateIsLoaded {
			return nil
		}
		return o.date
	case "time":
		if !o.timeIsLoaded {
			return nil
		}
		return o.time
	case "dateTime":
		if !o.dateTimeIsLoaded {
			return nil
		}
		return o.dateTime
	case "creationTime":
		if !o.creationTimeIsLoaded {
			return nil
		}
		return o.creationTime
	case "modifiedTime":
		if !o.modifiedTimeIsLoaded {
			return nil
		}
		return o.modifiedTime
	case "testInt":
		if !o.testIntIsLoaded {
			return nil
		}
		return o.testInt
	case "testUnsigned":
		if !o.testUnsignedIsLoaded {
			return nil
		}
		return o.testUnsigned
	case "testInt64":
		if !o.testInt64IsLoaded {
			return nil
		}
		return o.testInt64
	case "testUint64":
		if !o.testUint64IsLoaded {
			return nil
		}
		return o.testUint64
	case "testFloat32":
		if !o.testFloat32IsLoaded {
			return nil
		}
		return o.testFloat32
	case "testFloat64":
		if !o.testFloat64IsLoaded {
			return nil
		}
		return o.testFloat64
	case "testNumeric":
		if !o.testNumericIsLoaded {
			return nil
		}
		return o.testNumeric
	case "testBool":
		if !o.testBoolIsLoaded {
			return nil
		}
		return o.testBool
	case "testUnlimitedString":
		if !o.testUnlimitedStringIsLoaded {
			return nil
		}
		return o.testUnlimitedString
	case "testLimitedString":
		if !o.testLimitedStringIsLoaded {
			return nil
		}
		return o.testLimitedString
	case "testLongstring":
		if !o.testLongstringIsLoaded {
			return nil
		}
		return o.testLongstring
	case "testUnlimitedBytes":
		if !o.testUnlimitedBytesIsLoaded {
			return nil
		}
		return o.testUnlimitedBytes
	case "testLimitedBytes":
		if !o.testLimitedBytesIsLoaded {
			return nil
		}
		return o.testLimitedBytes
	case "typeLongBytes":
		if !o.typeLongBytesIsLoaded {
			return nil
		}
		return o.typeLongBytes
	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *typeTestBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	enc := gob.NewEncoder(buf)
	if err := o.encodeTo(enc); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (o *typeTestBase) encodeTo(enc db.Encoder) error {

	if err := enc.Encode(o.id); err != nil {
		return fmt.Errorf("error encoding TypeTest.id: %w", err)
	}
	if err := enc.Encode(o.idIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.idIsLoaded: %w", err)
	}
	if err := enc.Encode(o.idIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.idIsDirty: %w", err)
	}

	if err := enc.Encode(o.date); err != nil {
		return fmt.Errorf("error encoding TypeTest.date: %w", err)
	}
	if err := enc.Encode(o.dateIsNull); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateIsNull: %w", err)
	}
	if err := enc.Encode(o.dateIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateIsLoaded: %w", err)
	}
	if err := enc.Encode(o.dateIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateIsDirty: %w", err)
	}

	if err := enc.Encode(o.time); err != nil {
		return fmt.Errorf("error encoding TypeTest.time: %w", err)
	}
	if err := enc.Encode(o.timeIsNull); err != nil {
		return fmt.Errorf("error encoding TypeTest.timeIsNull: %w", err)
	}
	if err := enc.Encode(o.timeIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.timeIsLoaded: %w", err)
	}
	if err := enc.Encode(o.timeIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.timeIsDirty: %w", err)
	}

	if err := enc.Encode(o.dateTime); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateTime: %w", err)
	}
	if err := enc.Encode(o.dateTimeIsNull); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateTimeIsNull: %w", err)
	}
	if err := enc.Encode(o.dateTimeIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateTimeIsLoaded: %w", err)
	}
	if err := enc.Encode(o.dateTimeIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.dateTimeIsDirty: %w", err)
	}

	if err := enc.Encode(o.creationTime); err != nil {
		return fmt.Errorf("error encoding TypeTest.creationTime: %w", err)
	}
	if err := enc.Encode(o.creationTimeIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.creationTimeIsLoaded: %w", err)
	}

	if err := enc.Encode(o.modifiedTime); err != nil {
		return fmt.Errorf("error encoding TypeTest.modifiedTime: %w", err)
	}
	if err := enc.Encode(o.modifiedTimeIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.modifiedTimeIsLoaded: %w", err)
	}

	if err := enc.Encode(o.testInt); err != nil {
		return fmt.Errorf("error encoding TypeTest.testInt: %w", err)
	}
	if err := enc.Encode(o.testIntIsNull); err != nil {
		return fmt.Errorf("error encoding TypeTest.testIntIsNull: %w", err)
	}
	if err := enc.Encode(o.testIntIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testIntIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testIntIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testIntIsDirty: %w", err)
	}

	if err := enc.Encode(o.testUnsigned); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnsigned: %w", err)
	}
	if err := enc.Encode(o.testUnsignedIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnsignedIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testUnsignedIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnsignedIsDirty: %w", err)
	}

	if err := enc.Encode(o.testInt64); err != nil {
		return fmt.Errorf("error encoding TypeTest.testInt64: %w", err)
	}
	if err := enc.Encode(o.testInt64IsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testInt64IsLoaded: %w", err)
	}
	if err := enc.Encode(o.testInt64IsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testInt64IsDirty: %w", err)
	}

	if err := enc.Encode(o.testUint64); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUint64: %w", err)
	}
	if err := enc.Encode(o.testUint64IsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUint64IsLoaded: %w", err)
	}
	if err := enc.Encode(o.testUint64IsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUint64IsDirty: %w", err)
	}

	if err := enc.Encode(o.testFloat32); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat32: %w", err)
	}
	if err := enc.Encode(o.testFloat32IsNull); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat32IsNull: %w", err)
	}
	if err := enc.Encode(o.testFloat32IsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat32IsLoaded: %w", err)
	}
	if err := enc.Encode(o.testFloat32IsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat32IsDirty: %w", err)
	}

	if err := enc.Encode(o.testFloat64); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat64: %w", err)
	}
	if err := enc.Encode(o.testFloat64IsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat64IsLoaded: %w", err)
	}
	if err := enc.Encode(o.testFloat64IsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testFloat64IsDirty: %w", err)
	}

	if err := enc.Encode(o.testNumeric); err != nil {
		return fmt.Errorf("error encoding TypeTest.testNumeric: %w", err)
	}
	if err := enc.Encode(o.testNumericIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testNumericIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testNumericIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testNumericIsDirty: %w", err)
	}

	if err := enc.Encode(o.testBool); err != nil {
		return fmt.Errorf("error encoding TypeTest.testBool: %w", err)
	}
	if err := enc.Encode(o.testBoolIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testBoolIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testBoolIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testBoolIsDirty: %w", err)
	}

	if err := enc.Encode(o.testUnlimitedString); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedString: %w", err)
	}
	if err := enc.Encode(o.testUnlimitedStringIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedStringIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testUnlimitedStringIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedStringIsDirty: %w", err)
	}

	if err := enc.Encode(o.testLimitedString); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedString: %w", err)
	}
	if err := enc.Encode(o.testLimitedStringIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedStringIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testLimitedStringIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedStringIsDirty: %w", err)
	}

	if err := enc.Encode(o.testLongstring); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLongstring: %w", err)
	}
	if err := enc.Encode(o.testLongstringIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLongstringIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testLongstringIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLongstringIsDirty: %w", err)
	}

	if err := enc.Encode(o.testUnlimitedBytes); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedBytes: %w", err)
	}
	if err := enc.Encode(o.testUnlimitedBytesIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedBytesIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testUnlimitedBytesIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testUnlimitedBytesIsDirty: %w", err)
	}

	if err := enc.Encode(o.testLimitedBytes); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedBytes: %w", err)
	}
	if err := enc.Encode(o.testLimitedBytesIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedBytesIsLoaded: %w", err)
	}
	if err := enc.Encode(o.testLimitedBytesIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.testLimitedBytesIsDirty: %w", err)
	}

	if err := enc.Encode(o.typeLongBytes); err != nil {
		return fmt.Errorf("error encoding TypeTest.typeLongBytes: %w", err)
	}
	if err := enc.Encode(o.typeLongBytesIsLoaded); err != nil {
		return fmt.Errorf("error encoding TypeTest.typeLongBytesIsLoaded: %w", err)
	}
	if err := enc.Encode(o.typeLongBytesIsDirty); err != nil {
		return fmt.Errorf("error encoding TypeTest.typeLongBytesIsDirty: %w", err)
	}

	if o._aliases == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o._aliases); err != nil {
			return fmt.Errorf("error encoding TypeTest._aliases: %w", err)
		}
	}

	if err := enc.Encode(o._restored); err != nil {
		return fmt.Errorf("error encoding TypeTest._restored: %w", err)
	}
	if err := enc.Encode(o._originalPK); err != nil {
		return fmt.Errorf("error encoding TypeTest._originalPK: %w", err)
	}
	return nil
}

// UnmarshalBinary converts a structure that was created with MarshalBinary into a TypeTest object.
func (o *typeTestBase) UnmarshalBinary(data []byte) (err error) {
	buf := bytes.NewReader(data)
	dec := gob.NewDecoder(buf)
	return o.decodeFrom(dec)
}

func (o *typeTestBase) decodeFrom(dec db.Decoder) (err error) {
	var isPtr bool

	_ = isPtr
	if err = dec.Decode(&o.id); err != nil {
		return fmt.Errorf("error decoding TypeTest.id: %w", err)
	}
	if err = dec.Decode(&o.idIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.idIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.idIsDirty: %w", err)
	}

	if err = dec.Decode(&o.date); err != nil {
		return fmt.Errorf("error decoding TypeTest.date: %w", err)
	}
	if err = dec.Decode(&o.dateIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsNull: %w", err)
	}
	if err = dec.Decode(&o.dateIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.dateIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateIsDirty: %w", err)
	}

	if err = dec.Decode(&o.time); err != nil {
		return fmt.Errorf("error decoding TypeTest.time: %w", err)
	}
	if err = dec.Decode(&o.timeIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsNull: %w", err)
	}
	if err = dec.Decode(&o.timeIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.timeIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.timeIsDirty: %w", err)
	}

	if err = dec.Decode(&o.dateTime); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTime: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsNull: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.dateTimeIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.dateTimeIsDirty: %w", err)
	}

	if err = dec.Decode(&o.creationTime); err != nil {
		return fmt.Errorf("error decoding TypeTest.creationTime: %w", err)
	}
	if err = dec.Decode(&o.creationTimeIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.creationTimeIsLoaded: %w", err)
	}

	if err = dec.Decode(&o.modifiedTime); err != nil {
		return fmt.Errorf("error decoding TypeTest.modifiedTime: %w", err)
	}
	if err = dec.Decode(&o.modifiedTimeIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.modifiedTimeIsLoaded: %w", err)
	}

	if err = dec.Decode(&o.testInt); err != nil {
		return fmt.Errorf("error decoding TypeTest.testInt: %w", err)
	}
	if err = dec.Decode(&o.testIntIsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsNull: %w", err)
	}
	if err = dec.Decode(&o.testIntIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testIntIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testIntIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testUnsigned); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnsigned: %w", err)
	}
	if err = dec.Decode(&o.testUnsignedIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnsignedIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testUnsignedIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnsignedIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testInt64); err != nil {
		return fmt.Errorf("error decoding TypeTest.testInt64: %w", err)
	}
	if err = dec.Decode(&o.testInt64IsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testInt64IsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testInt64IsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testInt64IsDirty: %w", err)
	}

	if err = dec.Decode(&o.testUint64); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUint64: %w", err)
	}
	if err = dec.Decode(&o.testUint64IsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUint64IsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testUint64IsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUint64IsDirty: %w", err)
	}

	if err = dec.Decode(&o.testFloat32); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat32: %w", err)
	}
	if err = dec.Decode(&o.testFloat32IsNull); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat32IsNull: %w", err)
	}
	if err = dec.Decode(&o.testFloat32IsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat32IsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testFloat32IsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat32IsDirty: %w", err)
	}

	if err = dec.Decode(&o.testFloat64); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat64: %w", err)
	}
	if err = dec.Decode(&o.testFloat64IsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat64IsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testFloat64IsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testFloat64IsDirty: %w", err)
	}

	if err = dec.Decode(&o.testNumeric); err != nil {
		return fmt.Errorf("error decoding TypeTest.testNumeric: %w", err)
	}
	if err = dec.Decode(&o.testNumericIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testNumericIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testNumericIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testNumericIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testBool); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBool: %w", err)
	}
	if err = dec.Decode(&o.testBoolIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBoolIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testBoolIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testBoolIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testUnlimitedString); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedString: %w", err)
	}
	if err = dec.Decode(&o.testUnlimitedStringIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedStringIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testUnlimitedStringIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedStringIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testLimitedString); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedString: %w", err)
	}
	if err = dec.Decode(&o.testLimitedStringIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedStringIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testLimitedStringIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedStringIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testLongstring); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLongstring: %w", err)
	}
	if err = dec.Decode(&o.testLongstringIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLongstringIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testLongstringIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLongstringIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testUnlimitedBytes); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedBytes: %w", err)
	}
	if err = dec.Decode(&o.testUnlimitedBytesIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedBytesIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testUnlimitedBytesIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testUnlimitedBytesIsDirty: %w", err)
	}

	if err = dec.Decode(&o.testLimitedBytes); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedBytes: %w", err)
	}
	if err = dec.Decode(&o.testLimitedBytesIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedBytesIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.testLimitedBytesIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.testLimitedBytesIsDirty: %w", err)
	}

	if err = dec.Decode(&o.typeLongBytes); err != nil {
		return fmt.Errorf("error decoding TypeTest.typeLongBytes: %w", err)
	}
	if err = dec.Decode(&o.typeLongBytesIsLoaded); err != nil {
		return fmt.Errorf("error decoding TypeTest.typeLongBytesIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.typeLongBytesIsDirty); err != nil {
		return fmt.Errorf("error decoding TypeTest.typeLongBytesIsDirty: %w", err)
	}

	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding TypeTest._aliases isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o._aliases); err != nil {
			return fmt.Errorf("error decoding TypeTest._aliases: %w", err)
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return fmt.Errorf("error decoding TypeTest._restored: %w", err)
	}
	if err = dec.Decode(&o._originalPK); err != nil {
		return fmt.Errorf("error decoding TypeTest._originalPK: %w", err)
	}
	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *typeTestBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *typeTestBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsLoaded {
		v["id"] = o.id
	}

	if o.dateIsLoaded {
		if o.dateIsNull {
			v["date"] = nil
		} else {
			v["date"] = o.date
		}
	}

	if o.timeIsLoaded {
		if o.timeIsNull {
			v["time"] = nil
		} else {
			v["time"] = o.time
		}
	}

	if o.dateTimeIsLoaded {
		if o.dateTimeIsNull {
			v["dateTime"] = nil
		} else {
			v["dateTime"] = o.dateTime
		}
	}

	if o.creationTimeIsLoaded {
		v["creationTime"] = o.creationTime
	}

	if o.modifiedTimeIsLoaded {
		v["modifiedTime"] = o.modifiedTime
	}

	if o.testIntIsLoaded {
		if o.testIntIsNull {
			v["testInt"] = nil
		} else {
			v["testInt"] = o.testInt
		}
	}

	if o.testUnsignedIsLoaded {
		v["testUnsigned"] = o.testUnsigned
	}

	if o.testInt64IsLoaded {
		v["testInt64"] = o.testInt64
	}

	if o.testUint64IsLoaded {
		v["testUint64"] = o.testUint64
	}

	if o.testFloat32IsLoaded {
		if o.testFloat32IsNull {
			v["testFloat32"] = nil
		} else {
			v["testFloat32"] = o.testFloat32
		}
	}

	if o.testFloat64IsLoaded {
		v["testFloat64"] = o.testFloat64
	}

	if o.testNumericIsLoaded {
		v["testNumeric"] = o.testNumeric
	}

	if o.testBoolIsLoaded {
		v["testBool"] = o.testBool
	}

	if o.testUnlimitedStringIsLoaded {
		v["testUnlimitedString"] = o.testUnlimitedString
	}

	if o.testLimitedStringIsLoaded {
		v["testLimitedString"] = o.testLimitedString
	}

	if o.testLongstringIsLoaded {
		v["testLongstring"] = o.testLongstring
	}

	if o.testUnlimitedBytesIsLoaded {
		v["testUnlimitedBytes"] = o.testUnlimitedBytes
	}

	if o.testLimitedBytesIsLoaded {
		v["testLimitedBytes"] = o.testLimitedBytes
	}

	if o.typeLongBytesIsLoaded {
		v["typeLongBytes"] = o.typeLongBytes
	}

	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the TypeTest. The TypeTest can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//
//	"id" - string
//	"date" - time.Time, nullable
//	"time" - time.Time, nullable
//	"dateTime" - time.Time, nullable
//	"creationTime" - time.Time
//	"modifiedTime" - time.Time
//	"testInt" - int, nullable
//	"testUnsigned" - uint
//	"testInt64" - int64
//	"testUint64" - uint64
//	"testFloat32" - float32, nullable
//	"testFloat64" - float64
//	"testNumeric" - string
//	"testBool" - bool
//	"testUnlimitedString" - string
//	"testLimitedString" - string
//	"testLongstring" - string
//	"testUnlimitedBytes" - []byte
//	"testLimitedBytes" - []byte
//	"typeLongBytes" - []byte
func (o *typeTestBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if len(data) == 0 {
		return
	}
	d := json.NewDecoder(bytes.NewReader(data))
	d.UseNumber() // use a number to avoid precision errors
	if err = d.Decode(&v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in TypeTest to modify the json before sending it here.
func (o *typeTestBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {

		case "id":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetID(s)
				}
			}
		case "date":
			{
				if v == nil {
					o.SetDateToNull()
					continue
				}

				switch d := v.(type) {
				case json.Number:
					// a numeric value, which for JSON, means milliseconds since epoc
					n2, err := d.Int64()
					if err != nil {
						return err
					}
					o.SetDate(time.UnixMilli(n2).UTC())
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}
		case "time":
			{
				if v == nil {
					o.SetTimeToNull()
					continue
				}

				switch d := v.(type) {
				case json.Number:
					// a numeric value, which for JSON, means milliseconds since epoc
					n2, err := d.Int64()
					if err != nil {
						return err
					}
					o.SetTime(time.UnixMilli(n2).UTC())
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetTime(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetTime(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}
		case "dateTime":
			{
				if v == nil {
					o.SetDateTimeToNull()
					continue
				}

				switch d := v.(type) {
				case json.Number:
					// a numeric value, which for JSON, means milliseconds since epoc
					n2, err := d.Int64()
					if err != nil {
						return err
					}
					o.SetDateTime(time.UnixMilli(n2).UTC())
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetDateTime(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetDateTime(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}
		case "testInt":
			{
				if v == nil {
					o.SetTestIntToNull()
					continue
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetTestInt(int(n2))
				case int:
					o.SetTestInt(n)
				case float64:
					o.SetTestInt(int(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testUnsigned":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetTestUnsigned(uint(n2))
				case int:
					o.SetTestUnsigned(uint(n))
				case uint:
					o.SetTestUnsigned(n)
				case float64:
					o.SetTestUnsigned(uint(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testInt64":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetTestInt64(n2)
				case int:
					o.SetTestInt64(int64(n))
				case float64:
					o.SetTestInt64(int64(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testUint64":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetTestUint64(uint64(n2))
				case uint64:
					o.SetTestUint64(n)
				case int:
					o.SetTestUint64(uint64(n))
				case float64:
					o.SetTestUint64(uint64(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testFloat32":
			{
				if v == nil {
					o.SetTestFloat32ToNull()
					continue
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Float64()
					if err != nil {
						return err
					}
					o.SetTestFloat32(float32(n2))
				case float64:
					o.SetTestFloat32(float32(n))
				case float32:
					o.SetTestFloat32(n)
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testFloat64":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Float64()
					if err != nil {
						return err
					}
					o.SetTestFloat64(n2)
				case float64:
					o.SetTestFloat64(n)
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}
		case "testNumeric":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestNumeric(s)
				}
			}
		case "testBool":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if b, ok := v.(bool); !ok {
					return fmt.Errorf("json field %s must be a boolean", k)
				} else {
					o.SetTestBool(b)
				}
			}
		case "testUnlimitedString":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestUnlimitedString(s)
				}
			}
		case "testLimitedString":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestLimitedString(s)
				}
			}
		case "testLongstring":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetTestLongstring(s)
				}
			}
		case "testUnlimitedBytes":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetTestUnlimitedBytes(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetTestUnlimitedBytes(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}
		case "testLimitedBytes":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetTestLimitedBytes(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetTestLimitedBytes(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}
		case "typeLongBytes":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetTypeLongBytes(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetTypeLongBytes(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}
		}
	}
	return
}
