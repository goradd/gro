// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"context"
	"testing"

	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
)

// createMinimalSampleUnsupportedType creates an unsaved minimal version of a UnsupportedType object
// for testing.
func createMinimalSampleUnsupportedType() *UnsupportedType {
	obj := NewUnsupportedType()
	updateMinimalSampleUnsupportedType(obj)

	obj.SetTypeSerial(test.RandomValue[uint64](64))

	return obj
}

// updateMinimalSampleUnsupportedType sets the values of a minimal sample to new, random values.
func updateMinimalSampleUnsupportedType(obj *UnsupportedType) {

	obj.SetTypeTinyblob(test.RandomValue[[]byte](255))

	obj.SetTypeSmall(test.RandomValue[int](16))

	obj.SetTypeMedium(test.RandomValue[int](24))

	obj.SetTypeMultfk1(test.RandomValue[string](50))

	obj.SetTypeMultifk2(test.RandomValue[string](50))

}

// createMaximalSampleUnsupportedType creates an unsaved version of a UnsupportedType object
// for testing that includes references to minimal objects.
func createMaximalSampleUnsupportedType(ctx context.Context) *UnsupportedType {
	obj := NewUnsupportedType()
	obj.SetTypeSerial(test.RandomValue[uint64](64))
	updateMaximalSampleUnsupportedType(ctx, obj)
	return obj
}

// updateMaximalSampleUnsupportedType sets all the maximal sample values to new values.
// This will set new values for references, so save the old values and delete them.
func updateMaximalSampleUnsupportedType(ctx context.Context, obj *UnsupportedType) {
	updateMinimalSampleUnsupportedType(obj)

}

// deleteSampleUnsupportedType deletes an object created and saved by one of the sample creator functions.
func deleteSampleUnsupportedType(ctx context.Context, obj *UnsupportedType) {
	if obj == nil {
		return
	}

	_ = obj.Delete(ctx)

}

// assertEqualFieldsUnsupportedType compares two objects and asserts that the basic fields are equal.
func assertEqualFieldsUnsupportedType(t *testing.T, obj1, obj2 *UnsupportedType) {
	if obj1.TypeSerialIsLoaded() && obj2.TypeSerialIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeSerial(), obj2.TypeSerial())
	}
	if obj1.TypeSetIsLoaded() && obj2.TypeSetIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeSet(), obj2.TypeSet())
	}
	if obj1.TypeEnumeratedIsLoaded() && obj2.TypeEnumeratedIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeEnumerated(), obj2.TypeEnumerated())
	}
	if obj1.TypeGeoIsLoaded() && obj2.TypeGeoIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeGeo(), obj2.TypeGeo())
	}
	if obj1.TypeTinyblobIsLoaded() && obj2.TypeTinyblobIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeTinyblob(), obj2.TypeTinyblob())
	}
	if obj1.TypeBinaryIsLoaded() && obj2.TypeBinaryIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeBinary(), obj2.TypeBinary())
	}
	if obj1.TypeSmallIsLoaded() && obj2.TypeSmallIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeSmall(), obj2.TypeSmall())
	}
	if obj1.TypeMediumIsLoaded() && obj2.TypeMediumIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeMedium(), obj2.TypeMedium())
	}
	if obj1.TypePolygonIsLoaded() && obj2.TypePolygonIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypePolygon(), obj2.TypePolygon())
	}
	if obj1.TypeMultfk1IsLoaded() && obj2.TypeMultfk1IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeMultfk1(), obj2.TypeMultfk1())
	}
	if obj1.TypeMultifk2IsLoaded() && obj2.TypeMultifk2IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeMultifk2(), obj2.TypeMultifk2())
	}

}
