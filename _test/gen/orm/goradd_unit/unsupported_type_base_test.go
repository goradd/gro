// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"context"
	"testing"

	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUnsupportedType_SetTypeSet(t *testing.T) {

	obj := NewUnsupportedType()

	typeSet := test.RandomValue[[]uint8](5)
	obj.SetTypeSet(typeSet)
	assert.Equal(t, typeSet, obj.TypeSet())

	// test zero
	obj.SetTypeSet([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeSet(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeSet = test.RandomValue[[]uint8](6)
	assert.Panics(t, func() {
		obj.SetTypeSet(typeSet)
	})
}
func TestUnsupportedType_SetTypeEnum(t *testing.T) {

	obj := NewUnsupportedType()

	typeEnum := test.RandomValue[[]uint8](1)
	obj.SetTypeEnum(typeEnum)
	assert.Equal(t, typeEnum, obj.TypeEnum())

	// test zero
	obj.SetTypeEnum([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeEnum(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeEnum = test.RandomValue[[]uint8](2)
	assert.Panics(t, func() {
		obj.SetTypeEnum(typeEnum)
	})
}
func TestUnsupportedType_SetTypeDecimal(t *testing.T) {

	obj := NewUnsupportedType()

	typeDecimal := test.RandomValue[[]uint8](13)
	obj.SetTypeDecimal(typeDecimal)
	assert.Equal(t, typeDecimal, obj.TypeDecimal())

	// test zero
	obj.SetTypeDecimal([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeDecimal(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeDecimal = test.RandomValue[[]uint8](14)
	assert.Panics(t, func() {
		obj.SetTypeDecimal(typeDecimal)
	})
}
func TestUnsupportedType_SetTypeDouble(t *testing.T) {

	obj := NewUnsupportedType()

	typeDouble := test.RandomValue[float64](64)
	obj.SetTypeDouble(typeDouble)
	assert.Equal(t, typeDouble, obj.TypeDouble())

	// test zero
	obj.SetTypeDouble(0)
	assert.Equal(t, 0, obj.TypeDouble(), "set empty")

}
func TestUnsupportedType_SetTypeGeo(t *testing.T) {

	obj := NewUnsupportedType()

	typeGeo := test.RandomValue[[]uint8](0)
	obj.SetTypeGeo(typeGeo)
	assert.Equal(t, typeGeo, obj.TypeGeo())

	// test zero
	obj.SetTypeGeo([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeGeo(), "set empty")

}
func TestUnsupportedType_SetTypeTinyBlob(t *testing.T) {

	obj := NewUnsupportedType()

	typeTinyBlob := test.RandomValue[[]uint8](255)
	obj.SetTypeTinyBlob(typeTinyBlob)
	assert.Equal(t, typeTinyBlob, obj.TypeTinyBlob())

	// test zero
	obj.SetTypeTinyBlob([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeTinyBlob(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeTinyBlob = test.RandomValue[[]uint8](256)
	assert.Panics(t, func() {
		obj.SetTypeTinyBlob(typeTinyBlob)
	})
}
func TestUnsupportedType_SetTypeMediumBlob(t *testing.T) {

	obj := NewUnsupportedType()

	typeMediumBlob := test.RandomValue[[]uint8](16777215)
	obj.SetTypeMediumBlob(typeMediumBlob)
	assert.Equal(t, typeMediumBlob, obj.TypeMediumBlob())

	// test zero
	obj.SetTypeMediumBlob([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeMediumBlob(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeMediumBlob = test.RandomValue[[]uint8](16777216)
	assert.Panics(t, func() {
		obj.SetTypeMediumBlob(typeMediumBlob)
	})
}
func TestUnsupportedType_SetTypeVarbinary(t *testing.T) {

	obj := NewUnsupportedType()

	typeVarbinary := test.RandomValue[[]uint8](0)
	obj.SetTypeVarbinary(typeVarbinary)
	assert.Equal(t, typeVarbinary, obj.TypeVarbinary())

	// test zero
	obj.SetTypeVarbinary([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeVarbinary(), "set empty")

}
func TestUnsupportedType_SetTypeLongtext(t *testing.T) {

	obj := NewUnsupportedType()

	typeLongtext := test.RandomValue[string](4294967295)
	obj.SetTypeLongtext(typeLongtext)
	assert.Equal(t, typeLongtext, obj.TypeLongtext())

	// test zero
	obj.SetTypeLongtext("")
	assert.Equal(t, "", obj.TypeLongtext(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeLongtext = test.RandomValue[string](4294967296)
	assert.Panics(t, func() {
		obj.SetTypeLongtext(typeLongtext)
	})
}
func TestUnsupportedType_SetTypeBinary(t *testing.T) {

	obj := NewUnsupportedType()

	typeBinary := test.RandomValue[[]uint8](0)
	obj.SetTypeBinary(typeBinary)
	assert.Equal(t, typeBinary, obj.TypeBinary())

	// test zero
	obj.SetTypeBinary([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypeBinary(), "set empty")

}
func TestUnsupportedType_SetTypeSmall(t *testing.T) {

	obj := NewUnsupportedType()

	typeSmall := test.RandomValue[int](16)
	obj.SetTypeSmall(typeSmall)
	assert.Equal(t, typeSmall, obj.TypeSmall())

	// test zero
	obj.SetTypeSmall(0)
	assert.Equal(t, 0, obj.TypeSmall(), "set empty")

}
func TestUnsupportedType_SetTypeMedium(t *testing.T) {

	obj := NewUnsupportedType()

	typeMedium := test.RandomValue[int](32)
	obj.SetTypeMedium(typeMedium)
	assert.Equal(t, typeMedium, obj.TypeMedium())

	// test zero
	obj.SetTypeMedium(0)
	assert.Equal(t, 0, obj.TypeMedium(), "set empty")

}
func TestUnsupportedType_SetTypeBig(t *testing.T) {

	obj := NewUnsupportedType()

	typeBig := test.RandomValue[int64](64)
	obj.SetTypeBig(typeBig)
	assert.Equal(t, typeBig, obj.TypeBig())

	// test zero
	obj.SetTypeBig(0)
	assert.Equal(t, 0, obj.TypeBig(), "set empty")

}
func TestUnsupportedType_SetTypePolygon(t *testing.T) {

	obj := NewUnsupportedType()

	typePolygon := test.RandomValue[[]uint8](0)
	obj.SetTypePolygon(typePolygon)
	assert.Equal(t, typePolygon, obj.TypePolygon())

	// test zero
	obj.SetTypePolygon([]byte(nil))
	assert.Equal(t, []byte(nil), obj.TypePolygon(), "set empty")

}
func TestUnsupportedType_SetTypeUnsigned(t *testing.T) {

	obj := NewUnsupportedType()

	typeUnsigned := test.RandomValue[uint](0)
	obj.SetTypeUnsigned(typeUnsigned)
	assert.Equal(t, typeUnsigned, obj.TypeUnsigned())

	// test zero
	obj.SetTypeUnsigned(0x0)
	assert.Equal(t, 0x0, obj.TypeUnsigned(), "set empty")

}
func TestUnsupportedType_SetTypeMultfk1(t *testing.T) {

	obj := NewUnsupportedType()

	typeMultfk1 := test.RandomValue[string](50)
	obj.SetTypeMultfk1(typeMultfk1)
	assert.Equal(t, typeMultfk1, obj.TypeMultfk1())

	// test zero
	obj.SetTypeMultfk1("")
	assert.Equal(t, "", obj.TypeMultfk1(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeMultfk1 = test.RandomValue[string](51)
	assert.Panics(t, func() {
		obj.SetTypeMultfk1(typeMultfk1)
	})
}
func TestUnsupportedType_SetTypeMultifk2(t *testing.T) {

	obj := NewUnsupportedType()

	typeMultifk2 := test.RandomValue[string](50)
	obj.SetTypeMultifk2(typeMultifk2)
	assert.Equal(t, typeMultifk2, obj.TypeMultifk2())

	// test zero
	obj.SetTypeMultifk2("")
	assert.Equal(t, "", obj.TypeMultifk2(), "set empty")

	// test panic on setting value larger than maximum size allowed
	typeMultifk2 = test.RandomValue[string](51)
	assert.Panics(t, func() {
		obj.SetTypeMultifk2(typeMultifk2)
	})
}

// createMinimalSampleUnsupportedType creates and saves a minimal version of a UnsupportedType object
// for testing.
func createMinimalSampleUnsupportedType(ctx context.Context) *UnsupportedType {
	obj := NewUnsupportedType()

	typeDouble := test.RandomValue[float64](64)
	obj.SetTypeDouble(typeDouble)

	typeTinyBlob := test.RandomValue[[]uint8](255)
	obj.SetTypeTinyBlob(typeTinyBlob)

	typeMediumBlob := test.RandomValue[[]uint8](16777215)
	obj.SetTypeMediumBlob(typeMediumBlob)

	typeLongtext := test.RandomValue[string](4294967295)
	obj.SetTypeLongtext(typeLongtext)

	typeSmall := test.RandomValue[int](16)
	obj.SetTypeSmall(typeSmall)

	typeMedium := test.RandomValue[int](32)
	obj.SetTypeMedium(typeMedium)

	typeBig := test.RandomValue[int64](64)
	obj.SetTypeBig(typeBig)

	typeUnsigned := test.RandomValue[uint](0)
	obj.SetTypeUnsigned(typeUnsigned)

	typeMultfk1 := test.RandomValue[string](50)
	obj.SetTypeMultfk1(typeMultfk1)

	typeMultifk2 := test.RandomValue[string](50)
	obj.SetTypeMultifk2(typeMultifk2)

	obj.Save(ctx)
	return obj
}
func TestUnsupportedType_CRUD(t *testing.T) {
	obj := NewUnsupportedType()
	ctx := db.NewContext(nil)

	typeDouble := test.RandomValue[float64](64)
	obj.SetTypeDouble(typeDouble)

	typeTinyBlob := test.RandomValue[[]uint8](255)
	obj.SetTypeTinyBlob(typeTinyBlob)

	typeMediumBlob := test.RandomValue[[]uint8](16777215)
	obj.SetTypeMediumBlob(typeMediumBlob)

	typeLongtext := test.RandomValue[string](4294967295)
	obj.SetTypeLongtext(typeLongtext)

	typeSmall := test.RandomValue[int](16)
	obj.SetTypeSmall(typeSmall)

	typeMedium := test.RandomValue[int](32)
	obj.SetTypeMedium(typeMedium)

	typeBig := test.RandomValue[int64](64)
	obj.SetTypeBig(typeBig)

	typeUnsigned := test.RandomValue[uint](0)
	obj.SetTypeUnsigned(typeUnsigned)

	typeMultfk1 := test.RandomValue[string](50)
	obj.SetTypeMultfk1(typeMultfk1)

	typeMultifk2 := test.RandomValue[string](50)
	obj.SetTypeMultifk2(typeMultifk2)

	// Test retrieval
	obj = LoadUnsupportedType(ctx, obj.PrimaryKey())
	require.NotNil(t, obj)

	assert.True(t, obj.TypeSerialIsValid())
	assert.NotEmpty(t, obj.TypeSerial())

	assert.True(t, obj.TypeDoubleIsValid())
	assert.Equal(t, typeDouble, obj.TypeDouble())

	assert.True(t, obj.TypeTinyBlobIsValid())
	assert.Equal(t, typeTinyBlob, obj.TypeTinyBlob())

	assert.True(t, obj.TypeMediumBlobIsValid())
	assert.Equal(t, typeMediumBlob, obj.TypeMediumBlob())

	assert.True(t, obj.TypeLongtextIsValid())
	assert.Equal(t, typeLongtext, obj.TypeLongtext())

	assert.True(t, obj.TypeSmallIsValid())
	assert.Equal(t, typeSmall, obj.TypeSmall())

	assert.True(t, obj.TypeMediumIsValid())
	assert.Equal(t, typeMedium, obj.TypeMedium())

	assert.True(t, obj.TypeBigIsValid())
	assert.Equal(t, typeBig, obj.TypeBig())

	assert.True(t, obj.TypeUnsignedIsValid())
	assert.Equal(t, typeUnsigned, obj.TypeUnsigned())

	assert.True(t, obj.TypeMultfk1IsValid())
	assert.Equal(t, typeMultfk1, obj.TypeMultfk1())

	assert.True(t, obj.TypeMultifk2IsValid())
	assert.Equal(t, typeMultifk2, obj.TypeMultifk2())

}
