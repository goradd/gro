// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"strconv"
	"testing"
	"time"

	"github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createMinimalSampleTypeTest creates an unsaved minimal version of a TypeTest object
// for testing.
func createMinimalSampleTypeTest() *TypeTest {
	obj := NewTypeTest()
	updateMinimalSampleTypeTest(obj)

	return obj
}

// updateMinimalSampleTypeTest sets the values of a minimal sample to new, random values.
func updateMinimalSampleTypeTest(obj *TypeTest) {

	obj.SetDate(test.RandomValue[time.Time](0))

	obj.SetTime(test.RandomValue[time.Time](0))

	obj.SetDateTime(test.RandomValue[time.Time](0))

	obj.SetTestInt(test.RandomValue[int](32))

	obj.SetTestUnsigned(test.RandomValue[uint](32))

	obj.SetTestInt64(test.RandomValue[int64](64))

	obj.SetTestUint64(test.RandomValue[uint64](64))

	obj.SetTestFloat32(test.RandomValue[float32](32))

	obj.SetTestFloat64(test.RandomValue[float64](64))

	obj.SetTestNumeric(test.RandomDecimal(10, 4))

	obj.SetTestBool(test.RandomValue[bool](0))

	obj.SetTestUnlimitedString(test.RandomValue[string](0))

	obj.SetTestLimitedString(test.RandomValue[string](10))

	obj.SetTestLongstring(test.RandomValue[string](100000))

	obj.SetTestUnlimitedBytes(test.RandomValue[[]byte](0))

	obj.SetTestLimitedBytes(test.RandomValue[[]byte](10))

	obj.SetTypeLongBytes(test.RandomValue[[]byte](100000))

}

// createMaximalSampleTypeTest creates an unsaved version of a TypeTest object
// for testing that includes references to minimal objects.
func createMaximalSampleTypeTest(ctx context.Context) *TypeTest {
	obj := NewTypeTest()
	updateMaximalSampleTypeTest(ctx, obj)
	return obj
}

// updateMaximalSampleTypeTest sets all the maximal sample values to new values.
// This will set new values for references, so save the old values and delete them.
func updateMaximalSampleTypeTest(ctx context.Context, obj *TypeTest) {
	updateMinimalSampleTypeTest(obj)

}

// deleteSampleTypeTest deletes an object created and saved by one of the sample creator functions.
func deleteSampleTypeTest(ctx context.Context, obj *TypeTest) {
	if obj == nil {
		return
	}

	_ = obj.Delete(ctx)

}

// assertEqualFieldsTypeTest compares two objects and asserts that the basic fields are equal.
func assertEqualFieldsTypeTest(t *testing.T, obj1, obj2 *TypeTest) {
	if obj1.IDIsLoaded() && obj2.IDIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.ID(), obj2.ID())
	}
	if obj1.DateIsLoaded() && obj2.DateIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Date(), obj2.Date(), time.Second)
	}
	if obj1.TimeIsLoaded() && obj2.TimeIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Time(), obj2.Time(), time.Second)
	}
	if obj1.DateTimeIsLoaded() && obj2.DateTimeIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.DateTime(), obj2.DateTime(), time.Second)
	}
	if obj1.CreationTimeIsLoaded() && obj2.CreationTimeIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.CreationTime(), obj2.CreationTime(), time.Second)
	}
	if obj1.ModifiedTimeIsLoaded() && obj2.ModifiedTimeIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.ModifiedTime(), obj2.ModifiedTime(), time.Second)
	}
	if obj1.TestIntIsLoaded() && obj2.TestIntIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestInt(), obj2.TestInt())
	}
	if obj1.TestUnsignedIsLoaded() && obj2.TestUnsignedIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestUnsigned(), obj2.TestUnsigned())
	}
	if obj1.TestInt64IsLoaded() && obj2.TestInt64IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestInt64(), obj2.TestInt64())
	}
	if obj1.TestUint64IsLoaded() && obj2.TestUint64IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestUint64(), obj2.TestUint64())
	}
	if obj1.TestFloat32IsLoaded() && obj2.TestFloat32IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestFloat32(), obj2.TestFloat32())
	}
	if obj1.TestFloat64IsLoaded() && obj2.TestFloat64IsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestFloat64(), obj2.TestFloat64())
	}
	if obj1.TestNumericIsLoaded() && obj2.TestNumericIsLoaded() { // only check loaded values
		assert.True(t, test.EqualDecimals(obj1.TestNumeric(), obj2.TestNumeric()))
	}
	if obj1.TestBoolIsLoaded() && obj2.TestBoolIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestBool(), obj2.TestBool())
	}
	if obj1.TestUnlimitedStringIsLoaded() && obj2.TestUnlimitedStringIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestUnlimitedString(), obj2.TestUnlimitedString())
	}
	if obj1.TestLimitedStringIsLoaded() && obj2.TestLimitedStringIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestLimitedString(), obj2.TestLimitedString())
	}
	if obj1.TestLongstringIsLoaded() && obj2.TestLongstringIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestLongstring(), obj2.TestLongstring())
	}
	if obj1.TestUnlimitedBytesIsLoaded() && obj2.TestUnlimitedBytesIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestUnlimitedBytes(), obj2.TestUnlimitedBytes())
	}
	if obj1.TestLimitedBytesIsLoaded() && obj2.TestLimitedBytesIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TestLimitedBytes(), obj2.TestLimitedBytes())
	}
	if obj1.TypeLongBytesIsLoaded() && obj2.TypeLongBytesIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.TypeLongBytes(), obj2.TypeLongBytes())
	}

}

func TestTypeTest_SetID(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomNumberString()
	obj.SetID(val)
	assert.Equal(t, val, obj.ID())

	// test default
	obj.SetID("")
	assert.EqualValues(t, "", obj.ID(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](65)
	assert.Panics(t, func() {
		obj.SetID(val)
	})
}
func TestTypeTest_SetDate(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[time.Time](0)
	obj.SetDate(val)
	val = obj.Date()
	assert.Zero(t, val.Minute()) // make sure minute part is zero'd
	assert.Zero(t, val.Hour())   // make sure hour part is zero'd
	assert.Zero(t, val.Second()) // make sure second part is zero'd
	assert.False(t, obj.DateIsNull())

	// Test NULL
	obj.SetDateToNull()
	assert.EqualValues(t, time.Time{}, obj.Date())
	assert.True(t, obj.DateIsNull())

	// test default
	obj.SetDate(time.Time{})
	assert.EqualValues(t, time.Time{}, obj.Date(), "set default")

}
func TestTypeTest_SetTime(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[time.Time](0)
	obj.SetTime(val)
	val = obj.Time()
	assert.EqualValues(t, 1, val.Year())  // make sure year part is zero'd. The zero value of time.Time has a year of 1.
	assert.EqualValues(t, 1, val.Month()) // make sure month part is zero'd
	assert.EqualValues(t, 1, val.Day())   // make sure day part is zero'd
	assert.False(t, obj.TimeIsNull())

	// Test NULL
	obj.SetTimeToNull()
	assert.EqualValues(t, time.Time{}, obj.Time())
	assert.True(t, obj.TimeIsNull())

	// test default
	obj.SetTime(time.Time{})
	assert.EqualValues(t, time.Time{}, obj.Time(), "set default")

}
func TestTypeTest_SetDateTime(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[time.Time](0)
	obj.SetDateTime(val)
	assert.Equal(t, val, obj.DateTime())
	assert.False(t, obj.DateTimeIsNull())

	// Test NULL
	obj.SetDateTimeToNull()
	assert.EqualValues(t, time.Time{}, obj.DateTime())
	assert.True(t, obj.DateTimeIsNull())

	// test default
	obj.SetDateTime(time.Time{})
	assert.EqualValues(t, time.Time{}, obj.DateTime(), "set default")

}
func TestTypeTest_SetTestInt(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[int](32)
	obj.SetTestInt(val)
	assert.Equal(t, val, obj.TestInt())
	assert.False(t, obj.TestIntIsNull())

	// Test NULL
	obj.SetTestIntToNull()
	assert.EqualValues(t, 5, obj.TestInt())
	assert.True(t, obj.TestIntIsNull())

	// test default
	obj.SetTestInt(5)
	assert.EqualValues(t, 5, obj.TestInt(), "set default")

}
func TestTypeTest_SetTestUnsigned(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[uint](32)
	obj.SetTestUnsigned(val)
	assert.Equal(t, val, obj.TestUnsigned())

	// test default
	obj.SetTestUnsigned(0x0)
	assert.EqualValues(t, 0x0, obj.TestUnsigned(), "set default")

}
func TestTypeTest_SetTestInt64(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[int64](64)
	obj.SetTestInt64(val)
	assert.Equal(t, val, obj.TestInt64())

	// test default
	obj.SetTestInt64(0)
	assert.EqualValues(t, 0, obj.TestInt64(), "set default")

}
func TestTypeTest_SetTestUint64(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[uint64](64)
	obj.SetTestUint64(val)
	assert.Equal(t, val, obj.TestUint64())

	// test default
	obj.SetTestUint64(0x0)
	assert.EqualValues(t, 0x0, obj.TestUint64(), "set default")

}
func TestTypeTest_SetTestFloat32(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[float32](32)
	obj.SetTestFloat32(val)
	assert.Equal(t, val, obj.TestFloat32())
	assert.False(t, obj.TestFloat32IsNull())

	// Test NULL
	obj.SetTestFloat32ToNull()
	assert.EqualValues(t, 0, obj.TestFloat32())
	assert.True(t, obj.TestFloat32IsNull())

	// test default
	obj.SetTestFloat32(0)
	assert.EqualValues(t, 0, obj.TestFloat32(), "set default")

}
func TestTypeTest_SetTestFloat64(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[float64](64)
	obj.SetTestFloat64(val)
	assert.Equal(t, val, obj.TestFloat64())

	// test default
	obj.SetTestFloat64(0)
	assert.EqualValues(t, 0, obj.TestFloat64(), "set default")

}
func TestTypeTest_SetTestNumeric(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomDecimal(10, 4)
	obj.SetTestNumeric(val)
	assert.Equal(t, val, obj.TestNumeric())

	// test default
	obj.SetTestNumeric("")
	assert.EqualValues(t, "", obj.TestNumeric(), "set default")

}
func TestTypeTest_SetTestBool(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[bool](0)
	obj.SetTestBool(val)
	assert.Equal(t, val, obj.TestBool())

	// test default
	obj.SetTestBool(true)
	assert.EqualValues(t, true, obj.TestBool(), "set default")

}
func TestTypeTest_SetTestUnlimitedString(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](0)
	obj.SetTestUnlimitedString(val)
	assert.Equal(t, val, obj.TestUnlimitedString())

	// test default
	obj.SetTestUnlimitedString("")
	assert.EqualValues(t, "", obj.TestUnlimitedString(), "set default")

}
func TestTypeTest_SetTestLimitedString(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](10)
	obj.SetTestLimitedString(val)
	assert.Equal(t, val, obj.TestLimitedString())

	// test default
	obj.SetTestLimitedString("")
	assert.EqualValues(t, "", obj.TestLimitedString(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](11)
	assert.Panics(t, func() {
		obj.SetTestLimitedString(val)
	})
}
func TestTypeTest_SetTestLongstring(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](100000)
	obj.SetTestLongstring(val)
	assert.Equal(t, val, obj.TestLongstring())

	// test default
	obj.SetTestLongstring("")
	assert.EqualValues(t, "", obj.TestLongstring(), "set default")

}
func TestTypeTest_SetTestUnlimitedBytes(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[[]byte](0)
	obj.SetTestUnlimitedBytes(val)
	assert.Equal(t, val, obj.TestUnlimitedBytes())

	// test default
	obj.SetTestUnlimitedBytes([]byte{})
	assert.EqualValues(t, []byte{}, obj.TestUnlimitedBytes(), "set default")

}
func TestTypeTest_SetTestLimitedBytes(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[[]byte](10)
	obj.SetTestLimitedBytes(val)
	assert.Equal(t, val, obj.TestLimitedBytes())

	// test default
	obj.SetTestLimitedBytes([]byte{})
	assert.EqualValues(t, []byte{}, obj.TestLimitedBytes(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[[]byte](11)
	assert.Panics(t, func() {
		obj.SetTestLimitedBytes(val)
	})
}
func TestTypeTest_SetTypeLongBytes(t *testing.T) {

	obj := NewTypeTest()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[[]byte](100000)
	obj.SetTypeLongBytes(val)
	assert.Equal(t, val, obj.TypeLongBytes())

	// test default
	obj.SetTypeLongBytes([]byte{})
	assert.EqualValues(t, []byte{}, obj.TypeLongBytes(), "set default")

}

func TestTypeTest_Copy(t *testing.T) {
	obj := createMinimalSampleTypeTest()

	obj2 := obj.Copy()

	assert.Equal(t, obj.Date(), obj2.Date())
	assert.Equal(t, obj.Time(), obj2.Time())
	assert.Equal(t, obj.DateTime(), obj2.DateTime())
	assert.Equal(t, obj.TestInt(), obj2.TestInt())
	assert.Equal(t, obj.TestUnsigned(), obj2.TestUnsigned())
	assert.Equal(t, obj.TestInt64(), obj2.TestInt64())
	assert.Equal(t, obj.TestUint64(), obj2.TestUint64())
	assert.Equal(t, obj.TestFloat32(), obj2.TestFloat32())
	assert.Equal(t, obj.TestFloat64(), obj2.TestFloat64())
	assert.Equal(t, obj.TestNumeric(), obj2.TestNumeric())
	assert.Equal(t, obj.TestBool(), obj2.TestBool())
	assert.Equal(t, obj.TestUnlimitedString(), obj2.TestUnlimitedString())
	assert.Equal(t, obj.TestLimitedString(), obj2.TestLimitedString())
	assert.Equal(t, obj.TestLongstring(), obj2.TestLongstring())
	assert.Equal(t, obj.TestUnlimitedBytes(), obj2.TestUnlimitedBytes())
	assert.Equal(t, obj.TestLimitedBytes(), obj2.TestLimitedBytes())
	assert.Equal(t, obj.TypeLongBytes(), obj2.TypeLongBytes())

}

func TestTypeTest_BasicInsert(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	ctx := db.NewContext(nil)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)

	// Test retrieval
	obj2, err := LoadTypeTest(ctx, obj.PrimaryKey())
	require.NotNil(t, obj2)
	assert.NoError(t, err)

	assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

	assert.True(t, obj2.IDIsLoaded())
	assert.Panics(t, func() {
		obj2.SetID(obj2.ID())
	})

	assert.True(t, obj2.DateIsLoaded())
	assert.False(t, obj2.DateIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.dateIsDirty)
	obj2.SetDate(obj2.Date())
	assert.False(t, obj2.dateIsDirty)

	assert.True(t, obj2.TimeIsLoaded())
	assert.False(t, obj2.TimeIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.timeIsDirty)
	obj2.SetTime(obj2.Time())
	assert.False(t, obj2.timeIsDirty)

	assert.True(t, obj2.DateTimeIsLoaded())
	assert.False(t, obj2.DateTimeIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.dateTimeIsDirty)
	obj2.SetDateTime(obj2.DateTime())
	assert.False(t, obj2.dateTimeIsDirty)

	assert.True(t, obj2.CreationTimeIsLoaded())

	assert.True(t, obj2.ModifiedTimeIsLoaded())

	assert.True(t, obj2.TestIntIsLoaded())
	assert.False(t, obj2.TestIntIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testIntIsDirty)
	obj2.SetTestInt(obj2.TestInt())
	assert.False(t, obj2.testIntIsDirty)

	assert.True(t, obj2.TestUnsignedIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testUnsignedIsDirty)
	obj2.SetTestUnsigned(obj2.TestUnsigned())
	assert.False(t, obj2.testUnsignedIsDirty)

	assert.True(t, obj2.TestInt64IsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testInt64IsDirty)
	obj2.SetTestInt64(obj2.TestInt64())
	assert.False(t, obj2.testInt64IsDirty)

	assert.True(t, obj2.TestUint64IsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testUint64IsDirty)
	obj2.SetTestUint64(obj2.TestUint64())
	assert.False(t, obj2.testUint64IsDirty)

	assert.True(t, obj2.TestFloat32IsLoaded())
	assert.False(t, obj2.TestFloat32IsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testFloat32IsDirty)
	obj2.SetTestFloat32(obj2.TestFloat32())
	assert.False(t, obj2.testFloat32IsDirty)

	assert.True(t, obj2.TestFloat64IsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testFloat64IsDirty)
	obj2.SetTestFloat64(obj2.TestFloat64())
	assert.False(t, obj2.testFloat64IsDirty)

	assert.True(t, obj2.TestNumericIsLoaded())
	assert.True(t, test.EqualDecimals(obj.TestNumeric(), obj2.TestNumeric()))
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testNumericIsDirty)
	obj2.SetTestNumeric(obj2.TestNumeric())
	assert.False(t, obj2.testNumericIsDirty)

	assert.True(t, obj2.TestBoolIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testBoolIsDirty)
	obj2.SetTestBool(obj2.TestBool())
	assert.False(t, obj2.testBoolIsDirty)

	assert.True(t, obj2.TestUnlimitedStringIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testUnlimitedStringIsDirty)
	obj2.SetTestUnlimitedString(obj2.TestUnlimitedString())
	assert.False(t, obj2.testUnlimitedStringIsDirty)

	assert.True(t, obj2.TestLimitedStringIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testLimitedStringIsDirty)
	obj2.SetTestLimitedString(obj2.TestLimitedString())
	assert.False(t, obj2.testLimitedStringIsDirty)

	assert.True(t, obj2.TestLongstringIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testLongstringIsDirty)
	obj2.SetTestLongstring(obj2.TestLongstring())
	assert.False(t, obj2.testLongstringIsDirty)

	assert.True(t, obj2.TestUnlimitedBytesIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testUnlimitedBytesIsDirty)
	obj2.SetTestUnlimitedBytes(obj2.TestUnlimitedBytes())
	assert.False(t, obj2.testUnlimitedBytesIsDirty)

	assert.True(t, obj2.TestLimitedBytesIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.testLimitedBytesIsDirty)
	obj2.SetTestLimitedBytes(obj2.TestLimitedBytes())
	assert.False(t, obj2.testLimitedBytesIsDirty)

	assert.True(t, obj2.TypeLongBytesIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.typeLongBytesIsDirty)
	obj2.SetTypeLongBytes(obj2.TypeLongBytes())
	assert.False(t, obj2.typeLongBytesIsDirty)

}

func TestTypeTest_InsertPanics(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	_ = obj
	ctx := db.NewContext(nil)
	_ = ctx

	obj.testUnsignedIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testUnsignedIsLoaded = true

	obj.testInt64IsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testInt64IsLoaded = true

	obj.testUint64IsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testUint64IsLoaded = true

	obj.testFloat64IsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testFloat64IsLoaded = true

	obj.testNumericIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testNumericIsLoaded = true

	obj.testBoolIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testBoolIsLoaded = true

	obj.testUnlimitedStringIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testUnlimitedStringIsLoaded = true

	obj.testLimitedStringIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testLimitedStringIsLoaded = true

	obj.testLongstringIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testLongstringIsLoaded = true

	obj.testUnlimitedBytesIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testUnlimitedBytesIsLoaded = true

	obj.testLimitedBytesIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.testLimitedBytesIsLoaded = true

	obj.typeLongBytesIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.typeLongBytesIsLoaded = true

}

func TestTypeTest_BasicUpdate(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	ctx := db.NewContext(nil)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)
	updateMinimalSampleTypeTest(obj)
	assert.NoError(t, obj.Save(ctx))
	obj2, err := LoadTypeTest(ctx, obj.PrimaryKey())
	assert.NoError(t, err)

	assert.Equal(t, obj2.ID(), obj.ID(), "ID did not update")

	assert.WithinDuration(t, obj2.Date(), obj.Date(), time.Second, "Date not within one second")

	assert.WithinDuration(t, obj2.Time(), obj.Time(), time.Second, "Time not within one second")

	assert.WithinDuration(t, obj2.DateTime(), obj.DateTime(), time.Second, "DateTime not within one second")

	assert.WithinDuration(t, obj2.CreationTime(), obj.CreationTime(), time.Second, "CreationTime not within one second")

	assert.WithinDuration(t, obj2.ModifiedTime(), obj.ModifiedTime(), time.Second, "ModifiedTime not within one second")
	assert.Equal(t, obj2.TestInt(), obj.TestInt(), "TestInt did not update")
	assert.Equal(t, obj2.TestUnsigned(), obj.TestUnsigned(), "TestUnsigned did not update")
	assert.Equal(t, obj2.TestInt64(), obj.TestInt64(), "TestInt64 did not update")
	assert.Equal(t, obj2.TestUint64(), obj.TestUint64(), "TestUint64 did not update")
	assert.Equal(t, obj2.TestFloat32(), obj.TestFloat32(), "TestFloat32 did not update")
	assert.Equal(t, obj2.TestFloat64(), obj.TestFloat64(), "TestFloat64 did not update")
	assert.Equal(t, obj2.TestBool(), obj.TestBool(), "TestBool did not update")
	assert.Equal(t, obj2.TestUnlimitedString(), obj.TestUnlimitedString(), "TestUnlimitedString did not update")
	assert.Equal(t, obj2.TestLimitedString(), obj.TestLimitedString(), "TestLimitedString did not update")
	assert.Equal(t, obj2.TestLongstring(), obj.TestLongstring(), "TestLongstring did not update")
	assert.Equal(t, obj2.TestUnlimitedBytes(), obj.TestUnlimitedBytes(), "TestUnlimitedBytes did not update")
	assert.Equal(t, obj2.TestLimitedBytes(), obj.TestLimitedBytes(), "TestLimitedBytes did not update")
	assert.Equal(t, obj2.TypeLongBytes(), obj.TypeLongBytes(), "TypeLongBytes did not update")
}

func TestTypeTest_ReferenceLoad(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSampleTypeTest(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)

	// Test that referenced objects were saved and assigned ids

	// Test lazy loading
	obj2, err := LoadTypeTest(ctx, obj.PrimaryKey())
	assert.NoError(t, err)
	objPkOnly, err2 := LoadTypeTest(ctx, obj.PrimaryKey(), node.TypeTest().PrimaryKey())
	assert.NoError(t, err2)
	_ = obj2 // avoid error if there are no references
	_ = objPkOnly

	// test eager loading
	obj3, _ := LoadTypeTest(ctx, obj.PrimaryKey())
	_ = obj3 // avoid error if there are no references

}

func TestTypeTest_ReferenceUpdateNewObjects(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSampleTypeTest(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)

	obj2, _ := LoadTypeTest(ctx, obj.PrimaryKey())
	updateMaximalSampleTypeTest(ctx, obj2)
	assert.NoError(t, obj2.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj2)

	obj3, _ := LoadTypeTest(ctx, obj2.PrimaryKey())
	_ = obj3 // avoid error if there are no references

}

func TestTypeTest_ReferenceUpdateOldObjects(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSampleTypeTest(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)

	assert.NoError(t, obj.Save(ctx))

	obj2, _ := LoadTypeTest(ctx, obj.PrimaryKey())
	_ = obj2 // avoid error if there are no references

}
func TestTypeTest_EmptyPrimaryKeyGetter(t *testing.T) {
	obj := NewTypeTest()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)
}

func TestTypeTest_Getters(t *testing.T) {
	obj := createMinimalSampleTypeTest()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)

	ctx := db.NewContext(nil)
	require.NoError(t, obj.Save(ctx))
	defer deleteSampleTypeTest(ctx, obj)

	has, _ := HasTypeTest(ctx, obj.PrimaryKey())
	assert.True(t, has)

	obj2, _ := LoadTypeTest(ctx, obj.PrimaryKey(), node.TypeTest().PrimaryKey())

	assert.Equal(t, obj.ID(), obj.Get(node.TypeTest().ID().Identifier))
	assert.Equal(t, obj.Date(), obj.Get(node.TypeTest().Date().Identifier))
	assert.Panics(t, func() { obj2.Date() })
	assert.Nil(t, obj2.Get(node.TypeTest().Date().Identifier))
	assert.Equal(t, obj.Time(), obj.Get(node.TypeTest().Time().Identifier))
	assert.Panics(t, func() { obj2.Time() })
	assert.Nil(t, obj2.Get(node.TypeTest().Time().Identifier))
	assert.Equal(t, obj.DateTime(), obj.Get(node.TypeTest().DateTime().Identifier))
	assert.Panics(t, func() { obj2.DateTime() })
	assert.Nil(t, obj2.Get(node.TypeTest().DateTime().Identifier))
	assert.Equal(t, obj.CreationTime(), obj.Get(node.TypeTest().CreationTime().Identifier))
	assert.Panics(t, func() { obj2.CreationTime() })
	assert.Nil(t, obj2.Get(node.TypeTest().CreationTime().Identifier))
	assert.Equal(t, obj.ModifiedTime(), obj.Get(node.TypeTest().ModifiedTime().Identifier))
	assert.Panics(t, func() { obj2.ModifiedTime() })
	assert.Nil(t, obj2.Get(node.TypeTest().ModifiedTime().Identifier))
	assert.Equal(t, obj.TestInt(), obj.Get(node.TypeTest().TestInt().Identifier))
	assert.Panics(t, func() { obj2.TestInt() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestInt().Identifier))
	assert.Equal(t, obj.TestUnsigned(), obj.Get(node.TypeTest().TestUnsigned().Identifier))
	assert.Panics(t, func() { obj2.TestUnsigned() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestUnsigned().Identifier))
	assert.Equal(t, obj.TestInt64(), obj.Get(node.TypeTest().TestInt64().Identifier))
	assert.Panics(t, func() { obj2.TestInt64() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestInt64().Identifier))
	assert.Equal(t, obj.TestUint64(), obj.Get(node.TypeTest().TestUint64().Identifier))
	assert.Panics(t, func() { obj2.TestUint64() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestUint64().Identifier))
	assert.Equal(t, obj.TestFloat32(), obj.Get(node.TypeTest().TestFloat32().Identifier))
	assert.Panics(t, func() { obj2.TestFloat32() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestFloat32().Identifier))
	assert.Equal(t, obj.TestFloat64(), obj.Get(node.TypeTest().TestFloat64().Identifier))
	assert.Panics(t, func() { obj2.TestFloat64() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestFloat64().Identifier))
	assert.Equal(t, obj.TestNumeric(), obj.Get(node.TypeTest().TestNumeric().Identifier))
	assert.Panics(t, func() { obj2.TestNumeric() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestNumeric().Identifier))
	assert.Equal(t, obj.TestBool(), obj.Get(node.TypeTest().TestBool().Identifier))
	assert.Panics(t, func() { obj2.TestBool() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestBool().Identifier))
	assert.Equal(t, obj.TestUnlimitedString(), obj.Get(node.TypeTest().TestUnlimitedString().Identifier))
	assert.Panics(t, func() { obj2.TestUnlimitedString() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestUnlimitedString().Identifier))
	assert.Equal(t, obj.TestLimitedString(), obj.Get(node.TypeTest().TestLimitedString().Identifier))
	assert.Panics(t, func() { obj2.TestLimitedString() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestLimitedString().Identifier))
	assert.Equal(t, obj.TestLongstring(), obj.Get(node.TypeTest().TestLongstring().Identifier))
	assert.Panics(t, func() { obj2.TestLongstring() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestLongstring().Identifier))
	assert.Equal(t, obj.TestUnlimitedBytes(), obj.Get(node.TypeTest().TestUnlimitedBytes().Identifier))
	assert.Panics(t, func() { obj2.TestUnlimitedBytes() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestUnlimitedBytes().Identifier))
	assert.Equal(t, obj.TestLimitedBytes(), obj.Get(node.TypeTest().TestLimitedBytes().Identifier))
	assert.Panics(t, func() { obj2.TestLimitedBytes() })
	assert.Nil(t, obj2.Get(node.TypeTest().TestLimitedBytes().Identifier))
	assert.Equal(t, obj.TypeLongBytes(), obj.Get(node.TypeTest().TypeLongBytes().Identifier))
	assert.Panics(t, func() { obj2.TypeLongBytes() })
	assert.Nil(t, obj2.Get(node.TypeTest().TypeLongBytes().Identifier))
}

func TestTypeTest_QueryLoad(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleTypeTest(ctx, obj)

	objs, _ := QueryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().PrimaryKey(), obj.PrimaryKey())).
		OrderBy(node.TypeTest().PrimaryKey()). // exercise order by
		Limit(1, 0).                           // exercise limit
		Calculation(node.TypeTest(), "IsTrue", op.Equal(1, 1)).
		Load()

	assert.Equal(t, obj.PrimaryKey(), objs[0].PrimaryKey())
	assert.True(t, objs[0].GetAlias("IsTrue").Bool())
}
func TestTypeTest_QueryLoadI(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleTypeTest(ctx, obj)

	objs, _ := QueryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().PrimaryKey(), obj.PrimaryKey())).
		LoadI()

	assert.Equal(t, obj.PrimaryKey(), objs[0].Get("ID"))
}
func TestTypeTest_QueryCursor(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleTypeTest(ctx, obj)

	cursor, _ := QueryTypeTests(ctx).
		Where(op.Equal(node.TypeTest().PrimaryKey(), obj.PrimaryKey())).
		LoadCursor()

	obj2, err2 := cursor.Next()
	assert.Equal(t, obj.PrimaryKey(), obj2.PrimaryKey())
	assert.NoError(t, err2)
	obj2, err2 = cursor.Next()
	assert.Nil(t, obj2)
	assert.NoError(t, err2)
	assert.NoError(t, cursor.Close())

	// test empty cursor result
	cursor, err = QueryTypeTests(ctx).
		Where(op.Equal(1, 0)).
		LoadCursor()
	obj2, err = cursor.Next()
	assert.Nil(t, obj2)
	assert.NoError(t, err)
	assert.NoError(t, cursor.Close())
}
func TestTypeTest_Count(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSampleTypeTest(ctx)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleTypeTest(ctx, obj)
	// reread in case there are data limitations imposed by the database
	obj2, _ := LoadTypeTest(ctx, obj.PrimaryKey())

	assert.Positive(t, func() int { i, _ := CountTypeTests(ctx); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByID(ctx, obj2.ID()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByDate(ctx, obj2.Date()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTime(ctx, obj2.Time()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByDateTime(ctx, obj2.DateTime()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByCreationTime(ctx, obj2.CreationTime()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByModifiedTime(ctx, obj2.ModifiedTime()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestInt(ctx, obj2.TestInt()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestUnsigned(ctx, obj2.TestUnsigned()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestInt64(ctx, obj2.TestInt64()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestUint64(ctx, obj2.TestUint64()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestFloat32(ctx, obj2.TestFloat32()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestFloat64(ctx, obj2.TestFloat64()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestNumeric(ctx, obj2.TestNumeric()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestBool(ctx, obj2.TestBool()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestUnlimitedString(ctx, obj2.TestUnlimitedString()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestLimitedString(ctx, obj2.TestLimitedString()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestLongstring(ctx, obj2.TestLongstring()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestUnlimitedBytes(ctx, obj2.TestUnlimitedBytes()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTestLimitedBytes(ctx, obj2.TestLimitedBytes()); return i }())
	assert.Positive(t, func() int { i, _ := CountTypeTestsByTypeLongBytes(ctx, obj2.TypeLongBytes()); return i }())

}

func TestTypeTest_MarshalJSON(t *testing.T) {
	obj := createMinimalSampleTypeTest()

	b, err := json.Marshal(obj)
	assert.NoError(t, err)

	obj2 := NewTypeTest()
	err = json.Unmarshal(b, &obj2)
	assert.NoError(t, err)

	assertEqualFieldsTypeTest(t, obj, obj2)
}

func TestTypeTest_MarshalBinary(t *testing.T) {
	obj := createMinimalSampleTypeTest()

	b, err := obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 := NewTypeTest()
	err = obj2.UnmarshalBinary(b)
	assert.NoError(t, err)

	assertEqualFieldsTypeTest(t, obj, obj2)
}

func TestTypeTest_FailingMarshalBinary(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	var err error

	for i := 0; i < 66; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
	// do it again with aliases
	obj._aliases = make(map[string]any)
	for i := 0; i < 67; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
}

func TestTypeTest_FailingUnmarshalBinary(t *testing.T) {
	obj := createMinimalSampleTypeTest()
	b, err := obj.MarshalBinary()
	assert.NoError(t, err)
	obj2 := NewTypeTest()
	for i := 0; i < 66; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}

	// do it again with aliases
	obj = createMinimalSampleTypeTest()
	obj._aliases = map[string]any{"a": 1}
	b, err = obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 = NewTypeTest()
	for i := 0; i < 67; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}
}
