// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"context"
	"strconv"
	"testing"

	"github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createMinimalSampleRoot creates an unsaved minimal version of a Root object
// for testing.
func createMinimalSampleRoot() *Root {
	obj := NewRoot()
	updateMinimalSampleRoot(obj)
	return obj
}

// updateMinimalSampleRoot sets the values of a minimal sample to new, random values.
func updateMinimalSampleRoot(obj *Root) {

	obj.SetName(test.RandomValue[string](100))

	// A required forward reference will need to be fulfilled just to save the minimal version of this object
	// If the database is configured so that the referenced object points back here, either directly or through multiple
	// forward references, it possible this could create an endless loop. Such a structure could not be saved anyways.
	obj.SetRequiredLeaf(createMinimalSampleLeaf())

	// A required forward reference will need to be fulfilled just to save the minimal version of this object
	// If the database is configured so that the referenced object points back here, either directly or through multiple
	// forward references, it possible this could create an endless loop. Such a structure could not be saved anyways.
	obj.SetOptionalLeafUnique(createMinimalSampleLeaf())

	// A required forward reference will need to be fulfilled just to save the minimal version of this object
	// If the database is configured so that the referenced object points back here, either directly or through multiple
	// forward references, it possible this could create an endless loop. Such a structure could not be saved anyways.
	obj.SetRequiredLeafUnique(createMinimalSampleLeaf())

}

// createMaximalSampleRoot creates an unsaved version of a Root object
// for testing that includes references to minimal objects.
func createMaximalSampleRoot() *Root {
	obj := NewRoot()
	updateMaximalSampleRoot(obj)
	return obj
}

// updateMaximalSampleRoot sets all the maximal sample values to new values.
func updateMaximalSampleRoot(obj *Root) {
	updateMinimalSampleRoot(obj)

	obj.SetOptionalLeaf(createMinimalSampleLeaf())

	obj.SetParent(createMinimalSampleRoot())

	obj.SetParentRoots(createMinimalSampleRoot())
}

// deleteSampleRoot deletes an object created and saved by one of the sample creator functions.
func deleteSampleRoot(ctx context.Context, obj *Root) {
	if obj == nil {
		return
	}

	for _, item := range obj.ParentRoots() {
		deleteSampleRoot(ctx, item)
	}

	obj.Delete(ctx)

	deleteSampleLeaf(ctx, obj.OptionalLeaf())

	deleteSampleLeaf(ctx, obj.RequiredLeaf())

	deleteSampleLeaf(ctx, obj.OptionalLeafUnique())

	deleteSampleLeaf(ctx, obj.RequiredLeafUnique())

	deleteSampleRoot(ctx, obj.Parent())

}

func TestRoot_SetName(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](100)
	obj.SetName(val)
	assert.Equal(t, val, obj.Name())

	// test default
	obj.SetName("")
	assert.EqualValues(t, "", obj.Name(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](101)
	assert.Panics(t, func() {
		obj.SetName(val)
	})
}
func TestRoot_SetOptionalLeafID(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](0)
	obj.SetOptionalLeafID(val)
	assert.Equal(t, val, obj.OptionalLeafID())
	assert.False(t, obj.OptionalLeafIDIsNull())

	// Test NULL
	obj.SetOptionalLeafIDToNull()
	assert.EqualValues(t, "", obj.OptionalLeafID())
	assert.True(t, obj.OptionalLeafIDIsNull())

	// test default
	obj.SetOptionalLeafID("")
	assert.EqualValues(t, "", obj.OptionalLeafID(), "set default")

}
func TestRoot_SetRequiredLeafID(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](0)
	obj.SetRequiredLeafID(val)
	assert.Equal(t, val, obj.RequiredLeafID())

	// test default
	obj.SetRequiredLeafID("")
	assert.EqualValues(t, "", obj.RequiredLeafID(), "set default")

}
func TestRoot_SetOptionalLeafUniqueID(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](0)
	obj.SetOptionalLeafUniqueID(val)
	assert.Equal(t, val, obj.OptionalLeafUniqueID())

	// test default
	obj.SetOptionalLeafUniqueID("")
	assert.EqualValues(t, "", obj.OptionalLeafUniqueID(), "set default")

}
func TestRoot_SetRequiredLeafUniqueID(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](0)
	obj.SetRequiredLeafUniqueID(val)
	assert.Equal(t, val, obj.RequiredLeafUniqueID())

	// test default
	obj.SetRequiredLeafUniqueID("")
	assert.EqualValues(t, "", obj.RequiredLeafUniqueID(), "set default")

}
func TestRoot_SetParentID(t *testing.T) {

	obj := NewRoot()
	val := test.RandomValue[string](0)
	obj.SetParentID(val)
	assert.Equal(t, val, obj.ParentID())
	assert.False(t, obj.ParentIDIsNull())

	// Test NULL
	obj.SetParentIDToNull()
	assert.EqualValues(t, "", obj.ParentID())
	assert.True(t, obj.ParentIDIsNull())

	// test default
	obj.SetParentID("")
	assert.EqualValues(t, "", obj.ParentID(), "set default")

}

func TestRoot_Copy(t *testing.T) {
	obj := createMinimalSampleRoot()

	obj2 := obj.Copy()

	assert.Equal(t, obj.Name(), obj2.Name())
	assert.Equal(t, obj.OptionalLeafID(), obj2.OptionalLeafID())
	assert.Equal(t, obj.RequiredLeafID(), obj2.RequiredLeafID())
	assert.Equal(t, obj.OptionalLeafUniqueID(), obj2.OptionalLeafUniqueID())
	assert.Equal(t, obj.RequiredLeafUniqueID(), obj2.RequiredLeafUniqueID())
	assert.Equal(t, obj.ParentID(), obj2.ParentID())

}

func TestRoot_BasicInsert(t *testing.T) {
	obj := createMinimalSampleRoot()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleRoot(ctx, obj)

	// Test retrieval
	obj2 := LoadRoot(ctx, obj.PrimaryKey())
	require.NotNil(t, obj2)

	assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

	assert.True(t, obj2.IDIsValid())

	assert.True(t, obj2.NameIsValid())

	assert.EqualValues(t, obj.Name(), obj2.Name())

	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.nameIsDirty)
	obj2.SetName(obj2.Name())
	assert.False(t, obj2.nameIsDirty)

}

func TestRoot_InsertPanics(t *testing.T) {
	obj := createMinimalSampleRoot()
	ctx := db.NewContext(nil)

	obj.nameIsValid = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.nameIsValid = true

	obj.requiredLeafIDIsValid = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.requiredLeafIDIsValid = true

	obj.optionalLeafUniqueIDIsValid = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.optionalLeafUniqueIDIsValid = true

	obj.requiredLeafUniqueIDIsValid = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.requiredLeafUniqueIDIsValid = true

}

func TestRoot_BasicUpdate(t *testing.T) {
	obj := createMinimalSampleRoot()
	ctx := db.NewContext(nil)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleRoot(ctx, obj)
	updateMinimalSampleRoot(obj)
	assert.NoError(t, obj.Save(ctx))
	obj2 := LoadRoot(ctx, obj.PrimaryKey())

	assert.Equal(t, obj2.ID(), obj.ID(), "ID did not update")
	assert.Equal(t, obj2.Name(), obj.Name(), "Name did not update")
	assert.Equal(t, obj2.OptionalLeafID(), obj.OptionalLeafID(), "OptionalLeafID did not update")
	assert.Equal(t, obj2.RequiredLeafID(), obj.RequiredLeafID(), "RequiredLeafID did not update")
	assert.Equal(t, obj2.OptionalLeafUniqueID(), obj.OptionalLeafUniqueID(), "OptionalLeafUniqueID did not update")
	assert.Equal(t, obj2.RequiredLeafUniqueID(), obj.RequiredLeafUniqueID(), "RequiredLeafUniqueID did not update")
	assert.Equal(t, obj2.ParentID(), obj.ParentID(), "ParentID did not update")
}

func TestRoot_References(t *testing.T) {
	obj := createMaximalSampleRoot()
	ctx := db.NewContext(nil)
	obj.Save(ctx)
	defer deleteSampleRoot(ctx, obj)

	// Test that referenced objects were saved and assigned ids
	assert.NotNil(t, obj.OptionalLeaf())
	assert.NotEqual(t, '-', obj.OptionalLeaf().PrimaryKey()[0])

	assert.NotNil(t, obj.RequiredLeaf())
	assert.NotEqual(t, '-', obj.RequiredLeaf().PrimaryKey()[0])

	assert.NotNil(t, obj.OptionalLeafUnique())
	assert.NotEqual(t, '-', obj.OptionalLeafUnique().PrimaryKey()[0])

	assert.NotNil(t, obj.RequiredLeafUnique())
	assert.NotEqual(t, '-', obj.RequiredLeafUnique().PrimaryKey()[0])

	assert.NotNil(t, obj.Parent())
	assert.NotEqual(t, '-', obj.Parent().PrimaryKey()[0])

}
func TestRoot_EmptyPrimaryKeyGetter(t *testing.T) {
	obj := NewRoot()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)
}

func TestRoot_Getters(t *testing.T) {
	obj := createMinimalSampleRoot()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)

	ctx := db.NewContext(nil)
	require.NoError(t, obj.Save(ctx))
	defer deleteSampleRoot(ctx, obj)

	obj2 := LoadRoot(ctx, obj.PrimaryKey(), node.Root().PrimaryKey())

	assert.Panics(t, func() { obj2.Name() })
	assert.Panics(t, func() { obj2.OptionalLeafID() })
	assert.Panics(t, func() { obj2.RequiredLeafID() })
	assert.Panics(t, func() { obj2.OptionalLeafUniqueID() })
	assert.Panics(t, func() { obj2.RequiredLeafUniqueID() })
	assert.Panics(t, func() { obj2.ParentID() })
}
