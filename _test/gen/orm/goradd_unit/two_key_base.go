// Code generated by goradd-orm. DO NOT EDIT.

package goradd_unit

import (
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/query"
	"github.com/goradd/orm/pkg/broadcast"
	"context"
	"fmt"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/anyutil"
	"bytes"
	"encoding/gob"
	"encoding/json"
    "github.com/goradd/maps"
    "github.com/goradd/orm/_test/gen/orm/goradd_unit/node"
    "time"
    "unicode/utf8"
)


// TwoKeyPrimaryKey represents the composite key type of the primary key.
type TwoKeyPrimaryKey struct {
    Server string
    Directory string
}

// TwoKeyBase is embedded in a TwoKey object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the TwoKey embedder.
// Instead, use the accessor functions.
type twoKeyBase struct {
	server string
	serverIsLoaded bool
	serverIsDirty bool
	directory string
	directoryIsLoaded bool
	directoryIsDirty bool
	fileName string
	fileNameIsLoaded bool
	fileNameIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

    _originalPK TwoKeyPrimaryKey
}


// IDs used to access the TwoKey object fields by name using the Get function.
// doc: type=TwoKey
const  (
    TwoKeyServerField = `server`
    TwoKeyDirectoryField = `directory`
    TwoKeyFileNameField = `fileName`
)

    const TwoKeyServerMaxLength = 50 // The number of runes the column can hold
    const TwoKeyDirectoryMaxLength = 50 // The number of runes the column can hold
    const TwoKeyFileNameMaxLength = 50 // The number of runes the column can hold

// Initialize or re-initialize a TwoKey database object to default values.
func (o *twoKeyBase) Initialize() {
	o.server = ""
	o.serverIsLoaded = false
	o.serverIsDirty = false

	o.directory = ""
	o.directoryIsLoaded = false
	o.directoryIsDirty = false

	o.fileName = ""
	o.fileNameIsLoaded = false
	o.fileNameIsDirty = false


	o._aliases = nil
	o._restored = false
}


// Copy copies most fields to a new TwoKey object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Automatically generated fields will not be included in the copy.
// The primary key field will not be copied. You will need to manually set the primary key field before saving.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *twoKeyBase) Copy() (newObject *TwoKey) {
    newObject = NewTwoKey()
    if o.serverIsLoaded {
        newObject.SetServer(o.server)
    }
    if o.directoryIsLoaded {
        newObject.SetDirectory(o.directory)
    }
    if o.fileNameIsLoaded {
        newObject.SetFileName(o.fileName)
    }
    return
}
type TwoKeyPrimaryKey struct {
    Server string
    Directory string
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *twoKeyBase) OriginalPrimaryKey() TwoKeyPrimaryKey {
	return o._originalPK
}

// PrimaryKey returns the value of the primary key of the record.
func (o *twoKeyBase) PrimaryKey() TwoKeyPrimaryKey {
	if o._restored && !o.serverIsLoaded {
		panic ("Server was not selected in the last query and has not been set, and so PrimaryKey is not valid")
	}
	if o._restored && !o.directoryIsLoaded {
		panic ("Directory was not selected in the last query and has not been set, and so PrimaryKey is not valid")
	}
    return TwoKeyPrimaryKey {
        Server: o.server,
        Directory: o.directory,
    }
}

// SetPrimaryKey sets the value of the primary key in the object, to be saved later in the database using the Save() function.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *twoKeyBase) SetPrimaryKey(v TwoKeyPrimaryKey) {
    if o._restored {
        panic ("error: Do not change a primary key for a record that has been saved. Instead, save a copy and delete the original.")
    }
    if utf8.RuneCountInString(v) > TwoKeyServerMaxLength {
        panic("attempted to set TwoKey.Server to a value larger than its maximum length in runes")
    }
	o.serverIsLoaded = true
	o.serverIsDirty = true
    o.server = v.Server
    if utf8.RuneCountInString(v) > TwoKeyDirectoryMaxLength {
        panic("attempted to set TwoKey.Directory to a value larger than its maximum length in runes")
    }
	o.directoryIsLoaded = true
	o.directoryIsDirty = true
    o.directory = v.Directory
}



// FileName returns the value of FileName.
func (o *twoKeyBase) FileName() string {
	if o._restored && !o.fileNameIsLoaded {
		panic ("FileName was not selected in the last query and has not been set, and so is not valid")
	}
	return o.fileName
}

// FileNameIsLoaded returns true if the value was loaded from the database or has been set.
func (o *twoKeyBase) FileNameIsLoaded() bool {
	return o.fileNameIsLoaded
}

// SetFileName sets the value of FileName in the object, to be saved later in the database using the Save() function.
func (o *twoKeyBase) SetFileName(v string) {
    if utf8.RuneCountInString(v) > TwoKeyFileNameMaxLength {
        panic("attempted to set TwoKey.FileName to a value larger than its maximum length in runes")
    }
	if o._restored &&
	    o.fileNameIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
        o.fileName == v {
        // no change
        return
    }

	o.fileNameIsLoaded = true
	o.fileName = v
	o.fileNameIsDirty = true
}


// GetAlias returns the value for the Alias node aliasKey that was returned in the most
// recent query.
func (o *twoKeyBase) GetAlias(aliasKey string) query.AliasValue {
	if a,ok := o._aliases[aliasKey]; ok {
		return query.NewAliasValue(a)
	} else {
		panic ("Alias " + aliasKey + " not found.")
	}
}


// IsNew returns true if the object will create a new record when saved.
func (o *twoKeyBase) IsNew() bool {
	return !o._restored
}


// LoadTwoKey returns a TwoKey from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [TwoKeysBuilder.Select] for more info.
func LoadTwoKey(ctx context.Context, pk TwoKeyPrimaryKey, selectNodes ...query.Node) (*TwoKey, error) {
	return queryTwoKeys(ctx).
	    Where(op.Equal(node.TwoKey().Server(), pk.server)).
	    Where(op.Equal(node.TwoKey().Directory(), pk.directory)).
	    Select(selectNodes...).
	    Get()
}

// HasTwoKey returns true if a TwoKey with the given primary key exists in the database.
// doc: type=TwoKey
func HasTwoKey(ctx context.Context, pk TwoKeyPrimaryKey) (bool, error) {
    v, err := queryTwoKeys(ctx).
	    Where(op.Equal(node.TwoKey().Server(), pk.server)).
	    Where(op.Equal(node.TwoKey().Directory(), pk.directory)).
         Count()
    return v > 0, err
}


// The TwoKeyBuilder uses a builder pattern to create a query on the database.
// Create a TwoKeyBuilder by calling QueryTwoKeys, which will select all
// the TwoKey object in the database. Then filter and arrange those objects
// by calling Where, Select, etc.
// End a query by calling either Load, LoadI, LoadCursor, Get, or Count.
// A TwoKeyBuilder stores the context it will use to perform the query, and thus is
// meant to be a short-lived object. You should not save it for later use.
type TwoKeyBuilder struct {
	builder *query.Builder
	ctx context.Context
}

func newTwoKeyBuilder(ctx context.Context) *TwoKeyBuilder {
	b := TwoKeyBuilder{
		builder: query.NewBuilder(node.TwoKey()),
		ctx: ctx,
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of TwoKey objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *TwoKeyBuilder) Load() (twoKeys []*TwoKey, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	var results any

    ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new(TwoKey)
		o.unpack(item, o)
		twoKeys = append(twoKeys, o)
	}
	return
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a variety of interfaces that load arrays of objects, including KeyLabeler.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *TwoKeyBuilder) LoadI() (twoKeys []query.OrmObj, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd_unit")
	var results any

    ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new(TwoKey)
		o.unpack(item, o)
		twoKeys = append(twoKeys, o)
	}
	return
}


// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//   defer cursor.Close()
// to make sure the cursor gets closed.
//
func (b *TwoKeyBuilder) LoadCursor() (twoKeysCursor, error) {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd_unit")
	result, err := database.BuilderQuery(b.ctx, b.builder)
	var cursor query.CursorI
	if result != nil {
	    cursor = result.(query.CursorI)
	}
	return twoKeysCursor{cursor}, err
}

type twoKeysCursor struct {
	query.CursorI
}

// Next returns the current TwoKey object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c twoKeysCursor) Next() (*TwoKey, error) {
    if c.CursorI == nil {
        return nil, nil
    }

	row, err := c.CursorI.Next()
	if row == nil || err != nil {
		return nil, err
	}
	o := new(TwoKey)
	o.unpack(row, o)
	return o, nil
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
// If an error occurs, or no results are found, a nil is returned.
func (b *TwoKeyBuilder) Get() (*TwoKey, error) {
    results, err := b.Load()
    if err != nil || len(results) == 0 {
        return nil, err
    }
    return results[0], nil
}

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *TwoKeyBuilder)  Where(c query.Node) *TwoKeyBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *TwoKeyBuilder)  OrderBy(nodes... query.Sorter) *TwoKeyBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *TwoKeyBuilder)  Limit(maxRowCount int, offset int) *TwoKeyBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the two_key table will be queried and loaded.
// If nodes contains columns from the two_key table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *TwoKeyBuilder)  Select(nodes... query.Node) *TwoKeyBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *TwoKeyBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) *TwoKeyBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *TwoKeyBuilder)  Distinct() *TwoKeyBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *TwoKeyBuilder)  GroupBy(nodes... query.Node) *TwoKeyBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *TwoKeyBuilder)  Having(node query.Node)  *TwoKeyBuilder {
	 b.builder.Having(node)
	 return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *TwoKeyBuilder)  Count() (int, error) {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd_unit")

    ctx := b.ctx
	results, err := database.BuilderQuery(ctx, b.builder)
    if results == nil || err != nil {
        return 0, err
    }
	return results.(int), nil
}


// CountTwoKeys returns the total number of items in the two_key table.
func CountTwoKeys(ctx context.Context) (int, error) {
	return QueryTwoKeys(ctx).Count()
}


// unpack recursively transforms data coming from the database into ORM objects.
func (o *twoKeyBase) unpack (m map[string]interface{}, objThis *TwoKey) {

	
        

	if v, ok := m["server"]; ok && v != nil {
    	if o.server, ok = v.(string); ok {
			o.serverIsLoaded = true
			o.serverIsDirty = false
            o._originalPK.Server = o.server
		} else {
			panic("Wrong type found for server.")
		}
	} else {
		o.serverIsLoaded = false
		o.server = ""
		o.serverIsDirty = false
	}

    
	
        

	if v, ok := m["directory"]; ok && v != nil {
    	if o.directory, ok = v.(string); ok {
			o.directoryIsLoaded = true
			o.directoryIsDirty = false
            o._originalPK.Directory = o.directory
		} else {
			panic("Wrong type found for directory.")
		}
	} else {
		o.directoryIsLoaded = false
		o.directory = ""
		o.directoryIsDirty = false
	}

    
	
        

	if v, ok := m["file_name"]; ok && v != nil {
    	if o.fileName, ok = v.(string); ok {
			o.fileNameIsLoaded = true
			o.fileNameIsDirty = false
		} else {
			panic("Wrong type found for file_name.")
		}
	} else {
		o.fileNameIsLoaded = false
		o.fileName = ""
		o.fileNameIsDirty = false
	}

    



	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}


// save will update or insert the object, depending on the state of the object.
func (o *twoKeyBase) save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *twoKeyBase) update(ctx context.Context) error {
    if !o._restored {
        panic ("cannot update a record that was not originally read from the database.")
    }
    if !o.IsDirty() {
        return nil // nothing to save
    }

    var modifiedFields map[string]interface{}

    d := Database()
    err := db.WithTransaction(ctx, d, func(ctx context.Context) error {


        modifiedFields = getTwoKeyUpdateFields(o)
        if len(modifiedFields) != 0 {
            var err2 error

            _, err2 = d.Update(ctx, "two_key", "