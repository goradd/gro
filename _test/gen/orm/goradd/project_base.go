// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/query"
	"github.com/goradd/orm/pkg/broadcast"
	"context"
	"fmt"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/anyutil"
	"bytes"
	"encoding/gob"
	"encoding/json"
    "github.com/goradd/maps"
    "github.com/goradd/orm/_test/gen/orm/goradd/node"
)



// ProjectBase is embedded in a Project object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the Project embedder.
// Instead, use the accessor functions.
type projectBase struct {
	id string
	idIsLoaded bool
	idIsDirty bool
	num int
	numIsLoaded bool
	numIsDirty bool
	statusEnum ProjectStatus
	statusEnumIsLoaded bool
	statusEnumIsDirty bool
	managerId []byte
	managerIdIsNull bool
	managerIdIsLoaded bool
	managerIdIsDirty bool
	name string
	nameIsLoaded bool
	nameIsDirty bool
	description string
	descriptionIsNull bool
	descriptionIsLoaded bool
	descriptionIsDirty bool
	startDate time.Time
	startDateIsNull bool
	startDateIsLoaded bool
	startDateIsDirty bool
	endDate time.Time
	endDateIsNull bool
	endDateIsLoaded bool
	endDateIsDirty bool
	budget string
	budgetIsNull bool
	budgetIsLoaded bool
	budgetIsDirty bool
	spent string
	spentIsNull bool
	spentIsLoaded bool
	spentIsDirty bool
	parentProjectId []byte
	parentProjectIdIsNull bool
	parentProjectIdIsLoaded bool
	parentProjectIdIsDirty bool

// Many-Many references
    children maps.SliceMap[string, *Project]
    childrenPks []string                // Primary keys to associate at Save time
    childrenIsDirty bool
    parents maps.SliceMap[string, *Project]
    parentsPks []string                // Primary keys to associate at Save time
    parentsIsDirty bool
    teamMembers maps.SliceMap[string, *Person]
    teamMembersPks []string                // Primary keys to associate at Save time
    teamMembersIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

    _originalPK string
}


// IDs used to access the Project object fields by name using the Get function.
// doc: type=Project
const  (
    ProjectIdField = `id`
    ProjectNumField = `num`
    ProjectStatusEnumField = `statusEnum`
    ProjectManagerIdField = `managerId`
    ProjectNameField = `name`
    ProjectDescriptionField = `description`
    ProjectStartDateField = `startDate`
    ProjectEndDateField = `endDate`
    ProjectBudgetField = `budget`
    ProjectSpentField = `spent`
    ProjectParentProjectIdField = `parentProjectId`
    ProjectChildrenField = `children`
    ProjectParentsField = `parents`
    ProjectTeamMembersField = `teamMembers`
)

    const ProjectIdMaxLength = 32 // The number of runes the column can hold
    const ProjectNumMax = 2147483647
    const ProjectNumMin = -2147483648
    const ProjectNameMaxLength = 100 // The number of runes the column can hold
    const ProjectBudgetMaxLength = 14 // The number of runes the column can hold
    const ProjectSpentMaxLength = 14 // The number of runes the column can hold

// Initialize or re-initialize a Project database object to default values.
// The primary key will get a temporary unique value which will be replaced when the object is saved.
func (o *projectBase) Initialize() {
    o.id = db.TemporaryPrimaryKey()
	o.idIsLoaded = true
	o.idIsDirty = false

	o.num = 0
	o.numIsLoaded = false
	o.numIsDirty = false

	o.statusEnum = 0
	o.statusEnumIsLoaded = false
	o.statusEnumIsDirty = false

	o.managerId = []byte{}
	o.managerIdIsNull = true
	o.managerIdIsLoaded = false
	o.managerIdIsDirty = false

	o.name = ""
	o.nameIsLoaded = false
	o.nameIsDirty = false

	o.description = ""
	o.descriptionIsNull = true
	o.descriptionIsLoaded = false
	o.descriptionIsDirty = false

	o.startDate = time.Time{}
	o.startDateIsNull = true
	o.startDateIsLoaded = false
	o.startDateIsDirty = false

	o.endDate = time.Time{}
	o.endDateIsNull = true
	o.endDateIsLoaded = false
	o.endDateIsDirty = false

	o.budget = ""
	o.budgetIsNull = true
	o.budgetIsLoaded = false
	o.budgetIsDirty = false

	o.spent = ""
	o.spentIsNull = true
	o.spentIsLoaded = false
	o.spentIsDirty = false

	o.parentProjectId = []byte{}
	o.parentProjectIdIsNull = true
	o.parentProjectIdIsLoaded = false
	o.parentProjectIdIsDirty = false


// Many-Many reference objects.
    o.children.Clear()
    o.childrenPks = nil
    o.childrenIsDirty = false
    o.parents.Clear()
    o.parentsPks = nil
    o.parentsIsDirty = false
    o.teamMembers.Clear()
    o.teamMembersPks = nil
    o.teamMembersIsDirty = false

	o._aliases = nil
	o._restored = false
}



// PrimaryKey returns the current value of the primary key.
func (o *projectBase) PrimaryKey() string {
	return o.id
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *projectBase) OriginalPrimaryKey() string {
	return o._originalPK
}


// Copy copies most fields to a new Project object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Automatically generated fields will not be included in the copy.
// The primary key field will not be copied, since it is normally auto-generated.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *projectBase) Copy() (newObject *Project) {
    newObject = NewProject()
    if o.idIsLoaded {
        newObject.SetId(o.id)
    }
    if o.numIsLoaded {
        newObject.SetNum(o.num)
    }
    if o.statusEnumIsLoaded {
        newObject.SetStatusEnum(o.statusEnum)
    }
    if o.managerIdIsLoaded {
        newObject.SetManagerId(o.managerId)
    }
    if o.nameIsLoaded {
        newObject.SetName(o.name)
    }
    if o.descriptionIsLoaded {
        newObject.SetDescription(o.description)
    }
    if o.startDateIsLoaded {
        newObject.SetStartDate(o.startDate)
    }
    if o.endDateIsLoaded {
        newObject.SetEndDate(o.endDate)
    }
    if o.budgetIsLoaded {
        newObject.SetBudget(o.budget)
    }
    if o.spentIsLoaded {
        newObject.SetSpent(o.spent)
    }
    if o.parentProjectIdIsLoaded {
        newObject.SetParentProjectId(o.parentProjectId)
    }
    return
}
// PrimaryKey returns the value of the primary key of the record.
func (o *projectBase) PrimaryKey() string {
	if o._restored && !o.idIsLoaded {
		panic ("Id was not selected in the last query and has not been set, and so PrimaryKey is not valid")
	}
	return o.id
}

// SetPrimaryKey sets the value of the primary key in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the primary key value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *projectBase) SetPrimaryKey(v string) {
    if o._restored {
        panic ("error: Do not change a primary key for a record that has been saved. Instead, save a copy and delete the original.")
    }
    if utf8.RuneCountInString(v) > ProjectIdMaxLength {
        panic("attempted to set Project.Id to a value larger than its maximum length in runes")
    }
	o.idIsLoaded = true
	o.idIsDirty = true
	o.id = v
}

// Id returns the value of Id.
func (o *projectBase) Id() string {
	return o.PrimaryKey()
}

// SetId sets the value of Id in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the Id value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *projectBase) SetId(v string) {
    o.SetPrimaryKey(v)
}


// Num returns the value of Num.
func (o *projectBase) Num() int {
	if o._restored && !o.numIsLoaded {
		panic ("Num was not selected in the last query and has not been set, and so is not valid")
	}
	return o.num
}

// NumIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) NumIsLoaded() bool {
	return o.numIsLoaded
}

// SetNum sets the value of Num in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetNum(v int) {
	if o._restored &&
	    o.numIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
        o.num == v {
        // no change
        return
    }

	o.numIsLoaded = true
	o.num = v
	o.numIsDirty = true
}

// StatusEnum returns the value of StatusEnum.
func (o *projectBase) StatusEnum() ProjectStatus {
	if o._restored && !o.statusEnumIsLoaded {
		panic ("StatusEnum was not selected in the last query and has not been set, and so is not valid")
	}
	return o.statusEnum
}

// StatusEnumIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) StatusEnumIsLoaded() bool {
	return o.statusEnumIsLoaded
}

// SetStatusEnum sets the value of StatusEnum in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetStatusEnum(v ProjectStatus) {
	if o._restored &&
	    o.statusEnumIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
        o.statusEnum == v {
        // no change
        return
    }

	o.statusEnumIsLoaded = true
	o.statusEnum = v
	o.statusEnumIsDirty = true
}

// ManagerId returns the value of ManagerId.
func (o *projectBase) ManagerId() []byte {
	if o._restored && !o.managerIdIsLoaded {
		panic ("ManagerId was not selected in the last query and has not been set, and so is not valid")
	}
	return o.managerId
}

// ManagerIdIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) ManagerIdIsLoaded() bool {
	return o.managerIdIsLoaded
}


// ManagerIdIsNull returns true if the related database value is null.
func (o *projectBase) ManagerIdIsNull() bool {
	return o.managerIdIsNull
}

// SetManagerId copies the value of ManagerId, to be saved later in the database using the Save() function.
// Pass nil to set manager_id to NULL in the database.
func (o *projectBase) SetManagerId(v []byte) {
	if v == nil {
		o.SetManagerIdToNull()
   		return
    }


	if o._restored &&
	    o.managerIdIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.managerIdIsNull && // if the db value is null, force a set of value
        bytes.Equal(o.managerId, v) {
        // no change
        return
    }

	o.managerIdIsLoaded = true
	o.managerId = slices.Clone(v)
    o.managerIdIsNull = false
	o.managerIdIsDirty = true
}

// SetManagerIdToNull() will set the manager_id value in the database to NULL.
// ManagerId() will return the column's default value after this.
func (o *projectBase) SetManagerIdToNull() {
	if !o.managerIdIsLoaded || !o.managerIdIsNull {
        // If we know it is null in the database, don't save it
		o.managerIdIsDirty = true
	}
    o.managerIdIsLoaded = true
    o.managerIdIsNull = true
    o.managerId = []byte{}
}
// Name returns the value of Name.
func (o *projectBase) Name() string {
	if o._restored && !o.nameIsLoaded {
		panic ("Name was not selected in the last query and has not been set, and so is not valid")
	}
	return o.name
}

// NameIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) NameIsLoaded() bool {
	return o.nameIsLoaded
}

// SetName sets the value of Name in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetName(v string) {
    if utf8.RuneCountInString(v) > ProjectNameMaxLength {
        panic("attempted to set Project.Name to a value larger than its maximum length in runes")
    }
	if o._restored &&
	    o.nameIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
        o.name == v {
        // no change
        return
    }

	o.nameIsLoaded = true
	o.name = v
	o.nameIsDirty = true
}

// Description returns the value of Description.
func (o *projectBase) Description() string {
	if o._restored && !o.descriptionIsLoaded {
		panic ("Description was not selected in the last query and has not been set, and so is not valid")
	}
	return o.description
}

// DescriptionIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) DescriptionIsLoaded() bool {
	return o.descriptionIsLoaded
}


// DescriptionIsNull returns true if the related database value is null.
func (o *projectBase) DescriptionIsNull() bool {
	return o.descriptionIsNull
}

// SetDescription sets the value of Description in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetDescription(v string) {
	if o._restored &&
	    o.descriptionIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.descriptionIsNull && // if the db value is null, force a set of value
        o.description == v {
        // no change
        return
    }

	o.descriptionIsLoaded = true
	o.description = v
	o.descriptionIsDirty = true
    o.descriptionIsNull = false
}

// SetDescriptionToNull() will set the description value in the database to NULL.
// Description() will return the column's default value after this.
func (o *projectBase) SetDescriptionToNull() {
	if !o.descriptionIsLoaded || !o.descriptionIsNull {
        // If we know it is null in the database, don't save it
		o.descriptionIsDirty = true
	}
    o.descriptionIsLoaded = true
    o.descriptionIsNull = true
    o.description = ""
}
// StartDate returns the value of StartDate.
func (o *projectBase) StartDate() time.Time {
	if o._restored && !o.startDateIsLoaded {
		panic ("StartDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.startDate
}

// StartDateIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) StartDateIsLoaded() bool {
	return o.startDateIsLoaded
}


// StartDateIsNull returns true if the related database value is null.
func (o *projectBase) StartDateIsNull() bool {
	return o.startDateIsNull
}

// SetStartDate sets the value of StartDate in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *projectBase) SetStartDate(v time.Time) {
	if o._restored &&
	    o.startDateIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.startDateIsNull && // if the db value is null, force a set of value
        o.startDate.Equal(v) {
        // no change
        return
    }

	o.startDateIsLoaded = true
    v = v.UTC()
    v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())
	o.startDate = v
	o.startDateIsDirty = true
    o.startDateIsNull = false
}

// SetStartDateToNull() will set the start_date value in the database to NULL.
// StartDate() will return the column's default value after this.
func (o *projectBase) SetStartDateToNull() {
	if !o.startDateIsLoaded || !o.startDateIsNull {
        // If we know it is null in the database, don't save it
		o.startDateIsDirty = true
	}
    o.startDateIsLoaded = true
    o.startDateIsNull = true
    o.startDate = time.Time{}
}
// EndDate returns the value of EndDate.
func (o *projectBase) EndDate() time.Time {
	if o._restored && !o.endDateIsLoaded {
		panic ("EndDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.endDate
}

// EndDateIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) EndDateIsLoaded() bool {
	return o.endDateIsLoaded
}


// EndDateIsNull returns true if the related database value is null.
func (o *projectBase) EndDateIsNull() bool {
	return o.endDateIsNull
}

// SetEndDate sets the value of EndDate in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *projectBase) SetEndDate(v time.Time) {
	if o._restored &&
	    o.endDateIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.endDateIsNull && // if the db value is null, force a set of value
        o.endDate.Equal(v) {
        // no change
        return
    }

	o.endDateIsLoaded = true
    v = v.UTC()
    v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())
	o.endDate = v
	o.endDateIsDirty = true
    o.endDateIsNull = false
}

// SetEndDateToNull() will set the end_date value in the database to NULL.
// EndDate() will return the column's default value after this.
func (o *projectBase) SetEndDateToNull() {
	if !o.endDateIsLoaded || !o.endDateIsNull {
        // If we know it is null in the database, don't save it
		o.endDateIsDirty = true
	}
    o.endDateIsLoaded = true
    o.endDateIsNull = true
    o.endDate = time.Time{}
}
// Budget returns the value of Budget.
func (o *projectBase) Budget() string {
	if o._restored && !o.budgetIsLoaded {
		panic ("Budget was not selected in the last query and has not been set, and so is not valid")
	}
	return o.budget
}

// BudgetIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) BudgetIsLoaded() bool {
	return o.budgetIsLoaded
}


// BudgetIsNull returns true if the related database value is null.
func (o *projectBase) BudgetIsNull() bool {
	return o.budgetIsNull
}

// SetBudget sets the value of Budget in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetBudget(v string) {
    if utf8.RuneCountInString(v) > ProjectBudgetMaxLength {
        panic("attempted to set Project.Budget to a value larger than its maximum length in runes")
    }
	if o._restored &&
	    o.budgetIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.budgetIsNull && // if the db value is null, force a set of value
        o.budget == v {
        // no change
        return
    }

	o.budgetIsLoaded = true
	o.budget = v
	o.budgetIsDirty = true
    o.budgetIsNull = false
}

// SetBudgetToNull() will set the budget value in the database to NULL.
// Budget() will return the column's default value after this.
func (o *projectBase) SetBudgetToNull() {
	if !o.budgetIsLoaded || !o.budgetIsNull {
        // If we know it is null in the database, don't save it
		o.budgetIsDirty = true
	}
    o.budgetIsLoaded = true
    o.budgetIsNull = true
    o.budget = ""
}
// Spent returns the value of Spent.
func (o *projectBase) Spent() string {
	if o._restored && !o.spentIsLoaded {
		panic ("Spent was not selected in the last query and has not been set, and so is not valid")
	}
	return o.spent
}

// SpentIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) SpentIsLoaded() bool {
	return o.spentIsLoaded
}


// SpentIsNull returns true if the related database value is null.
func (o *projectBase) SpentIsNull() bool {
	return o.spentIsNull
}

// SetSpent sets the value of Spent in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetSpent(v string) {
    if utf8.RuneCountInString(v) > ProjectSpentMaxLength {
        panic("attempted to set Project.Spent to a value larger than its maximum length in runes")
    }
	if o._restored &&
	    o.spentIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.spentIsNull && // if the db value is null, force a set of value
        o.spent == v {
        // no change
        return
    }

	o.spentIsLoaded = true
	o.spent = v
	o.spentIsDirty = true
    o.spentIsNull = false
}

// SetSpentToNull() will set the spent value in the database to NULL.
// Spent() will return the column's default value after this.
func (o *projectBase) SetSpentToNull() {
	if !o.spentIsLoaded || !o.spentIsNull {
        // If we know it is null in the database, don't save it
		o.spentIsDirty = true
	}
    o.spentIsLoaded = true
    o.spentIsNull = true
    o.spent = ""
}
// ParentProjectId returns the value of ParentProjectId.
func (o *projectBase) ParentProjectId() []byte {
	if o._restored && !o.parentProjectIdIsLoaded {
		panic ("ParentProjectId was not selected in the last query and has not been set, and so is not valid")
	}
	return o.parentProjectId
}

// ParentProjectIdIsLoaded returns true if the value was loaded from the database or has been set.
func (o *projectBase) ParentProjectIdIsLoaded() bool {
	return o.parentProjectIdIsLoaded
}


// ParentProjectIdIsNull returns true if the related database value is null.
func (o *projectBase) ParentProjectIdIsNull() bool {
	return o.parentProjectIdIsNull
}

// SetParentProjectId copies the value of ParentProjectId, to be saved later in the database using the Save() function.
// Pass nil to set parent_project_id to NULL in the database.
func (o *projectBase) SetParentProjectId(v []byte) {
	if v == nil {
		o.SetParentProjectIdToNull()
   		return
    }


	if o._restored &&
	    o.parentProjectIdIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.parentProjectIdIsNull && // if the db value is null, force a set of value
        bytes.Equal(o.parentProjectId, v) {
        // no change
        return
    }

	o.parentProjectIdIsLoaded = true
	o.parentProjectId = slices.Clone(v)
    o.parentProjectIdIsNull = false
	o.parentProjectIdIsDirty = true
}

// SetParentProjectIdToNull() will set the parent_project_id value in the database to NULL.
// ParentProjectId() will return the column's default value after this.
func (o *projectBase) SetParentProjectIdToNull() {
	if !o.parentProjectIdIsLoaded || !o.parentProjectIdIsNull {
        // If we know it is null in the database, don't save it
		o.parentProjectIdIsDirty = true
	}
    o.parentProjectIdIsLoaded = true
    o.parentProjectIdIsNull = true
    o.parentProjectId = []byte{}
}

// GetAlias returns the value for the Alias node aliasKey that was returned in the most
// recent query.
func (o *projectBase) GetAlias(aliasKey string) query.AliasValue {
	if a,ok := o._aliases[aliasKey]; ok {
		return query.NewAliasValue(a)
	} else {
		panic ("Alias " + aliasKey + " not found.")
	}
}


// IsNew returns true if the object will create a new record when saved.
func (o *projectBase) IsNew() bool {
	return !o._restored
}

    

// Child returns a single Project object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) Child(pk string) *Project {
	return o.children.Get(pk)
}

// Children returns a slice of Project objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) Children() []*Project {
	return o.children.Values()
}

// SetChildren sets the associated objects to the given slice of Project objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetChildren(objs ...*Project) {
    o.children.Clear()
	o.childrenIsDirty = true
	o.childrenPks = nil
    for _,obj := range objs {
        o.children.Set(obj.PrimaryKey(), obj)
    }
}

// SetChildrenById prepares to associate Project objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetChildrenById(ids ...string) {
	o.children.Clear()
	o.childrenPks = ids
	o.childrenIsDirty = true
}

// LoadChildren loads the Project objects associated through the Child- relationship.
func (o *projectBase) LoadChildren(ctx context.Context) ([]*Project, error) {
    if o.childrenIsDirty && o.childrenPks == nil {
        panic("dirty many-many relationships cannot be loaded; call Save() first")
    }
    
    var objs []*Project
    var err error

    if o.childrenPks != nil {
        // Load the objects that will be associated after a Save
        objs, err = QueryProjects(ctx).
            Where(op.In(node.Project().PrimaryKey(), o.childrenPks...)).
            Load()
    } else {
        objs, err = QueryProjects(ctx).
            Where(op.Equal(node.Project().Parents(), o.PrimaryKey())).
            Load()
    }
    if err != nil {
        return nil, err
    }

    o.children.Clear()
	for _,obj := range objs {
	    o.children.Set(obj.PrimaryKey(), obj)
	}
	return o.children.Values(), err
}

// CountChildren counts the number of associated children objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountChildren(ctx context.Context) (int, error) {
	return QueryProjects(ctx).
		Where(op.Equal(node.Project().Parents(), o.PrimaryKey())).
		Count()

}

    

//  returns a single Project object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) (pk string) *Project {
	return o.parents.Get(pk)
}

// Parents returns a slice of Project objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) Parents() []*Project {
	return o.parents.Values()
}

// SetParents sets the associated objects to the given slice of Project objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetParents(objs ...*Project) {
    o.parents.Clear()
	o.parentsIsDirty = true
	o.parentsPks = nil
    for _,obj := range objs {
        o.parents.Set(obj.PrimaryKey(), obj)
    }
}

// SetParentsById prepares to associate Project objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetParentsById(ids ...string) {
	o.parents.Clear()
	o.parentsPks = ids
	o.parentsIsDirty = true
}

// LoadParents loads the Project objects associated through the -Child relationship.
func (o *projectBase) LoadParents(ctx context.Context) ([]*Project, error) {
    if o.parentsIsDirty && o.parentsPks == nil {
        panic("dirty many-many relationships cannot be loaded; call Save() first")
    }
    
    var objs []*Project
    var err error

    if o.parentsPks != nil {
        // Load the objects that will be associated after a Save
        objs, err = QueryProjects(ctx).
            Where(op.In(node.Project().PrimaryKey(), o.parentsPks...)).
            Load()
    } else {
        objs, err = QueryProjects(ctx).
            Where(op.Equal(node.Project().Children(), o.PrimaryKey())).
            Load()
    }
    if err != nil {
        return nil, err
    }

    o.parents.Clear()
	for _,obj := range objs {
	    o.parents.Set(obj.PrimaryKey(), obj)
	}
	return o.parents.Values(), err
}

// CountParents counts the number of associated parents objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountParents(ctx context.Context) (int, error) {
	return QueryProjects(ctx).
		Where(op.Equal(node.Project().Children(), o.PrimaryKey())).
		Count()

}

    

//  returns a single Person object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) (pk string) *Person {
	return o.teamMembers.Get(pk)
}

// TeamMembers returns a slice of Person objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) TeamMembers() []*Person {
	return o.teamMembers.Values()
}

// SetTeamMembers sets the associated objects to the given slice of Person objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetTeamMembers(objs ...*Person) {
    o.teamMembers.Clear()
	o.teamMembersIsDirty = true
	o.teamMembersPks = nil
    for _,obj := range objs {
        o.teamMembers.Set(obj.PrimaryKey(), obj)
    }
}

// SetTeamMembersById prepares to associate Person objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetTeamMembersById(ids ...string) {
	o.teamMembers.Clear()
	o.teamMembersPks = ids
	o.teamMembersIsDirty = true
}

// LoadTeamMembers loads the Person objects associated through the -Project relationship.
func (o *projectBase) LoadTeamMembers(ctx context.Context) ([]*Person, error) {
    if o.teamMembersIsDirty && o.teamMembersPks == nil {
        panic("dirty many-many relationships cannot be loaded; call Save() first")
    }
    
    var objs []*Person
    var err error

    if o.teamMembersPks != nil {
        // Load the objects that will be associated after a Save
        objs, err = QueryPeople(ctx).
            Where(op.In(node.Person().PrimaryKey(), o.teamMembersPks...)).
            Load()
    } else {
        objs, err = QueryPeople(ctx).
            Where(op.Equal(node.Person().Projects(), o.PrimaryKey())).
            Load()
    }
    if err != nil {
        return nil, err
    }

    o.teamMembers.Clear()
	for _,obj := range objs {
	    o.teamMembers.Set(obj.PrimaryKey(), obj)
	}
	return o.teamMembers.Values(), err
}

// CountTeamMembers counts the number of associated teamMembers objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountTeamMembers(ctx context.Context) (int, error) {
	return QueryPeople(ctx).
		Where(op.Equal(node.Person().Projects(), o.PrimaryKey())).
		Count()

}


// LoadProject returns a Project from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [ProjectsBuilder.Select] for more info.
func LoadProject(ctx context.Context, id string, selectNodes ...query.Node) (*Project, error) {
	return queryProjects(ctx).
	    Where(op.Equal(node.Project().Id(), id)).
	    Select(selectNodes...).
	    Get()
}

// HasProject returns true if a Project with the given primary key exists in the database.
// doc: type=Project
func HasProject(ctx context.Context, id string) (bool, error) {
    v, err := queryProjects(ctx).
	     Where(op.Equal(node.Project().Id(), id)).
         Count()
    return v > 0, err
}

// LoadProjectByNum queries for a single Project object by the given unique index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [ProjectsBuilder.Select].
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectByNum (ctx context.Context, num int, selectNodes ...query.Node) (*Project, error) {
    q := queryProjects(ctx)
    q = q.Where(op.Equal(node.Project().Num(), num))
    return q.Select(selectNodes...).Get()
}

// HasProjectByNum returns true if the
// given unique index values exist in the database.
// doc: type=Project
func HasProjectByNum (ctx context.Context, num int) (bool, error) {
    q := queryProjects(ctx)
    q = q.Where(op.Equal(node.Project().Num(), num))
    v, err := q.Count()
    return v > 0, err
}
 
// LoadProjectsByStatusEnum queries Project objects by the given index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [ProjectsBuilder.Select].
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectsByStatusEnum (ctx context.Context, statusEnum ProjectStatus, selectNodes ...query.Node) ([]*Project, error) {
    q := queryProjects(ctx)
    q = q.Where(op.Equal(node.Project().StatusEnum(), statusEnum))
    return q.Select(selectNodes...).Load()
}

// HasProjectsByStatusEnum returns true if the
// given index values exist in the database.
// doc: type=Project
func HasProjectsByStatusEnum (ctx context.Context, statusEnum ProjectStatus) (bool, error) {
    q := queryProjects(ctx)
    q = q.Where(op.Equal(node.Project().StatusEnum(), statusEnum))
    v, err := q.Count()
    return v > 0, err
}
 
// LoadProjectsByManagerId queries Project objects by the given index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [ProjectsBuilder.Select].
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectsByManagerId (ctx context.Context, managerId interface{}, selectNodes ...query.Node) ([]*Project, error) {
    q := queryProjects(ctx)
    if managerId == nil {
        q = q.Where(op.IsNull(node.Project().ManagerId()))
    } else {
        q = q.Where(op.Equal(node.Project().ManagerId(), managerId))
    }
    return q.Select(selectNodes...).Load()
}

// HasProjectsByManagerId returns true if the
// given index values exist in the database.
// doc: type=Project
func HasProjectsByManagerId (ctx context.Context, managerId interface{}) (bool, error) {
    q := queryProjects(ctx)
    if managerId == nil {
        q = q.Where(op.IsNull(node.Project().ManagerId()))
    } else {
        q = q.Where(op.Equal(node.Project().ManagerId(), managerId))
    }
    v, err := q.Count()
    return v > 0, err
}
 
// LoadProjectsByParentProjectId queries Project objects by the given index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [ProjectsBuilder.Select].
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectsByParentProjectId (ctx context.Context, parentProjectId interface{}, selectNodes ...query.Node) ([]*Project, error) {
    q := queryProjects(ctx)
    if parentProjectId == nil {
        q = q.Where(op.IsNull(node.Project().ParentProjectId()))
    } else {
        q = q.Where(op.Equal(node.Project().ParentProjectId(), parentProjectId))
    }
    return q.Select(selectNodes...).Load()
}

// HasProjectsByParentProjectId returns true if the
// given index values exist in the database.
// doc: type=Project
func HasProjectsByParentProjectId (ctx context.Context, parentProjectId interface{}) (bool, error) {
    q := queryProjects(ctx)
    if parentProjectId == nil {
        q = q.Where(op.IsNull(node.Project().ParentProjectId()))
    } else {
        q = q.Where(op.Equal(node.Project().ParentProjectId(), parentProjectId))
    }
    v, err := q.Count()
    return v > 0, err
}

// The ProjectBuilder uses a builder pattern to create a query on the database.
// Create a ProjectBuilder by calling QueryProjects, which will select all
// the Project object in the database. Then filter and arrange those objects
// by calling Where, Select, etc.
// End a query by calling either Load, LoadI, LoadCursor, Get, or Count.
// A ProjectBuilder stores the context it will use to perform the query, and thus is
// meant to be a short-lived object. You should not save it for later use.
type ProjectBuilder struct {
	builder *query.Builder
	ctx context.Context
}

func newProjectBuilder(ctx context.Context) *ProjectBuilder {
	b := ProjectBuilder{
		builder: query.NewBuilder(node.Project()),
		ctx: ctx,
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of Project objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *ProjectBuilder) Load() (projects []*Project, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any

    ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new(Project)
		o.unpack(item, o)
		projects = append(projects, o)
	}
	return
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a variety of interfaces that load arrays of objects, including KeyLabeler.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *ProjectBuilder) LoadI() (projects []query.OrmObj, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any

    ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new(Project)
		o.unpack(item, o)
		projects = append(projects, o)
	}
	return
}


// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//   defer cursor.Close()
// to make sure the cursor gets closed.
//
func (b *ProjectBuilder) LoadCursor() (projectsCursor, error) {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd")
	result, err := database.BuilderQuery(b.ctx, b.builder)
	var cursor query.CursorI
	if result != nil {
	    cursor = result.(query.CursorI)
	}
	return projectsCursor{cursor}, err
}

type projectsCursor struct {
	query.CursorI
}

// Next returns the current Project object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c projectsCursor) Next() (*Project, error) {
    if c.CursorI == nil {
        return nil, nil
    }

	row, err := c.CursorI.Next()
	if row == nil || err != nil {
		return nil, err
	}
	o := new(Project)
	o.unpack(row, o)
	return o, nil
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
// If an error occurs, or no results are found, a nil is returned.
func (b *ProjectBuilder) Get() (*Project, error) {
    results, err := b.Load()
    if err != nil || len(results) == 0 {
        return nil, err
    }
    return results[0], nil
}

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *ProjectBuilder)  Where(c query.Node) *ProjectBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *ProjectBuilder)  OrderBy(nodes... query.Sorter) *ProjectBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *ProjectBuilder)  Limit(maxRowCount int, offset int) *ProjectBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the project table will be queried and loaded.
// If nodes contains columns from the project table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *ProjectBuilder)  Select(nodes... query.Node) *ProjectBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *ProjectBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) *ProjectBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *ProjectBuilder)  Distinct() *ProjectBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *ProjectBuilder)  GroupBy(nodes... query.Node) *ProjectBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *ProjectBuilder)  Having(node query.Node)  *ProjectBuilder {
	 b.builder.Having(node)
	 return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *ProjectBuilder)  Count() (int, error) {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd")

    ctx := b.ctx
	results, err := database.BuilderQuery(ctx, b.builder)
    if results == nil || err != nil {
        return 0, err
    }
	return results.(int), nil
}


// CountProjects returns the total number of items in the project table.
func CountProjects(ctx context.Context) (int, error) {
	return QueryProjects(ctx).Count()
}

// CountProjectsByNum queries the database and returns the number of Project objects that
// have num.
// doc: type=Project
func CountProjectsByNum(ctx context.Context, num int ) (int, error) {
    v_num := num
	return QueryProjects(ctx).
	Where(op.Equal(node.Project().Num(), v_num)).
	Count()
}

// CountProjectsByStatusEnum queries the database and returns the number of Project objects that
// have statusEnum.
// doc: type=Project
func CountProjectsByStatusEnum(ctx context.Context, statusEnum ProjectStatus ) (int, error) {
    v_statusEnum := statusEnum
	return QueryProjects(ctx).
	Where(op.Equal(node.Project().StatusEnum(), v_statusEnum)).
	Count()
}

// CountProjectsByManagerId queries the database and returns the number of Project objects that
// have managerId.
// doc: type=Project
func CountProjectsByManagerId(ctx context.Context, managerId []byte ) (int, error) {
    v_managerId := managerId
	return QueryProjects(ctx).
	Where(op.Equal(node.Project().ManagerId(), v_managerId)).
	Count()
}

// CountProjectsByParentProjectId queries the database and returns the number of Project objects that
// have parentProjectId.
// doc: type=Project
func CountProjectsByParentProjectId(ctx context.Context, parentProjectId []byte ) (int, error) {
    v_parentProjectId := parentProjectId
	return QueryProjects(ctx).
	Where(op.Equal(node.Project().ParentProjectId(), v_parentProjectId)).
	Count()
}


// unpack recursively transforms data coming from the database into ORM objects.
func (o *projectBase) unpack (m map[string]interface{}, objThis *Project) {

	
        

	if v, ok := m["id"]; ok && v != nil {
    	if o.id, ok = v.(string); ok {
			o.idIsLoaded = true
			o.idIsDirty = false
            o._originalPK = o.id
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsLoaded = false
		o.id = ""
		o.idIsDirty = false
	}

    
	
        

	if v, ok := m["num"]; ok && v != nil {
    	if o.num, ok = v.(int); ok {
			o.numIsLoaded = true
			o.numIsDirty = false
		} else {
			panic("Wrong type found for num.")
		}
	} else {
		o.numIsLoaded = false
		o.num = 0
		o.numIsDirty = false
	}

    
	
        

	if v, ok := m["status_enum"]; ok && v != nil {
     	if i, ok2 := v.(int); ok2 {
           o.statusEnum = ProjectStatus(i)
			o.statusEnumIsLoaded = true
			o.statusEnumIsDirty = false
		} else {
			panic("Wrong type found for status_enum.")
		}
	} else {
		o.statusEnumIsLoaded = false
		o.statusEnum = 0
		o.statusEnumIsDirty = false
	}

    
	
	    

	if v, ok := m["manager_id"]; ok {
		if v == nil {
			o.managerId = []byte{}
			o.managerIdIsNull = true
			o.managerIdIsLoaded = true
			o.managerIdIsDirty = false
		} else if o.managerId, ok = v.([]byte); ok {
			o.managerIdIsNull = false
			o.managerIdIsLoaded = true
			o.managerIdIsDirty = false
		} else {
			panic("Wrong type found for manager_id.")
		}
	} else {
		o.managerIdIsLoaded = false
		o.managerIdIsNull = true
		o.managerId = []byte{}
		o.managerIdIsDirty = false
	}

	
	
        

	if v, ok := m["name"]; ok && v != nil {
    	if o.name, ok = v.(string); ok {
			o.nameIsLoaded = true
			o.nameIsDirty = false
		} else {
			panic("Wrong type found for name.")
		}
	} else {
		o.nameIsLoaded = false
		o.name = ""
		o.nameIsDirty = false
	}

    
	
	    

	if v, ok := m["description"]; ok {
		if v == nil {
			o.description = ""
			o.descriptionIsNull = true
			o.descriptionIsLoaded = true
			o.descriptionIsDirty = false
		} else if o.description, ok = v.(string); ok {
			o.descriptionIsNull = false
			o.descriptionIsLoaded = true
			o.descriptionIsDirty = false
		} else {
			panic("Wrong type found for description.")
		}
	} else {
		o.descriptionIsLoaded = false
		o.descriptionIsNull = true
		o.description = ""
		o.descriptionIsDirty = false
	}

	
	
	    

	if v, ok := m["start_date"]; ok {
		if v == nil {
			o.startDate = time.Time{}
			o.startDateIsNull = true
			o.startDateIsLoaded = true
			o.startDateIsDirty = false
		} else if o.startDate, ok = v.(time.Time); ok {
			o.startDateIsNull = false
			o.startDateIsLoaded = true
			o.startDateIsDirty = false
		} else {
			panic("Wrong type found for start_date.")
		}
	} else {
		o.startDateIsLoaded = false
		o.startDateIsNull = true
		o.startDate = time.Time{}
		o.startDateIsDirty = false
	}

	
	
	    

	if v, ok := m["end_date"]; ok {
		if v == nil {
			o.endDate = time.Time{}
			o.endDateIsNull = true
			o.endDateIsLoaded = true
			o.endDateIsDirty = false
		} else if o.endDate, ok = v.(time.Time); ok {
			o.endDateIsNull = false
			o.endDateIsLoaded = true
			o.endDateIsDirty = false
		} else {
			panic("Wrong type found for end_date.")
		}
	} else {
		o.endDateIsLoaded = false
		o.endDateIsNull = true
		o.endDate = time.Time{}
		o.endDateIsDirty = false
	}

	
	
	    

	if v, ok := m["budget"]; ok {
		if v == nil {
			o.budget = ""
			o.budgetIsNull = true
			o.budgetIsLoaded = true
			o.budgetIsDirty = false
		} else if o.budget, ok = v.(string); ok {
			o.budgetIsNull = false
			o.budgetIsLoaded = true
			o.budgetIsDirty = false
		} else {
			panic("Wrong type found for budget.")
		}
	} else {
		o.budgetIsLoaded = false
		o.budgetIsNull = true
		o.budget = ""
		o.budgetIsDirty = false
	}

	
	
	    

	if v, ok := m["spent"]; ok {
		if v == nil {
			o.spent = ""
			o.spentIsNull = true
			o.spentIsLoaded = true
			o.spentIsDirty = false
		} else if o.spent, ok = v.(string); ok {
			o.spentIsNull = false
			o.spentIsLoaded = true
			o.spentIsDirty = false
		} else {
			panic("Wrong type found for spent.")
		}
	} else {
		o.spentIsLoaded = false
		o.spentIsNull = true
		o.spent = ""
		o.spentIsDirty = false
	}

	
	
	    

	if v, ok := m["parent_project_id"]; ok {
		if v == nil {
			o.parentProjectId = []byte{}
			o.parentProjectIdIsNull = true
			o.parentProjectIdIsLoaded = true
			o.parentProjectIdIsDirty = false
		} else if o.parentProjectId, ok = v.([]byte); ok {
			o.parentProjectIdIsNull = false
			o.parentProjectIdIsLoaded = true
			o.parentProjectIdIsDirty = false
		} else {
			panic("Wrong type found for parent_project_id.")
		}
	} else {
		o.parentProjectIdIsLoaded = false
		o.parentProjectIdIsNull = true
		o.parentProjectId = []byte{}
		o.parentProjectIdIsDirty = false
	}

	

// Many-Many references
	

	if v, ok := m["Children"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.children.Clear()

			for _,v3 := range v2 {
				obj := new(Project)
				obj.unpack(v3, obj)
				o.children.Set(obj.PrimaryKey(), obj)
			}
			o.childrenPks = nil
		} else {
			panic("Wrong type found for children object.")
		}
	} else {
		o.children.Clear()
		o.childrenPks = nil
	}

	

	if v, ok := m["Parents"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.parents.Clear()

			for _,v3 := range v2 {
				obj := new(Project)
				obj.unpack(v3, obj)
				o.parents.Set(obj.PrimaryKey(), obj)
			}
			o.parentsPks = nil
		} else {
			panic("Wrong type found for parents object.")
		}
	} else {
		o.parents.Clear()
		o.parentsPks = nil
	}

	

	if v, ok := m["TeamMembers"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.teamMembers.Clear()

			for _,v3 := range v2 {
				obj := new(Person)
				obj.unpack(v3, obj)
				o.teamMembers.Set(obj.PrimaryKey(), obj)
			}
			o.teamMembersPks = nil
		} else {
			panic("Wrong type found for teamMembers object.")
		}
	} else {
		o.teamMembers.Clear()
		o.teamMembersPks = nil
	}



	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}


// save will update or insert the object, depending on the state of the object.
func (o *projectBase) save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *projectBase) update(ctx context.Context) error {
    if !o._restored {
        panic ("cannot update a record that was not originally read from the database.")
    }
    if !o.IsDirty() {
        return nil // nothing to save
    }

    var modifiedFields map[string]interface{}

    d := Database()
    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, 30 * time.Second)
    defer cancel()
    err := db.ExecuteTransaction(ctx, d, func() error {


        modifiedFields = getProjectUpdateFields(o)
        if len(modifiedFields) != 0 {
            var err2 error

            _, err2 = d.Update(ctx, "project", "id", o._originalPK, modifiedFields, "", 0)
            if err2 != nil {
                return err2
            }
        }


    
    {
        keys := o.children.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
        for i, k := range keys {
            obj := o.children.Get(k)
            if err := obj.Save(ctx); err != nil {
                return err
            }
            if obj.PrimaryKey() != k {
                // update key in the slice map without changing the order
                o.children.Delete(k)
                o.children.SetAt(i, obj.PrimaryKey(), obj)
            }
        }
        if o.childrenIsDirty {
            if (len(o.childrenPks) != 0) {
                if err := db.AssociateOnly(ctx,
                        d,
                        "related_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "project_id",
                        o.childrenPks); err != nil {
                    return err
                }
            } else {
                if err := db.AssociateOnly(ctx,
                        d,
                        "related_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "project_id",
                        o.children.Keys()); err != nil {
                    return err
                }
            }
        }
    }
    
    {
        keys := o.parents.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
        for i, k := range keys {
            obj := o.parents.Get(k)
            if err := obj.Save(ctx); err != nil {
                return err
            }
            if obj.PrimaryKey() != k {
                // update key in the slice map without changing the order
                o.parents.Delete(k)
                o.parents.SetAt(i, obj.PrimaryKey(), obj)
            }
        }
        if o.parentsIsDirty {
            if (len(o.parentsPks) != 0) {
                if err := db.AssociateOnly(ctx,
                        d,
                        "related_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "project_id",
                        o.parentsPks); err != nil {
                    return err
                }
            } else {
                if err := db.AssociateOnly(ctx,
                        d,
                        "related_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "project_id",
                        o.parents.Keys()); err != nil {
                    return err
                }
            }
        }
    }
    
    {
        keys := o.teamMembers.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
        for i, k := range keys {
            obj := o.teamMembers.Get(k)
            if err := obj.Save(ctx); err != nil {
                return err
            }
            if obj.PrimaryKey() != k {
                // update key in the slice map without changing the order
                o.teamMembers.Delete(k)
                o.teamMembers.SetAt(i, obj.PrimaryKey(), obj)
            }
        }
        if o.teamMembersIsDirty {
            if (len(o.teamMembersPks) != 0) {
                if err := db.AssociateOnly(ctx,
                        d,
                        "team_member_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "person_id",
                        o.teamMembersPks); err != nil {
                    return err
                }
            } else {
                if err := db.AssociateOnly(ctx,
                        d,
                        "team_member_project_assn",
                        "project_id",
                        o.PrimaryKey(),
                        "person_id",
                        o.teamMembers.Keys()); err != nil {
                    return err
                }
            }
        }
    }

        return nil
    }) // transaction
    if err != nil {
        return err
    }

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
        broadcast.Update(ctx, "goradd", "project", o._originalPK, anyutil.SortedKeys(modifiedFields)...)
	}

	return nil
}


// insert will insert the object into the database. Related items will be saved.
func (o *projectBase) insert(ctx context.Context) (err error) {
    var insertFields map[string]interface{}
    d := Database()

    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, 30 * time.Second)
    defer cancel()

	err = db.ExecuteTransaction(ctx, d, func() error {
    if !o.numIsLoaded {
        panic("a value for Num is required, and there is no default value. Call SetNum() before inserting the record.")
    }
    if !o.statusEnumIsLoaded {
        panic("a value for StatusEnum is required, and there is no default value. Call SetStatusEnum() before inserting the record.")
    }
    if !o.nameIsLoaded {
        panic("a value for Name is required, and there is no default value. Call SetName() before inserting the record.")
    }
    insertFields = getProjectInsertFields(o)
    var newPK string
	newPK, err = d.Insert(ctx, "project", "id", insertFields)
    if err != nil {
        return err
    }
	o.id = newPK
	o._originalPK = newPK
    o.idIsLoaded = true



    if o.children.Len() > 0 {
        keys := o.children.Keys()
        for i, k := range keys {
            obj := o.children.Get(k)
            if err = obj.Save(ctx); err != nil {
                return err
            }
            if k != obj.PrimaryKey() {
                o.children.Delete(k)
                o.children.SetAt(i, obj.PrimaryKey(), obj)
            }
            db.Associate(ctx,
                d,
                "related_project_assn",
                "project_id",
                newPK,
                "project_id",
                obj.PrimaryKey(),
            )
        }
    } else if len(o.childrenPks) > 0 {
        for _,k := range o.childrenPks {
            obj, err2 := LoadProject(ctx, k)
            if err2 != nil {
                return err2
            }
            if (obj != nil) {
                db.Associate(ctx,
                    d,
                    "related_project_assn",
                    "project_id",
                    newPK,
                    "project_id",
                    k,
                )
            }
        }
    }
    if o.parents.Len() > 0 {
        keys := o.parents.Keys()
        for i, k := range keys {
            obj := o.parents.Get(k)
            if err = obj.Save(ctx); err != nil {
                return err
            }
            if k != obj.PrimaryKey() {
                o.parents.Delete(k)
                o.parents.SetAt(i, obj.PrimaryKey(), obj)
            }
            db.Associate(ctx,
                d,
                "related_project_assn",
                "project_id",
                newPK,
                "project_id",
                obj.PrimaryKey(),
            )
        }
    } else if len(o.parentsPks) > 0 {
        for _,k := range o.parentsPks {
            obj, err2 := LoadProject(ctx, k)
            if err2 != nil {
                return err2
            }
            if (obj != nil) {
                db.Associate(ctx,
                    d,
                    "related_project_assn",
                    "project_id",
                    newPK,
                    "project_id",
                    k,
                )
            }
        }
    }
    if o.teamMembers.Len() > 0 {
        keys := o.teamMembers.Keys()
        for i, k := range keys {
            obj := o.teamMembers.Get(k)
            if err = obj.Save(ctx); err != nil {
                return err
            }
            if k != obj.PrimaryKey() {
                o.teamMembers.Delete(k)
                o.teamMembers.SetAt(i, obj.PrimaryKey(), obj)
            }
            db.Associate(ctx,
                d,
                "team_member_project_assn",
                "project_id",
                newPK,
                "person_id",
                obj.PrimaryKey(),
            )
        }
    } else if len(o.teamMembersPks) > 0 {
        for _,k := range o.teamMembersPks {
            obj, err2 := LoadPerson(ctx, k)
            if err2 != nil {
                return err2
            }
            if (obj != nil) {
                db.Associate(ctx,
                    d,
                    "team_member_project_assn",
                    "project_id",
                    newPK,
                    "person_id",
                    k,
                )
            }
        }
    }

        return nil

    }) // transaction

    if err != nil {
        return
    }

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "project", o.PrimaryKey())
	return
}



// getUpdateFields returns the database columns that will be sent to the update process.
// This will include timestamp fields only if some other column has changed.
func (o *projectBase) getUpdateFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
        fields["id"] = o.id
	}
	if o.numIsDirty {
        fields["num"] = o.num
	}
	if o.statusEnumIsDirty {
        fields["status_enum"] = o.statusEnum
	}
	if o.managerIdIsDirty {
        if 	o.managerIdIsNull {
            fields["manager_id"] = nil
        } else {
  		    fields["manager_id"] = o.managerId
        }
	}
	if o.nameIsDirty {
        fields["name"] = o.name
	}
	if o.descriptionIsDirty {
        if 	o.descriptionIsNull {
            fields["description"] = nil
        } else {
  		    fields["description"] = o.description
        }
	}
	if o.startDateIsDirty {
        if 	o.startDateIsNull {
            fields["start_date"] = nil
        } else {
  		    fields["start_date"] = o.startDate
        }
	}
	if o.endDateIsDirty {
        if 	o.endDateIsNull {
            fields["end_date"] = nil
        } else {
  		    fields["end_date"] = o.endDate
        }
	}
	if o.budgetIsDirty {
        if 	o.budgetIsNull {
            fields["budget"] = nil
        } else {
  		    fields["budget"] = o.budget
        }
	}
	if o.spentIsDirty {
        if 	o.spentIsNull {
            fields["spent"] = nil
        } else {
  		    fields["spent"] = o.spent
        }
	}
	if o.parentProjectIdIsDirty {
        if 	o.parentProjectIdIsNull {
            fields["parent_project_id"] = nil
        } else {
  		    fields["parent_project_id"] = o.parentProjectId
        }
	}
	return
}

// getInsertFields returns the fields that will be specified in an insert operation.
// Optional fields that have not been set and have no default will be returned as nil.
// NoSql databases should interpret this as no value. Sql databases should interpret this as
// explicitly setting a NULL value, which would override any database specific default value.
// Auto-generated fields will be returned with their generated values, except AutoPK fields, which are generated by the
// database driver and updated after the insert.
func (o *projectBase) getInsertFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
    if o.idIsDirty {
        fields["id"] = o.id
    }
 
    fields["num"] = o.num
 
    fields["status_enum"] = o.statusEnum
    if o.managerIdIsNull {
        fields["manager_id"] = nil
    } else {
        fields["manager_id"] = o.managerId
    }
 
    fields["name"] = o.name
    if o.descriptionIsNull {
        fields["description"] = nil
    } else {
        fields["description"] = o.description
    }
    if o.startDateIsNull {
        fields["start_date"] = nil
    } else {
        fields["start_date"] = o.startDate
    }
    if o.endDateIsNull {
        fields["end_date"] = nil
    } else {
        fields["end_date"] = o.endDate
    }
    if o.budgetIsNull {
        fields["budget"] = nil
    } else {
        fields["budget"] = o.budget
    }
    if o.spentIsNull {
        fields["spent"] = nil
    } else {
        fields["spent"] = o.spent
    }
    if o.parentProjectIdIsNull {
        fields["parent_project_id"] = nil
    } else {
        fields["parent_project_id"] = o.parentProjectId
    }
	return
}


// Delete deletes the record from the database.
func (o *projectBase) Delete(ctx context.Context) (err error) {
    if o == nil {
        return // allow deleting of a nil object to be a noop
    }
	if !o._restored {
		panic ("Cannot delete a record that has no primary key value.")
	}
	d := Database()

    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, 30 * time.Second)
    defer cancel()

    err = db.ExecuteTransaction(ctx, d, func() error {
	

    
        if err := db.AssociateOnly(ctx,
            d,
            "related_project_assn",
            "project_id",
            o.PrimaryKey(),
            "id",
            []Project(nil)); err != nil {
                return err
            }

    
        if err := db.AssociateOnly(ctx,
            d,
            "related_project_assn",
            "project_id",
            o.PrimaryKey(),
            "id",
            []Project(nil)); err != nil {
                return err
            }

    
        if err := db.AssociateOnly(ctx,
            d,
            "team_member_project_assn",
            "project_id",
            o.PrimaryKey(),
            "id",
            []Person(nil)); err != nil {
                return err
            }

    
	    return d.Delete(ctx, "project", "id", o.id, "", 0)
	})

	if err != nil {
	    return err
	}
	broadcast.Delete(ctx, "goradd", "project", fmt.Sprint(o.id))
	return
}

// deleteProject deletes the Project with primary key pk from the database
// and handles associated records.
func deleteProject(ctx context.Context, pk string) error {
	d := db.GetDatabase("goradd")

    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, 30 * time.Second)
    defer cancel()

    err := db.ExecuteTransaction(ctx, d, func() error {
        if obj, err := LoadProject(ctx,
                pk,
                node.Project().PrimaryKey(),
                ); err != nil {
            return err
        } else if obj == nil {
            return db.NewRecordNotFoundError("project", pk)
        } else {
            if err := obj.Delete(ctx); err != nil {
                return err
            }
        }
        return nil
    })
    return err
}
// resetDirtyStatus resets the dirty status of every field in the object.
func (o *projectBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.numIsDirty = false
	o.statusEnumIsDirty = false
	o.managerIdIsDirty = false
	o.nameIsDirty = false
	o.descriptionIsDirty = false
	o.startDateIsDirty = false
	o.endDateIsDirty = false
	o.budgetIsDirty = false
	o.spentIsDirty = false
	o.parentProjectIdIsDirty = false
	o.childrenIsDirty = false
	o.childrenPks = nil
	o.parentsIsDirty = false
	o.parentsPks = nil
	o.teamMembersIsDirty = false
	o.teamMembersPks = nil

}

// IsDirty returns true if the object has been changed since it was read from the database or created.
func (o *projectBase) IsDirty() (dirty bool) {
    dirty = o.idIsDirty ||
o.numIsDirty ||
o.statusEnumIsDirty ||
o.managerIdIsDirty ||
o.nameIsDirty ||
o.descriptionIsDirty ||
o.startDateIsDirty ||
o.endDateIsDirty ||
o.budgetIsDirty ||
o.spentIsDirty ||
o.parentProjectIdIsDirty



	dirty = dirty ||
	    o.childrenIsDirty|| 
o.parentsIsDirty|| 
o.teamMembersIsDirty

    

    for obj := range o.children.ValuesIter() {
        dirty = dirty || obj.IsDirty()
    }
    

    for obj := range o.parents.ValuesIter() {
        dirty = dirty || obj.IsDirty()
    }
    

    for obj := range o.teamMembers.ValuesIter() {
        dirty = dirty || obj.IsDirty()
    }
    

    return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil.
// Get can be used to retrieve a value by using the Identifier of a node.
func (o *projectBase) Get(key string) interface{} {
    switch key {
    case "id":
        if !o.idIsLoaded {
            return nil
        }
        return o.id
    case "num":
        if !o.numIsLoaded {
            return nil
        }
        return o.num
    case "statusEnum":
        if !o.statusEnumIsLoaded {
            return nil
        }
        return o.statusEnum
    case "managerId":
        if !o.managerIdIsLoaded {
            return nil
        }
        return o.managerId
    case "name":
        if !o.nameIsLoaded {
            return nil
        }
        return o.name
    case "description":
        if !o.descriptionIsLoaded {
            return nil
        }
        return o.description
    case "startDate":
        if !o.startDateIsLoaded {
            return nil
        }
        return o.startDate
    case "endDate":
        if !o.endDateIsLoaded {
            return nil
        }
        return o.endDate
    case "budget":
        if !o.budgetIsLoaded {
            return nil
        }
        return o.budget
    case "spent":
        if !o.spentIsLoaded {
            return nil
        }
        return o.spent
    case "parentProjectId":
        if !o.parentProjectIdIsLoaded {
            return nil
        }
        return o.parentProjectId
    case "children":
        return o.children.Values()
    case "parents":
        return o.parents.Values()
    case "teamMembers":
        return o.teamMembers.Values()
    }
    return nil
}
// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *projectBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
    enc := gob.NewEncoder(buf)
    if err := o.encodeTo(enc); err != nil {
        return nil, err
    }
	return buf.Bytes(), nil
}

func (o *projectBase) encodeTo(enc db.Encoder) error {

    if err := enc.Encode(o.id); err != nil {
        return fmt.Errorf("error encoding Project.id: %w", err)
    }
    if err := enc.Encode(o.idIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.idIsLoaded: %w", err)
    }
    if err := enc.Encode(o.idIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.idIsDirty: %w", err)
    }


    if err := enc.Encode(o.num); err != nil {
        return fmt.Errorf("error encoding Project.num: %w", err)
    }
    if err := enc.Encode(o.numIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.numIsLoaded: %w", err)
    }
    if err := enc.Encode(o.numIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.numIsDirty: %w", err)
    }


    if err := enc.Encode(o.statusEnum); err != nil {
        return fmt.Errorf("error encoding Project.statusEnum: %w", err)
    }
    if err := enc.Encode(o.statusEnumIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.statusEnumIsLoaded: %w", err)
    }
    if err := enc.Encode(o.statusEnumIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.statusEnumIsDirty: %w", err)
    }


    if err := enc.Encode(o.managerId); err != nil {
        return fmt.Errorf("error encoding Project.managerId: %w", err)
    }
    if err := enc.Encode(o.managerIdIsNull); err != nil {
        return fmt.Errorf("error encoding Project.managerIdIsNull: %w", err)
    }
    if err := enc.Encode(o.managerIdIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.managerIdIsLoaded: %w", err)
    }
    if err := enc.Encode(o.managerIdIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.managerIdIsDirty: %w", err)
    }


    if err := enc.Encode(o.name); err != nil {
        return fmt.Errorf("error encoding Project.name: %w", err)
    }
    if err := enc.Encode(o.nameIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.nameIsLoaded: %w", err)
    }
    if err := enc.Encode(o.nameIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.nameIsDirty: %w", err)
    }


    if err := enc.Encode(o.description); err != nil {
        return fmt.Errorf("error encoding Project.description: %w", err)
    }
    if err := enc.Encode(o.descriptionIsNull); err != nil {
        return fmt.Errorf("error encoding Project.descriptionIsNull: %w", err)
    }
    if err := enc.Encode(o.descriptionIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.descriptionIsLoaded: %w", err)
    }
    if err := enc.Encode(o.descriptionIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.descriptionIsDirty: %w", err)
    }


    if err := enc.Encode(o.startDate); err != nil {
        return fmt.Errorf("error encoding Project.startDate: %w", err)
    }
    if err := enc.Encode(o.startDateIsNull); err != nil {
        return fmt.Errorf("error encoding Project.startDateIsNull: %w", err)
    }
    if err := enc.Encode(o.startDateIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.startDateIsLoaded: %w", err)
    }
    if err := enc.Encode(o.startDateIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.startDateIsDirty: %w", err)
    }


    if err := enc.Encode(o.endDate); err != nil {
        return fmt.Errorf("error encoding Project.endDate: %w", err)
    }
    if err := enc.Encode(o.endDateIsNull); err != nil {
        return fmt.Errorf("error encoding Project.endDateIsNull: %w", err)
    }
    if err := enc.Encode(o.endDateIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.endDateIsLoaded: %w", err)
    }
    if err := enc.Encode(o.endDateIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.endDateIsDirty: %w", err)
    }


    if err := enc.Encode(o.budget); err != nil {
        return fmt.Errorf("error encoding Project.budget: %w", err)
    }
    if err := enc.Encode(o.budgetIsNull); err != nil {
        return fmt.Errorf("error encoding Project.budgetIsNull: %w", err)
    }
    if err := enc.Encode(o.budgetIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.budgetIsLoaded: %w", err)
    }
    if err := enc.Encode(o.budgetIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.budgetIsDirty: %w", err)
    }


    if err := enc.Encode(o.spent); err != nil {
        return fmt.Errorf("error encoding Project.spent: %w", err)
    }
    if err := enc.Encode(o.spentIsNull); err != nil {
        return fmt.Errorf("error encoding Project.spentIsNull: %w", err)
    }
    if err := enc.Encode(o.spentIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.spentIsLoaded: %w", err)
    }
    if err := enc.Encode(o.spentIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.spentIsDirty: %w", err)
    }


    if err := enc.Encode(o.parentProjectId); err != nil {
        return fmt.Errorf("error encoding Project.parentProjectId: %w", err)
    }
    if err := enc.Encode(o.parentProjectIdIsNull); err != nil {
        return fmt.Errorf("error encoding Project.parentProjectIdIsNull: %w", err)
    }
    if err := enc.Encode(o.parentProjectIdIsLoaded); err != nil {
        return fmt.Errorf("error encoding Project.parentProjectIdIsLoaded: %w", err)
    }
    if err := enc.Encode(o.parentProjectIdIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.parentProjectIdIsDirty: %w", err)
    }

    if err := enc.Encode(&o.children); err != nil {
        return fmt.Errorf("error encoding Project.children: %w", err)
    }
    if err := enc.Encode(o.childrenIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.childrenIsDirty: %w", err)
    }
    if err := enc.Encode(o.childrenPks != nil); err != nil {
        return err
    }
    if o.childrenPks != nil {
        if err := enc.Encode(o.childrenPks); err != nil {
            return fmt.Errorf("error encoding Project.childrenPks: %w", err)
        }
    }

    if err := enc.Encode(&o.parents); err != nil {
        return fmt.Errorf("error encoding Project.parents: %w", err)
    }
    if err := enc.Encode(o.parentsIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.parentsIsDirty: %w", err)
    }
    if err := enc.Encode(o.parentsPks != nil); err != nil {
        return err
    }
    if o.parentsPks != nil {
        if err := enc.Encode(o.parentsPks); err != nil {
            return fmt.Errorf("error encoding Project.parentsPks: %w", err)
        }
    }

    if err := enc.Encode(&o.teamMembers); err != nil {
        return fmt.Errorf("error encoding Project.teamMembers: %w", err)
    }
    if err := enc.Encode(o.teamMembersIsDirty); err != nil {
        return fmt.Errorf("error encoding Project.teamMembersIsDirty: %w", err)
    }
    if err := enc.Encode(o.teamMembersPks != nil); err != nil {
        return err
    }
    if o.teamMembersPks != nil {
        if err := enc.Encode(o.teamMembersPks); err != nil {
            return fmt.Errorf("error encoding Project.teamMembersPks: %w", err)
        }
    }


    if o._aliases == nil {
        if err := enc.Encode(false); err != nil {
            return err
        }
    } else {
        if err := enc.Encode(true); err != nil {
            return err
        }
        if err := enc.Encode(o._aliases); err != nil {
            return fmt.Errorf("error encoding Project._aliases: %w", err)
        }
    }

    if err := enc.Encode(o._restored); err != nil {
        return fmt.Errorf("error encoding Project._restored: %w", err)
    }
    if err := enc.Encode(o._originalPK); err != nil {
        return fmt.Errorf("error encoding Project._originalPK: %w", err)
    }
    return nil
}
// UnmarshalBinary converts a structure that was created with MarshalBinary into a Project object.
func (o *projectBase) UnmarshalBinary(data []byte) (err error) {
	buf := bytes.NewReader(data)
	dec := gob.NewDecoder(buf)
	return o.decodeFrom(dec)
}

func (o *projectBase) decodeFrom(dec db.Decoder) (err error) {
	var isPtr bool

	_ = isPtr
    if err = dec.Decode(&o.id); err != nil {
        return fmt.Errorf("error decoding Project.id: %w", err)
    }
    if err = dec.Decode(&o.idIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.idIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.idIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.idIsDirty: %w", err)
    }

    if err = dec.Decode(&o.num); err != nil {
        return fmt.Errorf("error decoding Project.num: %w", err)
    }
    if err = dec.Decode(&o.numIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.numIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.numIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.numIsDirty: %w", err)
    }

    if err = dec.Decode(&o.statusEnum); err != nil {
        return fmt.Errorf("error decoding Project.statusEnum: %w", err)
    }
    if err = dec.Decode(&o.statusEnumIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.statusEnumIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.statusEnumIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.statusEnumIsDirty: %w", err)
    }

    if err = dec.Decode(&o.managerId); err != nil {
        return fmt.Errorf("error decoding Project.managerId: %w", err)
    }
    if err = dec.Decode(&o.managerIdIsNull); err != nil {
        return fmt.Errorf("error decoding Project.managerIdIsNull: %w", err)
    }
    if err = dec.Decode(&o.managerIdIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.managerIdIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.managerIdIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.managerIdIsDirty: %w", err)
    }

    if err = dec.Decode(&o.name); err != nil {
        return fmt.Errorf("error decoding Project.name: %w", err)
    }
    if err = dec.Decode(&o.nameIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.nameIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.nameIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.nameIsDirty: %w", err)
    }

    if err = dec.Decode(&o.description); err != nil {
        return fmt.Errorf("error decoding Project.description: %w", err)
    }
    if err = dec.Decode(&o.descriptionIsNull); err != nil {
        return fmt.Errorf("error decoding Project.descriptionIsNull: %w", err)
    }
    if err = dec.Decode(&o.descriptionIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.descriptionIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.descriptionIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.descriptionIsDirty: %w", err)
    }

    if err = dec.Decode(&o.startDate); err != nil {
        return fmt.Errorf("error decoding Project.startDate: %w", err)
    }
    if err = dec.Decode(&o.startDateIsNull); err != nil {
        return fmt.Errorf("error decoding Project.startDateIsNull: %w", err)
    }
    if err = dec.Decode(&o.startDateIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.startDateIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.startDateIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.startDateIsDirty: %w", err)
    }

    if err = dec.Decode(&o.endDate); err != nil {
        return fmt.Errorf("error decoding Project.endDate: %w", err)
    }
    if err = dec.Decode(&o.endDateIsNull); err != nil {
        return fmt.Errorf("error decoding Project.endDateIsNull: %w", err)
    }
    if err = dec.Decode(&o.endDateIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.endDateIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.endDateIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.endDateIsDirty: %w", err)
    }

    if err = dec.Decode(&o.budget); err != nil {
        return fmt.Errorf("error decoding Project.budget: %w", err)
    }
    if err = dec.Decode(&o.budgetIsNull); err != nil {
        return fmt.Errorf("error decoding Project.budgetIsNull: %w", err)
    }
    if err = dec.Decode(&o.budgetIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.budgetIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.budgetIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.budgetIsDirty: %w", err)
    }

    if err = dec.Decode(&o.spent); err != nil {
        return fmt.Errorf("error decoding Project.spent: %w", err)
    }
    if err = dec.Decode(&o.spentIsNull); err != nil {
        return fmt.Errorf("error decoding Project.spentIsNull: %w", err)
    }
    if err = dec.Decode(&o.spentIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.spentIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.spentIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.spentIsDirty: %w", err)
    }

    if err = dec.Decode(&o.parentProjectId); err != nil {
        return fmt.Errorf("error decoding Project.parentProjectId: %w", err)
    }
    if err = dec.Decode(&o.parentProjectIdIsNull); err != nil {
        return fmt.Errorf("error decoding Project.parentProjectIdIsNull: %w", err)
    }
    if err = dec.Decode(&o.parentProjectIdIsLoaded); err != nil {
        return fmt.Errorf("error decoding Project.parentProjectIdIsLoaded: %w", err)
    }
    if err = dec.Decode(&o.parentProjectIdIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.parentProjectIdIsDirty: %w", err)
    }


    if err = dec.Decode(&o.children); err != nil {
        return fmt.Errorf("error decoding Project.childrenPks: %w", err)
    }
    if err = dec.Decode(&o.childrenIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.childrenIsDirty: %w", err)
    }
    if err = dec.Decode(&isPtr); err != nil {
        return fmt.Errorf("error decoding Project.childrenPks isPtr: %w", err)
    }
    if isPtr {
        if err = dec.Decode(&o.childrenPks); err != nil {
            return fmt.Errorf("error decoding Project.childrenPks: %w", err)
        }
    }

    if err = dec.Decode(&o.parents); err != nil {
        return fmt.Errorf("error decoding Project.parentsPks: %w", err)
    }
    if err = dec.Decode(&o.parentsIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.parentsIsDirty: %w", err)
    }
    if err = dec.Decode(&isPtr); err != nil {
        return fmt.Errorf("error decoding Project.parentsPks isPtr: %w", err)
    }
    if isPtr {
        if err = dec.Decode(&o.parentsPks); err != nil {
            return fmt.Errorf("error decoding Project.parentsPks: %w", err)
        }
    }

    if err = dec.Decode(&o.teamMembers); err != nil {
        return fmt.Errorf("error decoding Project.teamMembersPks: %w", err)
    }
    if err = dec.Decode(&o.teamMembersIsDirty); err != nil {
        return fmt.Errorf("error decoding Project.teamMembersIsDirty: %w", err)
    }
    if err = dec.Decode(&isPtr); err != nil {
        return fmt.Errorf("error decoding Project.teamMembersPks isPtr: %w", err)
    }
    if isPtr {
        if err = dec.Decode(&o.teamMembersPks); err != nil {
            return fmt.Errorf("error decoding Project.teamMembersPks: %w", err)
        }
    }
    if err = dec.Decode(&isPtr); err != nil {
        return fmt.Errorf("error decoding Project._aliases isPtr: %w", err)
    }
    if isPtr {
        if err = dec.Decode(&o._aliases); err != nil {
            return fmt.Errorf("error decoding Project._aliases: %w", err)
        }
    }

    if err = dec.Decode(&o._restored); err != nil {
        return fmt.Errorf("error decoding Project._restored: %w", err)
    }
    if err = dec.Decode(&o._originalPK); err != nil {
        return fmt.Errorf("error decoding Project._originalPK: %w", err)
    }
	return
}
// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *projectBase) MarshalJSON() (data []byte, err error) {
    v := o.MarshalStringMap()
    return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *projectBase) MarshalStringMap() (map[string]interface{}) {
    v := make(map[string]interface{})

    if o.idIsLoaded {
        v["id"] = o.id
    }


    if o.numIsLoaded {
        v["num"] = o.num
    }


    if o.statusEnumIsLoaded {
        v["statusEnum"] = o.statusEnum
    }


    if o.managerIdIsLoaded {
        if o.managerIdIsNull {
            v["managerId"] = nil
        } else {
            v["managerId"] = o.managerId
        }
    }


    if o.nameIsLoaded {
        v["name"] = o.name
    }


    if o.descriptionIsLoaded {
        if o.descriptionIsNull {
            v["description"] = nil
        } else {
            v["description"] = o.description
        }
    }


    if o.startDateIsLoaded {
        if o.startDateIsNull {
            v["startDate"] = nil
        } else {
            v["startDate"] = o.startDate
        }
    }


    if o.endDateIsLoaded {
        if o.endDateIsNull {
            v["endDate"] = nil
        } else {
            v["endDate"] = o.endDate
        }
    }


    if o.budgetIsLoaded {
        if o.budgetIsNull {
            v["budget"] = nil
        } else {
            v["budget"] = o.budget
        }
    }


    if o.spentIsLoaded {
        if o.spentIsNull {
            v["spent"] = nil
        } else {
            v["spent"] = o.spent
        }
    }


    if o.parentProjectIdIsLoaded {
        if o.parentProjectIdIsNull {
            v["parentProjectId"] = nil
        } else {
            v["parentProjectId"] = o.parentProjectId
        }
    }

    if o.children.Len() != 0 {
        var vals []map[string]interface{}
        for obj := range o.children.ValuesIter() {
            vals = append(vals, obj.MarshalStringMap())
        }
        v["children"] = vals
    }
    if o.parents.Len() != 0 {
        var vals []map[string]interface{}
        for obj := range o.parents.ValuesIter() {
            vals = append(vals, obj.MarshalStringMap())
        }
        v["parents"] = vals
    }
    if o.teamMembers.Len() != 0 {
        var vals []map[string]interface{}
        for obj := range o.teamMembers.ValuesIter() {
            vals = append(vals, obj.MarshalStringMap())
        }
        v["teamMembers"] = vals
    }
    for _k,_v := range o._aliases {
        v[_k] = _v
    }
    return v
}


// UnmarshalJSON unmarshalls the given json data into the Project. The Project can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//   "id" - string
//   "num" - int
//   "statusEnum" - ProjectStatus
//   "managerId" - []byte, nullable
//   "name" - string
//   "description" - string, nullable
//   "startDate" - time.Time, nullable
//   "endDate" - time.Time, nullable
//   "budget" - string, nullable
//   "spent" - string, nullable
//   "parentProjectId" - []byte, nullable
func (o *projectBase) UnmarshalJSON (data []byte) (err error) {
	var v map[string]interface{}
	if len(data) == 0 {
		return
	}
	d := json.NewDecoder(bytes.NewReader(data))
	d.UseNumber() // use a number to avoid precision errors
	if err = d.Decode(&v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in Project to modify the json before sending it here.
func (o *projectBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
    for k,v := range m {
        switch k {

        case "id":
        {
            if v == nil {
                return fmt.Errorf("field %s cannot be null", k)
            }


            if s,ok := v.(string); !ok {
                return fmt.Errorf("json field %s must be a string", k)
            } else {
                o.SetId(s)
            }
            }
        case "num":
        {
            if v == nil {
                return fmt.Errorf("field %s cannot be null", k)
            }


            switch n := v.(type) {
            case json.Number:
                n2,err := n.Int64()
                if err != nil {return err}
                o.SetNum(int(n2))
            case int:
                o.SetNum(n)
            case float64:
                o.SetNum(int(n))
            default:
                return fmt.Errorf("field %s must be a number", k)
            }
            }
        case "statusEnum":
        {
            if v == nil {
                return fmt.Errorf("field %s cannot be null", k)
            }


            v2, err := ProjectStatusFromInterface(v)
            if err != nil {return err}
            o.SetStatusEnum(v2)
            }
        case "managerId":
        {
            if v == nil {
                o.SetManagerIdToNull()
                continue
            }


            switch d := v.(type) {
            case string:
            {
                // A base 64 encoded string
                if b,err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
                    o.SetManagerId(b)
                } else {
                    return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
                }
            }
            case []interface{}:
            {
                // An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
                b := make([]byte, len(d), len(d))
                for i,b1 := range d {
                    if f,ok := b1.(float64); !ok {
                        return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
                    } else {
                        b[i] = uint8(f)
                    }
                }
                o.SetManagerId(b)
            }
            default:
                return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
            }

            }
        case "name":
        {
            if v == nil {
                return fmt.Errorf("field %s cannot be null", k)
            }


            if s,ok := v.(string); !ok {
                return fmt.Errorf("json field %s must be a string", k)
            } else {
                o.SetName(s)
            }
            }
        case "description":
        {
            if v == nil {
                o.SetDescriptionToNull()
                continue
            }


            if s,ok := v.(string); !ok {
                return fmt.Errorf("json field %s must be a string", k)
            } else {
                o.SetDescription(s)
            }
            }
        case "startDate":
        {
            if v == nil {
                o.SetStartDateToNull()
                continue
            }


             switch d := v.(type) {
             case json.Number:
                // a numeric value, which for JSON, means milliseconds since epoc
                 n2,err := d.Int64()
                 if err != nil {return err}
                 o.SetStartDate(time.UnixMilli(n2).UTC())
             case float64:
                 // a numeric value, which for JSON, means milliseconds since epoc
                 o.SetStartDate(time.UnixMilli(int64(d)).UTC())
             case string:
                 // an ISO8601 string (hopefully)
                 var t time.Time
                 err = t.UnmarshalJSON([]byte(`"` + d + `"`))
                 if err != nil {
                     return fmt.Errorf("JSON format error for time field %s: %w", k, err)
                 }
                 t = t.UTC()
                 o.SetStartDate(t)
             default:
                 return fmt.Errorf("json field %s must be a number or a string", k)
             }
            }
        case "endDate":
        {
            if v == nil {
                o.SetEndDateToNull()
                continue
            }


             switch d := v.(type) {
             case json.Number:
                // a numeric value, which for JSON, means milliseconds since epoc
                 n2,err := d.Int64()
                 if err != nil {return err}
                 o.SetEndDate(time.UnixMilli(n2).UTC())
             case float64:
                 // a numeric value, which for JSON, means milliseconds since epoc
                 o.SetEndDate(time.UnixMilli(int64(d)).UTC())
             case string:
                 // an ISO8601 string (hopefully)
                 var t time.Time
                 err = t.UnmarshalJSON([]byte(`"` + d + `"`))
                 if err != nil {
                     return fmt.Errorf("JSON format error for time field %s: %w", k, err)
                 }
                 t = t.UTC()
                 o.SetEndDate(t)
             default:
                 return fmt.Errorf("json field %s must be a number or a string", k)
             }
            }
        case "budget":
        {
            if v == nil {
                o.SetBudgetToNull()
                continue
            }


            if s,ok := v.(string); !ok {
                return fmt.Errorf("json field %s must be a string", k)
            } else {
                o.SetBudget(s)
            }
            }
        case "spent":
        {
            if v == nil {
                o.SetSpentToNull()
                continue
            }


            if s,ok := v.(string); !ok {
                return fmt.Errorf("json field %s must be a string", k)
            } else {
                o.SetSpent(s)
            }
            }
        case "parentProjectId":
        {
            if v == nil {
                o.SetParentProjectIdToNull()
                continue
            }


            switch d := v.(type) {
            case string:
            {
                // A base 64 encoded string
                if b,err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
                    o.SetParentProjectId(b)
                } else {
                    return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
                }
            }
            case []interface{}:
            {
                // An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
                b := make([]byte, len(d), len(d))
                for i,b1 := range d {
                    if f,ok := b1.(float64); !ok {
                        return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
                    } else {
                        b[i] = uint8(f)
                    }
                }
                o.SetParentProjectId(b)
            }
            default:
                return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
            }

            }

        case "children":
            v2,ok := v.([]any)
            if !ok {
                return fmt.Errorf("json field %s must be an array of maps", k)
            }
            var s []*Project
            for _,i2 := range v2 {
                m2,ok := i2.(map[string]any)
                if !ok {
                    return fmt.Errorf("json field %s must be an array of maps", k)
                }
                v3 := NewProject()
                err = v3.UnmarshalStringMap(m2)
                if err != nil {return}
                s = append(s, v3)
            }
            o.SetChildren(s...)


        case "parents":
            v2,ok := v.([]any)
            if !ok {
                return fmt.Errorf("json field %s must be an array of maps", k)
            }
            var s []*Project
            for _,i2 := range v2 {
                m2,ok := i2.(map[string]any)
                if !ok {
                    return fmt.Errorf("json field %s must be an array of maps", k)
                }
                v3 := NewProject()
                err = v3.UnmarshalStringMap(m2)
                if err != nil {return}
                s = append(s, v3)
            }
            o.SetParents(s...)


        case "teamMembers":
            v2,ok := v.([]any)
            if !ok {
                return fmt.Errorf("json field %s must be an array of maps", k)
            }
            var s []*Person
            for _,i2 := range v2 {
                m2,ok := i2.(map[string]any)
                if !ok {
                    return fmt.Errorf("json field %s must be an array of maps", k)
                }
                v3 := NewPerson()
                err = v3.UnmarshalStringMap(m2)
                if err != nil {return}
                s = append(s, v3)
            }
            o.SetTeamMembers(s...)

        }
    }
    return
}

