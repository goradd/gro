// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"slices"
	"time"
	"unicode/utf8"

	"github.com/goradd/all"
	"github.com/goradd/maps"
	"github.com/goradd/orm/_test/gen/orm/goradd/node"
	"github.com/goradd/orm/pkg/broadcast"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/query"
)

// ProjectBase is embedded in a Project object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the Project embedder.
// Instead, use the accessor functions.
type projectBase struct {
	id        string
	idIsValid bool

	num        int
	numIsValid bool
	numIsDirty bool

	status        ProjectStatus
	statusIsValid bool
	statusIsDirty bool

	managerID        string
	managerIDIsNull  bool
	managerIDIsValid bool
	managerIDIsDirty bool
	objManager       *Person

	name        string
	nameIsValid bool
	nameIsDirty bool

	description        string
	descriptionIsNull  bool
	descriptionIsValid bool
	descriptionIsDirty bool

	startDate        time.Time
	startDateIsNull  bool
	startDateIsValid bool
	startDateIsDirty bool

	endDate        time.Time
	endDateIsNull  bool
	endDateIsValid bool
	endDateIsDirty bool

	budget        []byte
	budgetIsNull  bool
	budgetIsValid bool
	budgetIsDirty bool

	spent        []byte
	spentIsNull  bool
	spentIsValid bool
	spentIsDirty bool

	parentProjectID        string
	parentProjectIDIsNull  bool
	parentProjectIDIsValid bool
	parentProjectIDIsDirty bool
	objParentProject       *Project

	// Reverse reference objects.

	revMilestones        maps.SliceMap[string, *Milestone] // Objects in the order they were queried
	revMilestonesIsDirty bool

	revParentProjectProjects        maps.SliceMap[string, *Project] // Objects in the order they were queried
	revParentProjectProjectsIsDirty bool

	// Many-Many reference objects.
	mmChildren           maps.SliceMap[string, *Project]
	mmChildrenPks        []string // Primary keys to associate at Save time
	mmChildrenIsDirty    bool
	mmParents            maps.SliceMap[string, *Project]
	mmParentsPks         []string // Primary keys to associate at Save time
	mmParentsIsDirty     bool
	mmTeamMembers        maps.SliceMap[string, *Person]
	mmTeamMembersPks     []string // Primary keys to associate at Save time
	mmTeamMembersIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

	_originalPK string
}

// IDs used to access the Project object fields by name using the Get function.
// doc: type=Project
const (
	Project_ID              = `ID`
	Project_Num             = `Num`
	Project_Status          = `Status`
	Project_ManagerID       = `ManagerID`
	Project_Manager         = `Manager`
	Project_Name            = `Name`
	Project_Description     = `Description`
	Project_StartDate       = `StartDate`
	Project_EndDate         = `EndDate`
	Project_Budget          = `Budget`
	Project_Spent           = `Spent`
	Project_ParentProjectID = `ParentProjectID`
	Project_ParentProject   = `ParentProject`

	ProjectMilestones            = `Milestones`
	ProjectParentProjectProjects = `ParentProjectProjects`

	ProjectChild       = `Child`
	ProjectChildren    = `Children`
	ProjectParent      = `Parent`
	ProjectParents     = `Parents`
	ProjectTeamMember  = `TeamMember`
	ProjectTeamMembers = `TeamMembers`
)

const ProjectNumMax = 2147483647
const ProjectNumMin = -2147483648
const ProjectStatusMax = 2147483647
const ProjectStatusMin = -2147483648
const ProjectNameMaxLength = 100          // The number of runes the column can hold
const ProjectDescriptionMaxLength = 65535 // The number of runes the column can hold
const ProjectBudgetMaxLength = 15         // The number of bytes the column can hold
const ProjectSpentMaxLength = 15          // The number of bytes the column can hold

// Initialize or re-initialize a Project database object to default values.
// The primary key will get a temporary negative number which will be replaced when the object is saved.
// Multiple calls to Initialize are not guaranteed to create sequential values for the primary key.
func (o *projectBase) Initialize() {

	o.id = db.TemporaryPrimaryKey()

	o.idIsValid = false

	o.num = 0

	o.numIsValid = false
	o.numIsDirty = false

	o.status = 0

	o.statusIsValid = false
	o.statusIsDirty = false

	o.managerID = ""

	o.managerIDIsNull = true
	o.managerIDIsValid = true
	o.managerIDIsDirty = true

	o.name = ""

	o.nameIsValid = false
	o.nameIsDirty = false

	o.description = ""

	o.descriptionIsNull = true
	o.descriptionIsValid = true
	o.descriptionIsDirty = true

	o.startDate = time.Time{}

	o.startDateIsNull = true
	o.startDateIsValid = true
	o.startDateIsDirty = true

	o.endDate = time.Time{}

	o.endDateIsNull = true
	o.endDateIsValid = true
	o.endDateIsDirty = true

	o.budget = []byte{}

	o.budgetIsNull = true
	o.budgetIsValid = true
	o.budgetIsDirty = true

	o.spent = []byte{}

	o.spentIsNull = true
	o.spentIsValid = true
	o.spentIsDirty = true

	o.parentProjectID = ""

	o.parentProjectIDIsNull = true
	o.parentProjectIDIsValid = true
	o.parentProjectIDIsDirty = true

	// Reverse reference objects.

	o.revMilestones.Clear()
	o.revMilestonesIsDirty = false

	o.revParentProjectProjects.Clear()
	o.revParentProjectProjectsIsDirty = false

	// Many-Many reference objects.
	o.mmChildren.Clear()
	o.mmChildrenPks = nil
	o.mmChildrenIsDirty = false
	o.mmParents.Clear()
	o.mmParentsPks = nil
	o.mmParentsIsDirty = false
	o.mmTeamMembers.Clear()
	o.mmTeamMembersPks = nil
	o.mmTeamMembersIsDirty = false

	o._aliases = nil

	o._restored = false
}

// PrimaryKey returns the current value of the primary key field.
func (o *projectBase) PrimaryKey() string {
	return o.id
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *projectBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// Copy copies all valid fields to a new Project object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *projectBase) Copy() (newObject *Project) {
	newObject = NewProject()
	if o.numIsValid {
		newObject.SetNum(o.num)
	}
	if o.statusIsValid {
		newObject.SetStatus(o.status)
	}
	if o.managerIDIsValid {
		newObject.SetManagerID(o.managerID)
	}
	if o.nameIsValid {
		newObject.SetName(o.name)
	}
	if o.descriptionIsValid {
		newObject.SetDescription(o.description)
	}
	if o.startDateIsValid {
		newObject.SetStartDate(o.startDate)
	}
	if o.endDateIsValid {
		newObject.SetEndDate(o.endDate)
	}
	if o.budgetIsValid {
		newObject.SetBudget(o.budget)
	}
	if o.spentIsValid {
		newObject.SetSpent(o.spent)
	}
	if o.parentProjectIDIsValid {
		newObject.SetParentProjectID(o.parentProjectID)
	}
	return
}

// ID returns the loaded value of ID or
// the zero value if not loaded. Call IDIsValid() to determine
// if it is loaded.
func (o *projectBase) ID() string {
	return fmt.Sprint(o.id)
}

// IDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) IDIsValid() bool {
	return o._restored && o.idIsValid
}

// Num returns the loaded value of Num.
func (o *projectBase) Num() int {
	if o._restored && !o.numIsValid {
		panic("Num was not selected in the last query and has not been set, and so is not valid")
	}
	return o.num
}

// NumIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NumIsValid() bool {
	return o.numIsValid
}

// SetNum sets the value of Num in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetNum(v int) {
	if o._restored &&
		o.numIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.num == v {
		// no change
		return
	}

	o.numIsValid = true
	o.num = v
	o.numIsDirty = true
}

// Status returns the loaded value of Status.
func (o *projectBase) Status() ProjectStatus {
	if o._restored && !o.statusIsValid {
		panic("Status was not selected in the last query and has not been set, and so is not valid")
	}
	return o.status
}

// StatusIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) StatusIsValid() bool {
	return o.statusIsValid
}

// SetStatus sets the value of Status in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetStatus(v ProjectStatus) {
	if o._restored &&
		o.statusIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.status == v {
		// no change
		return
	}

	o.statusIsValid = true
	o.status = v
	o.statusIsDirty = true
}

// ManagerID returns the loaded value of ManagerID.
func (o *projectBase) ManagerID() string {
	if o._restored && !o.managerIDIsValid {
		panic("ManagerID was not selected in the last query and has not been set, and so is not valid")
	}
	return o.managerID
}

// ManagerIDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) ManagerIDIsValid() bool {
	return o.managerIDIsValid
}

// ManagerIDIsNull returns true if the related database value is null.
func (o *projectBase) ManagerIDIsNull() bool {
	return o.managerIDIsNull
}

// ManagerID_I returns the loaded value of ManagerID as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) ManagerID_I() interface{} {
	if o._restored && !o.managerIDIsValid {
		panic("managerID was not selected in the last query and has not been set, and so is not valid")
	} else if o.managerIDIsNull {
		return nil
	}
	return o.managerID
}

// SetManagerID sets the value of ManagerID in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetManagerID(v string) {
	if o._restored &&
		o.managerIDIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.managerIDIsNull && // if the db value is null, force a set of value
		o.managerID == v {
		// no change
		return
	}

	o.managerIDIsValid = true
	o.managerID = v
	o.managerIDIsDirty = true
	o.managerIDIsNull = false
	o.objManager = nil
}

// SetManagerIDToNull() will set the manager_id value in the database to NULL.
// ManagerID() will return the column's default value after this.
func (o *projectBase) SetManagerIDToNull() {
	if !o.managerIDIsValid || !o.managerIDIsNull {
		// If we know it is null in the database, don't save it
		o.managerIDIsDirty = true
	}
	o.managerIDIsValid = true
	o.managerIDIsNull = true
	o.managerID = ""
	o.objManager = nil
}

// Manager returns the current value of the loaded Manager, and nil if its not loaded.
func (o *projectBase) Manager() *Person {
	return o.objManager
}

// LoadManager returns the related Manager. If it is not already loaded,
// it will attempt to load it, provided the ManagerID column has been loaded first.
func (o *projectBase) LoadManager(ctx context.Context) *Person {
	if !o.managerIDIsValid {
		return nil
	}

	if o.objManager == nil {
		// Load and cache
		o.objManager = LoadPerson(ctx, o.managerID)
	}
	return o.objManager
}

// SetManager will set the reference to manager. The referenced object
// will be saved when Project is saved. Pass nil to break the connection.
func (o *projectBase) SetManager(objManager *Person) {
	o.managerIDIsValid = true
	if objManager == nil {
		if !o.managerIDIsNull || !o._restored {
			o.managerIDIsNull = true
			o.managerIDIsDirty = true
			o.managerID = ""
			o.objManager = nil
		}
	} else {
		o.objManager = objManager
		if o.managerIDIsNull || !o._restored || o.managerID != objManager.PrimaryKey() {
			o.managerIDIsNull = false
			o.managerID = objManager.PrimaryKey()
			o.managerIDIsDirty = true
		}
	}
}

// Name returns the loaded value of Name.
func (o *projectBase) Name() string {
	if o._restored && !o.nameIsValid {
		panic("Name was not selected in the last query and has not been set, and so is not valid")
	}
	return o.name
}

// NameIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) NameIsValid() bool {
	return o.nameIsValid
}

// SetName sets the value of Name in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetName(v string) {
	if utf8.RuneCountInString(v) > ProjectNameMaxLength {
		panic("attempted to set Project.Name to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.nameIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.name == v {
		// no change
		return
	}

	o.nameIsValid = true
	o.name = v
	o.nameIsDirty = true
}

// Description returns the loaded value of Description.
func (o *projectBase) Description() string {
	if o._restored && !o.descriptionIsValid {
		panic("Description was not selected in the last query and has not been set, and so is not valid")
	}
	return o.description
}

// DescriptionIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) DescriptionIsValid() bool {
	return o.descriptionIsValid
}

// DescriptionIsNull returns true if the related database value is null.
func (o *projectBase) DescriptionIsNull() bool {
	return o.descriptionIsNull
}

// Description_I returns the loaded value of Description as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Description_I() interface{} {
	if o._restored && !o.descriptionIsValid {
		panic("description was not selected in the last query and has not been set, and so is not valid")
	} else if o.descriptionIsNull {
		return nil
	}
	return o.description
}

// SetDescription sets the value of Description in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetDescription(v string) {
	if utf8.RuneCountInString(v) > ProjectDescriptionMaxLength {
		panic("attempted to set Project.Description to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.descriptionIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.descriptionIsNull && // if the db value is null, force a set of value
		o.description == v {
		// no change
		return
	}

	o.descriptionIsValid = true
	o.description = v
	o.descriptionIsDirty = true
	o.descriptionIsNull = false
}

// SetDescriptionToNull() will set the description value in the database to NULL.
// Description() will return the column's default value after this.
func (o *projectBase) SetDescriptionToNull() {
	if !o.descriptionIsValid || !o.descriptionIsNull {
		// If we know it is null in the database, don't save it
		o.descriptionIsDirty = true
	}
	o.descriptionIsValid = true
	o.descriptionIsNull = true
	o.description = ""
}

// StartDate returns the loaded value of StartDate.
func (o *projectBase) StartDate() time.Time {
	if o._restored && !o.startDateIsValid {
		panic("StartDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.startDate
}

// StartDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) StartDateIsValid() bool {
	return o.startDateIsValid
}

// StartDateIsNull returns true if the related database value is null.
func (o *projectBase) StartDateIsNull() bool {
	return o.startDateIsNull
}

// StartDate_I returns the loaded value of StartDate as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) StartDate_I() interface{} {
	if o._restored && !o.startDateIsValid {
		panic("startDate was not selected in the last query and has not been set, and so is not valid")
	} else if o.startDateIsNull {
		return nil
	}
	return o.startDate
}

// SetStartDate sets the value of StartDate in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *projectBase) SetStartDate(v time.Time) {
	if o._restored &&
		o.startDateIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.startDateIsNull && // if the db value is null, force a set of value
		o.startDate.Equal(v) {
		// no change
		return
	}

	o.startDateIsValid = true
	v = v.UTC()
	v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())
	o.startDate = v
	o.startDateIsDirty = true
	o.startDateIsNull = false
}

// SetStartDateToNull() will set the start_date value in the database to NULL.
// StartDate() will return the column's default value after this.
func (o *projectBase) SetStartDateToNull() {
	if !o.startDateIsValid || !o.startDateIsNull {
		// If we know it is null in the database, don't save it
		o.startDateIsDirty = true
	}
	o.startDateIsValid = true
	o.startDateIsNull = true
	o.startDate = time.Time{}
}

// EndDate returns the loaded value of EndDate.
func (o *projectBase) EndDate() time.Time {
	if o._restored && !o.endDateIsValid {
		panic("EndDate was not selected in the last query and has not been set, and so is not valid")
	}
	return o.endDate
}

// EndDateIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) EndDateIsValid() bool {
	return o.endDateIsValid
}

// EndDateIsNull returns true if the related database value is null.
func (o *projectBase) EndDateIsNull() bool {
	return o.endDateIsNull
}

// EndDate_I returns the loaded value of EndDate as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) EndDate_I() interface{} {
	if o._restored && !o.endDateIsValid {
		panic("endDate was not selected in the last query and has not been set, and so is not valid")
	} else if o.endDateIsNull {
		return nil
	}
	return o.endDate
}

// SetEndDate sets the value of EndDate in the object, to be saved later in the database using the Save() function.
//
// The value v will be converted to UTC time.
// The time will also be zeroed. This may cause the date value to change. To prevent this, be sure that the date given is already in UTC time.
func (o *projectBase) SetEndDate(v time.Time) {
	if o._restored &&
		o.endDateIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.endDateIsNull && // if the db value is null, force a set of value
		o.endDate.Equal(v) {
		// no change
		return
	}

	o.endDateIsValid = true
	v = v.UTC()
	v = time.Date(v.Year(), v.Month(), v.Day(), 0, 0, 0, 0, v.Location())
	o.endDate = v
	o.endDateIsDirty = true
	o.endDateIsNull = false
}

// SetEndDateToNull() will set the end_date value in the database to NULL.
// EndDate() will return the column's default value after this.
func (o *projectBase) SetEndDateToNull() {
	if !o.endDateIsValid || !o.endDateIsNull {
		// If we know it is null in the database, don't save it
		o.endDateIsDirty = true
	}
	o.endDateIsValid = true
	o.endDateIsNull = true
	o.endDate = time.Time{}
}

// Budget returns the loaded value of Budget.
func (o *projectBase) Budget() []byte {
	if o._restored && !o.budgetIsValid {
		panic("Budget was not selected in the last query and has not been set, and so is not valid")
	}
	return o.budget
}

// BudgetIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) BudgetIsValid() bool {
	return o.budgetIsValid
}

// BudgetIsNull returns true if the related database value is null.
func (o *projectBase) BudgetIsNull() bool {
	return o.budgetIsNull
}

// Budget_I returns the loaded value of Budget as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Budget_I() interface{} {
	if o._restored && !o.budgetIsValid {
		panic("budget was not selected in the last query and has not been set, and so is not valid")
	} else if o.budgetIsNull {
		return nil
	}
	return o.budget
}

// SetBudget copies the value of Budget, to be saved later in the database using the Save() function.
// Pass nil to set budget to NULL in the database.
func (o *projectBase) SetBudget(v []byte) {
	if v == nil {
		o.SetBudgetToNull()
		return
	}

	if len(v) > ProjectBudgetMaxLength {
		panic("attempted to set Project.Budget to a value larger than its maximum length")
	}

	if o._restored &&
		o.budgetIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.budgetIsNull && // if the db value is null, force a set of value
		bytes.Equal(o.budget, v) {
		// no change
		return
	}

	o.budgetIsValid = true
	o.budget = slices.Clone(v)
	o.budgetIsNull = false
	o.budgetIsDirty = true
}

// SetBudgetToNull() will set the budget value in the database to NULL.
// Budget() will return the column's default value after this.
func (o *projectBase) SetBudgetToNull() {
	if !o.budgetIsValid || !o.budgetIsNull {
		// If we know it is null in the database, don't save it
		o.budgetIsDirty = true
	}
	o.budgetIsValid = true
	o.budgetIsNull = true
	o.budget = []byte{}
}

// Spent returns the loaded value of Spent.
func (o *projectBase) Spent() []byte {
	if o._restored && !o.spentIsValid {
		panic("Spent was not selected in the last query and has not been set, and so is not valid")
	}
	return o.spent
}

// SpentIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) SpentIsValid() bool {
	return o.spentIsValid
}

// SpentIsNull returns true if the related database value is null.
func (o *projectBase) SpentIsNull() bool {
	return o.spentIsNull
}

// Spent_I returns the loaded value of Spent as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) Spent_I() interface{} {
	if o._restored && !o.spentIsValid {
		panic("spent was not selected in the last query and has not been set, and so is not valid")
	} else if o.spentIsNull {
		return nil
	}
	return o.spent
}

// SetSpent copies the value of Spent, to be saved later in the database using the Save() function.
// Pass nil to set spent to NULL in the database.
func (o *projectBase) SetSpent(v []byte) {
	if v == nil {
		o.SetSpentToNull()
		return
	}

	if len(v) > ProjectSpentMaxLength {
		panic("attempted to set Project.Spent to a value larger than its maximum length")
	}

	if o._restored &&
		o.spentIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.spentIsNull && // if the db value is null, force a set of value
		bytes.Equal(o.spent, v) {
		// no change
		return
	}

	o.spentIsValid = true
	o.spent = slices.Clone(v)
	o.spentIsNull = false
	o.spentIsDirty = true
}

// SetSpentToNull() will set the spent value in the database to NULL.
// Spent() will return the column's default value after this.
func (o *projectBase) SetSpentToNull() {
	if !o.spentIsValid || !o.spentIsNull {
		// If we know it is null in the database, don't save it
		o.spentIsDirty = true
	}
	o.spentIsValid = true
	o.spentIsNull = true
	o.spent = []byte{}
}

// ParentProjectID returns the loaded value of ParentProjectID.
func (o *projectBase) ParentProjectID() string {
	if o._restored && !o.parentProjectIDIsValid {
		panic("ParentProjectID was not selected in the last query and has not been set, and so is not valid")
	}
	return o.parentProjectID
}

// ParentProjectIDIsValid returns true if the value was loaded from the database or has been set.
func (o *projectBase) ParentProjectIDIsValid() bool {
	return o.parentProjectIDIsValid
}

// ParentProjectIDIsNull returns true if the related database value is null.
func (o *projectBase) ParentProjectIDIsNull() bool {
	return o.parentProjectIDIsNull
}

// ParentProjectID_I returns the loaded value of ParentProjectID as an interface.
// If the value in the database is NULL, a nil interface is returned.
func (o *projectBase) ParentProjectID_I() interface{} {
	if o._restored && !o.parentProjectIDIsValid {
		panic("parentProjectID was not selected in the last query and has not been set, and so is not valid")
	} else if o.parentProjectIDIsNull {
		return nil
	}
	return o.parentProjectID
}

// SetParentProjectID sets the value of ParentProjectID in the object, to be saved later in the database using the Save() function.
func (o *projectBase) SetParentProjectID(v string) {
	if o._restored &&
		o.parentProjectIDIsValid && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.parentProjectIDIsNull && // if the db value is null, force a set of value
		o.parentProjectID == v {
		// no change
		return
	}

	o.parentProjectIDIsValid = true
	o.parentProjectID = v
	o.parentProjectIDIsDirty = true
	o.parentProjectIDIsNull = false
	o.objParentProject = nil
}

// SetParentProjectIDToNull() will set the parent_project_id value in the database to NULL.
// ParentProjectID() will return the column's default value after this.
func (o *projectBase) SetParentProjectIDToNull() {
	if !o.parentProjectIDIsValid || !o.parentProjectIDIsNull {
		// If we know it is null in the database, don't save it
		o.parentProjectIDIsDirty = true
	}
	o.parentProjectIDIsValid = true
	o.parentProjectIDIsNull = true
	o.parentProjectID = ""
	o.objParentProject = nil
}

// ParentProject returns the current value of the loaded ParentProject, and nil if its not loaded.
func (o *projectBase) ParentProject() *Project {
	return o.objParentProject
}

// LoadParentProject returns the related ParentProject. If it is not already loaded,
// it will attempt to load it, provided the ParentProjectID column has been loaded first.
func (o *projectBase) LoadParentProject(ctx context.Context) *Project {
	if !o.parentProjectIDIsValid {
		return nil
	}

	if o.objParentProject == nil {
		// Load and cache
		o.objParentProject = LoadProject(ctx, o.parentProjectID)
	}
	return o.objParentProject
}

// SetParentProject will set the reference to parentProject. The referenced object
// will be saved when Project is saved. Pass nil to break the connection.
func (o *projectBase) SetParentProject(objParentProject *Project) {
	o.parentProjectIDIsValid = true
	if objParentProject == nil {
		if !o.parentProjectIDIsNull || !o._restored {
			o.parentProjectIDIsNull = true
			o.parentProjectIDIsDirty = true
			o.parentProjectID = ""
			o.objParentProject = nil
		}
	} else {
		o.objParentProject = objParentProject
		if o.parentProjectIDIsNull || !o._restored || o.parentProjectID != objParentProject.PrimaryKey() {
			o.parentProjectIDIsNull = false
			o.parentProjectID = objParentProject.PrimaryKey()
			o.parentProjectIDIsDirty = true
		}
	}
}

// GetAlias returns the alias for the given key.
func (o *projectBase) GetAlias(key string) query.AliasValue {
	if a, ok := o._aliases[key]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + key + " not found.")
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *projectBase) IsNew() bool {
	return !o._restored
}

// Child returns a single Project object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) Child(pk string) *Project {
	return o.mmChildren.Get(pk)
}

// Children returns a slice of Project objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) Children() []*Project {
	return o.mmChildren.Values()
}

// SetChildren sets the associated objects to the given slice of Project objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetChildren(objs ...*Project) {
	o.mmChildren.Clear()
	o.mmChildrenIsDirty = true
	o.mmChildrenPks = nil
	for _, obj := range objs {
		o.mmChildren.Set(obj.PrimaryKey(), obj)
	}
}

// SetChildrenByID prepares to associate Project objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetChildrenByID(ids ...string) {
	o.mmChildren.Clear()
	o.mmChildrenPks = ids
	o.mmChildrenIsDirty = true
}

// LoadChildren loads the Project objects associated through the Child-Parent relationship.
func (o *projectBase) LoadChildren(ctx context.Context) []*Project {
	if o.mmChildrenIsDirty && o.mmChildrenPks == nil {
		panic("dirty many-many relationships cannot be loaded; call Save() first")
	}

	var objs []*Project

	if o.mmChildrenPks != nil {
		// Load the objects that will be associated after a Save
		objs = QueryProjects(ctx).
			Where(op.In(node.Project().PrimaryKey(), o.mmChildrenPks...)).
			Load()
	} else {
		objs = QueryProjects(ctx).
			Where(op.Equal(node.Project().Parents(), o.PrimaryKey())).
			Load()
	}

	o.mmChildren.Clear()
	for _, obj := range objs {
		o.mmChildren.Set(obj.PrimaryKey(), obj)
	}
	return o.mmChildren.Values()
}

// CountChildren counts the number of associated mmChildren objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountChildren(ctx context.Context) int {
	return QueryProjects(ctx).
		Where(op.Equal(node.Project().Parents(), o.PrimaryKey())).
		Count()

}

// Parent returns a single Project object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) Parent(pk string) *Project {
	return o.mmParents.Get(pk)
}

// Parents returns a slice of Project objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) Parents() []*Project {
	return o.mmParents.Values()
}

// SetParents sets the associated objects to the given slice of Project objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetParents(objs ...*Project) {
	o.mmParents.Clear()
	o.mmParentsIsDirty = true
	o.mmParentsPks = nil
	for _, obj := range objs {
		o.mmParents.Set(obj.PrimaryKey(), obj)
	}
}

// SetParentsByID prepares to associate Project objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetParentsByID(ids ...string) {
	o.mmParents.Clear()
	o.mmParentsPks = ids
	o.mmParentsIsDirty = true
}

// LoadParents loads the Project objects associated through the Parent-Child relationship.
func (o *projectBase) LoadParents(ctx context.Context) []*Project {
	if o.mmParentsIsDirty && o.mmParentsPks == nil {
		panic("dirty many-many relationships cannot be loaded; call Save() first")
	}

	var objs []*Project

	if o.mmParentsPks != nil {
		// Load the objects that will be associated after a Save
		objs = QueryProjects(ctx).
			Where(op.In(node.Project().PrimaryKey(), o.mmParentsPks...)).
			Load()
	} else {
		objs = QueryProjects(ctx).
			Where(op.Equal(node.Project().Children(), o.PrimaryKey())).
			Load()
	}

	o.mmParents.Clear()
	for _, obj := range objs {
		o.mmParents.Set(obj.PrimaryKey(), obj)
	}
	return o.mmParents.Values()
}

// CountParents counts the number of associated mmParents objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountParents(ctx context.Context) int {
	return QueryProjects(ctx).
		Where(op.Equal(node.Project().Children(), o.PrimaryKey())).
		Count()

}

// TeamMember returns a single Person object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *projectBase) TeamMember(pk string) *Person {
	return o.mmTeamMembers.Get(pk)
}

// TeamMembers returns a slice of Person objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *projectBase) TeamMembers() []*Person {
	return o.mmTeamMembers.Values()
}

// SetTeamMembers sets the associated objects to the given slice of Person objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *projectBase) SetTeamMembers(objs ...*Person) {
	o.mmTeamMembers.Clear()
	o.mmTeamMembersIsDirty = true
	o.mmTeamMembersPks = nil
	for _, obj := range objs {
		o.mmTeamMembers.Set(obj.PrimaryKey(), obj)
	}
}

// SetTeamMembersByID prepares to associate Person objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *projectBase) SetTeamMembersByID(ids ...string) {
	o.mmTeamMembers.Clear()
	o.mmTeamMembersPks = ids
	o.mmTeamMembersIsDirty = true
}

// LoadTeamMembers loads the Person objects associated through the TeamMember-Project relationship.
func (o *projectBase) LoadTeamMembers(ctx context.Context) []*Person {
	if o.mmTeamMembersIsDirty && o.mmTeamMembersPks == nil {
		panic("dirty many-many relationships cannot be loaded; call Save() first")
	}

	var objs []*Person

	if o.mmTeamMembersPks != nil {
		// Load the objects that will be associated after a Save
		objs = QueryPeople(ctx).
			Where(op.In(node.Person().PrimaryKey(), o.mmTeamMembersPks...)).
			Load()
	} else {
		objs = QueryPeople(ctx).
			Where(op.Equal(node.Person().Projects(), o.PrimaryKey())).
			Load()
	}

	o.mmTeamMembers.Clear()
	for _, obj := range objs {
		o.mmTeamMembers.Set(obj.PrimaryKey(), obj)
	}
	return o.mmTeamMembers.Values()
}

// CountTeamMembers counts the number of associated mmTeamMembers objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *projectBase) CountTeamMembers(ctx context.Context) int {
	return QueryPeople(ctx).
		Where(op.Equal(node.Person().Projects(), o.PrimaryKey())).
		Count()

}

// Milestone returns a single Milestone object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return Milestone objects that are not saved.
func (o *projectBase) Milestone(pk string) *Milestone {
	v := o.revMilestones.Get(pk)
	return v
}

// Milestones returns a slice of Milestone objects if loaded.
func (o *projectBase) Milestones() []*Milestone {
	return o.revMilestones.Values()
}

// LoadMilestones loads a new slice of Milestone objects and returns it.
func (o *projectBase) LoadMilestones(ctx context.Context, conditions ...interface{}) []*Milestone {
	if o.IsNew() {
		return nil
	}
	for obj := range o.revMilestones.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot load over items that have changed but have not been saved.")
		}
	}

	qb := queryMilestones(ctx)
	cond := op.Equal(node.Milestone().ProjectID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = op.And(conditions...)
	}

	objs := qb.Where(cond).Load()
	o.revMilestones.Clear()

	for _, obj := range objs {
		pk := obj.ID()
		o.revMilestones.Set(pk, obj)
	}

	if o.revMilestones.Len() == 0 {
		return nil
	}
	return o.revMilestones.Values()
}

// CountMilestones does a database query and returns the number of Milestone
// objects currently in the database connected to this object.
func (o *projectBase) CountMilestones(ctx context.Context) int {
	return CountMilestonesByProjectID(ctx, o.PrimaryKey())
}

// SetMilestones associates the objects in objs with the Project.
// WARNING! If it has items already associated with it that will not be associated after a save,
// Save will panic. Be sure to delete those items or otherwise fix those pointers before calling save.
func (o *projectBase) SetMilestones(objs ...*Milestone) {
	for obj := range o.revMilestones.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot overwrite items that have changed but have not been saved.")
		}
	}

	o.revMilestones.Clear()
	for _, obj := range objs {
		pk := obj.ID()
		o.revMilestones.Set(pk, obj)
	}
	o.revMilestonesIsDirty = true
}

// ParentProjectProject returns a single Project object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return Project objects that are not saved.
func (o *projectBase) ParentProjectProject(pk string) *Project {
	v := o.revParentProjectProjects.Get(pk)
	return v
}

// ParentProjectProjects returns a slice of Project objects if loaded.
func (o *projectBase) ParentProjectProjects() []*Project {
	return o.revParentProjectProjects.Values()
}

// LoadParentProjectProjects loads a new slice of Project objects and returns it.
func (o *projectBase) LoadParentProjectProjects(ctx context.Context, conditions ...interface{}) []*Project {
	if o.IsNew() {
		return nil
	}
	for obj := range o.revParentProjectProjects.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot load over items that have changed but have not been saved.")
		}
	}

	qb := queryProjects(ctx)
	cond := op.Equal(node.Project().ParentProjectID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = op.And(conditions...)
	}

	objs := qb.Where(cond).Load()
	o.revParentProjectProjects.Clear()

	for _, obj := range objs {
		pk := obj.ID()
		o.revParentProjectProjects.Set(pk, obj)
	}

	if o.revParentProjectProjects.Len() == 0 {
		return nil
	}
	return o.revParentProjectProjects.Values()
}

// CountParentProjectProjects does a database query and returns the number of Project
// objects currently in the database connected to this object.
func (o *projectBase) CountParentProjectProjects(ctx context.Context) int {
	return CountProjectsByParentProjectID(ctx, o.PrimaryKey())
}

// SetParentProjectProjects associates the objects in objs with the Project.
// If it has items already associated with it that will not be associated after a save,
// the foreign keys for those items will be set to null.
// If you did not use a join to query the items in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be changing items
// that are not currently attached to this Project.
func (o *projectBase) SetParentProjectProjects(objs ...*Project) {
	for obj := range o.revParentProjectProjects.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot overwrite items that have changed but have not been saved.")
		}
	}

	o.revParentProjectProjects.Clear()
	for _, obj := range objs {
		pk := obj.ID()
		o.revParentProjectProjects.Set(pk, obj)
	}
	o.revParentProjectProjectsIsDirty = true
}

// LoadProject returns a Project from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [ProjectsBuilder.Select] for more info.
func LoadProject(ctx context.Context, id string, selectNodes ...query.Node) *Project {
	return queryProjects(ctx).
		Where(op.Equal(node.Project().ID(), id)).
		Select(selectNodes...).
		Get()
}

// HasProject returns true if a Project with the given primaryKey exists in the database.
// doc: type=Project
func HasProject(ctx context.Context, id string) bool {
	return queryProjects(ctx).
		Where(op.Equal(node.Project().ID(), id)).
		Count() == 1
}

// LoadProjectByNum queries for a single Project object by the given unique index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [ProjectsBuilder.Select].
// If you need a more elaborate query, use QueryProjects() to start a query builder.
func LoadProjectByNum(ctx context.Context, num int, selectNodes ...query.Node) *Project {
	q := queryProjects(ctx)
	q = q.Where(op.Equal(node.Project().Num(), num))
	return q.Select(selectNodes...).Get()
}

// HasProjectByNum returns true if the
// given unique index values exist in the database.
// doc: type=Project
func HasProjectByNum(ctx context.Context, num int) bool {
	q := queryProjects(ctx)
	q = q.Where(op.Equal(node.Project().Num(), num))
	return q.Count() == 1
}

// The ProjectBuilder uses the query.BuilderI interface to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, LoadCursor, Get, Count, or Delete
type ProjectBuilder interface {
	// Join(alias string, joinedTable query.Node, condition query.Node) ProjectBuilder

	// Where adds a condition to filter what gets selected.
	// Calling Where multiple times will AND the conditions together.
	Where(c query.Node) ProjectBuilder

	// OrderBy specifies how the resulting data should be sorted.
	// By default, the given nodes are sorted in ascending order.
	// Add Descending() to the node to specify that it should be sorted in descending order.
	OrderBy(nodes ...query.Sorter) ProjectBuilder

	// Limit will return a subset of the data, limited to the offset and number of rows specified.
	// For large data sets and specific types of queries, this can be slow, because it will perform
	// the entire query before computing the limit.
	// You cannot limit a query that has selected a "many" relationship".
	Limit(maxRowCount int, offset int) ProjectBuilder

	// Select performs two functions:
	//  - Passing a table type node will join the object or objects from that table to this object.
	//  - Passing a column node will optimize the query to only return the specified fields.
	// Once you select at least one column, you must select all the columns that you want in the result.
	// Some fields, like primary keys, are always selected.
	// If you are using a GroupBy, you must select the fields in the GroupBy.
	Select(nodes ...query.Node) ProjectBuilder

	// Calculation adds a calculation described by operation with the name alias.
	// After the query, you can read the data using GetAlias() on the object identified by base.
	Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) ProjectBuilder

	// Distinct removes duplicates from the results of the query.
	// Adding a Select() is required.
	Distinct() ProjectBuilder

	// GroupBy controls how results are grouped when using aggregate functions with Calculation.
	GroupBy(nodes ...query.Node) ProjectBuilder

	// Having does additional filtering on the results of the query after the query is performed.
	Having(node query.Node) ProjectBuilder

	// Load terminates the query builder, performs the query, and returns a slice of Project objects.
	// If there are any errors, nil is returned and the specific error is stored in the context.
	// If no results come back from the query, it will return a non-nil empty slice.
	Load() []*Project
	// Load terminates the query builder, performs the query, and returns a slice of interfaces.
	// This can then satisfy a general interface that loads arrays of objects.
	// If there are any errors, nil is returned and the specific error is stored in the context.
	// If no results come back from the query, it will return a non-nil empty slice.
	LoadI() []any

	// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
	//
	// A query cursor is useful for dealing with large amounts of query results. However, there are some
	// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
	// many-to-many or reverse relationships that will create an array of values.
	//
	// Call Next() on the returned cursor object to step through the results. Make sure you call Close
	// on the cursor object when you are done. You should use
	//   defer cursor.Close()
	// to make sure the cursor gets closed.
	LoadCursor() projectsCursor

	// Get is a convenience method to return only the first item found in a query.
	// The entire query is performed, so you should generally use this only if you know
	// you are selecting on one or very few items.
	//
	// If an error occurs, or no results are found, a nil is returned.
	// In the case of an error, the error is returned in the context.
	Get() *Project

	// Count terminates a query and returns just the number of items in the result.
	// If you have Select or Calculation columns in the query, it will count NULL results as well.
	// To not count NULL values, use Where in the builder with a NotNull operation.
	// To count distinct combinations of items, call Distinct() on the builder.
	Count() int

	// Subquery terminates the query builder and tags it as a subquery within a larger query.
	// You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
	// Generally you would use this as a node to a Calculation function on the surrounding query builder.
	// Subquery() *query.SubqueryNode

}

type projectQueryBuilder struct {
	builder *query.Builder
}

func newProjectBuilder(ctx context.Context) ProjectBuilder {
	b := projectQueryBuilder{
		builder: query.NewBuilder(ctx, node.Project()),
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of Project objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *projectQueryBuilder) Load() (projects []*Project) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	results := database.BuilderQuery(b.builder)
	if results == nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Project)
		o.load(item, o)
		projects = append(projects, o)
	}
	return
}

// Load terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a general interface that loads arrays of objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *projectQueryBuilder) LoadI() (projects []any) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	results := database.BuilderQuery(b.builder)
	if results == nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Project)
		o.load(item, o)
		projects = append(projects, o)
	}
	return
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *projectQueryBuilder) LoadCursor() projectsCursor {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd")
	result := database.BuilderQuery(b.builder)
	if result == nil {
		return projectsCursor{}
	}
	cursor := result.(query.CursorI)

	return projectsCursor{cursor}
}

type projectsCursor struct {
	query.CursorI
}

// Next returns the current Project object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c projectsCursor) Next() *Project {
	if c.CursorI == nil {
		return nil
	}

	row := c.CursorI.Next()
	if row == nil {
		return nil
	}
	o := new(Project)
	o.load(row, o)
	return o
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
//
// If an error occurs, or no results are found, a nil is returned.
// In the case of an error, the error is returned in the context.
func (b *projectQueryBuilder) Get() *Project {
	results := b.Load()
	if results != nil && len(results) > 0 {
		obj := results[0]
		return obj
	} else {
		return nil
	}
}

/*
// Join attaches the table referred to by joinedTable, filtering the join process using the operation node specified
// by condition.
// The joinedTable node will be modified by this process so that you can use it in subsequent builder operations.
// Call GetAlias to return the resulting object from the query result.
func (b *projectQueryBuilder) Join(alias string, joinedTable query.Node, condition query.Node) ProjectBuilder {
    if query.RootNode(n).TableName_() != "project" {
        panic("you can only join a node that is rooted at node.Project()")
    }
    // TODO: make sure joinedTable is a table node
	b.builder.Join(alias, joinedTable, condition)
	return b
}
*/

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *projectQueryBuilder) Where(c query.Node) ProjectBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *projectQueryBuilder) OrderBy(nodes ...query.Sorter) ProjectBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *projectQueryBuilder) Limit(maxRowCount int, offset int) ProjectBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the project table will be queried and loaded.
// If nodes contains columns from the project table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *projectQueryBuilder) Select(nodes ...query.Node) ProjectBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *projectQueryBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) ProjectBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *projectQueryBuilder) Distinct() ProjectBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *projectQueryBuilder) GroupBy(nodes ...query.Node) ProjectBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *projectQueryBuilder) Having(node query.Node) ProjectBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *projectQueryBuilder) Count() int {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd")
	results := database.BuilderQuery(b.builder)
	if results == nil {
		return 0
	}
	return results.(int)
}

/*
// Subquery terminates the query builder and tags it as a subquery within a larger query.
// You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
// Generally you would use this as a node to a Calculation function on the surrounding query builder.
func (b *projectQueryBuilder)  Subquery() *query.SubqueryNode {
	 return b.builder.Subquery()
}
*/

// CountProjectsByID queries the database and returns the number of Project objects that
// have id.
// doc: type=Project
func CountProjectsByID(ctx context.Context, id string) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().ID(), id)).Count()
}

// CountProjectsByNum queries the database and returns the number of Project objects that
// have num.
// doc: type=Project
func CountProjectsByNum(ctx context.Context, num int) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Num(), num)).Count()
}

// CountProjectsByStatus queries the database and returns the number of Project objects that
// have status.
// doc: type=Project
func CountProjectsByStatus(ctx context.Context, status ProjectStatus) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Status(), status)).Count()
}

// CountProjectsByManagerID queries the database and returns the number of Project objects that
// have managerID.
// doc: type=Project
func CountProjectsByManagerID(ctx context.Context, managerID string) int {
	if managerID == "" {
		return 0
	}
	return queryProjects(ctx).Where(op.Equal(node.Project().ManagerID(), managerID)).Count()
}

// CountProjectsByName queries the database and returns the number of Project objects that
// have name.
// doc: type=Project
func CountProjectsByName(ctx context.Context, name string) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Name(), name)).Count()
}

// CountProjectsByDescription queries the database and returns the number of Project objects that
// have description.
// doc: type=Project
func CountProjectsByDescription(ctx context.Context, description string) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Description(), description)).Count()
}

// CountProjectsByStartDate queries the database and returns the number of Project objects that
// have startDate.
// doc: type=Project
func CountProjectsByStartDate(ctx context.Context, startDate time.Time) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().StartDate(), startDate)).Count()
}

// CountProjectsByEndDate queries the database and returns the number of Project objects that
// have endDate.
// doc: type=Project
func CountProjectsByEndDate(ctx context.Context, endDate time.Time) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().EndDate(), endDate)).Count()
}

// CountProjectsByBudget queries the database and returns the number of Project objects that
// have budget.
// doc: type=Project
func CountProjectsByBudget(ctx context.Context, budget []byte) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Budget(), budget)).Count()
}

// CountProjectsBySpent queries the database and returns the number of Project objects that
// have spent.
// doc: type=Project
func CountProjectsBySpent(ctx context.Context, spent []byte) int {
	return queryProjects(ctx).Where(op.Equal(node.Project().Spent(), spent)).Count()
}

// CountProjectsByParentProjectID queries the database and returns the number of Project objects that
// have parentProjectID.
// doc: type=Project
func CountProjectsByParentProjectID(ctx context.Context, parentProjectID string) int {
	if parentProjectID == "" {
		return 0
	}
	return queryProjects(ctx).Where(op.Equal(node.Project().ParentProjectID(), parentProjectID)).Count()
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
func (o *projectBase) load(m map[string]interface{}, objThis *Project) {

	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsValid = true

			o._originalPK = o.id

		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsValid = false
		o.id = ""
	}

	if v, ok := m["num"]; ok && v != nil {
		if o.num, ok = v.(int); ok {
			o.numIsValid = true
			o.numIsDirty = false

		} else {
			panic("Wrong type found for num.")
		}
	} else {
		o.numIsValid = false
		o.num = 0
		o.numIsDirty = false
	}

	if v, ok := m["status_enum"]; ok && v != nil {
		if i, ok2 := v.(int); ok2 {
			o.status = ProjectStatus(i)
			o.statusIsValid = true
			o.statusIsDirty = false

		} else {
			panic("Wrong type found for status_enum.")
		}
	} else {
		o.statusIsValid = false
		o.status = 0
		o.statusIsDirty = false
	}

	if v, ok := m["manager_id"]; ok {
		if v == nil {
			o.managerID = ""
			o.managerIDIsNull = true
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else if o.managerID, ok = v.(string); ok {
			o.managerIDIsNull = false
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for manager_id.")
		}
	} else {
		o.managerIDIsValid = false
		o.managerIDIsNull = true
		o.managerID = ""
		o.managerIDIsDirty = false
	}

	if v, ok := m["Manager"]; ok {
		if objManager, ok2 := v.(map[string]any); ok2 {
			o.objManager = new(Person)
			o.objManager.load(objManager, o.objManager)
			o.managerIDIsValid = true
			o.managerIDIsDirty = false
		} else {
			panic("Wrong type found for Manager object.")
		}
	} else {
		o.objManager = nil
	}

	if v, ok := m["name"]; ok && v != nil {
		if o.name, ok = v.(string); ok {
			o.nameIsValid = true
			o.nameIsDirty = false

		} else {
			panic("Wrong type found for name.")
		}
	} else {
		o.nameIsValid = false
		o.name = ""
		o.nameIsDirty = false
	}

	if v, ok := m["description"]; ok {
		if v == nil {
			o.description = ""
			o.descriptionIsNull = true
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else if o.description, ok = v.(string); ok {
			o.descriptionIsNull = false
			o.descriptionIsValid = true
			o.descriptionIsDirty = false
		} else {
			panic("Wrong type found for description.")
		}
	} else {
		o.descriptionIsValid = false
		o.descriptionIsNull = true
		o.description = ""
		o.descriptionIsDirty = false
	}

	if v, ok := m["start_date"]; ok {
		if v == nil {
			o.startDate = time.Time{}
			o.startDateIsNull = true
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else if o.startDate, ok = v.(time.Time); ok {
			o.startDateIsNull = false
			o.startDateIsValid = true
			o.startDateIsDirty = false
		} else {
			panic("Wrong type found for start_date.")
		}
	} else {
		o.startDateIsValid = false
		o.startDateIsNull = true
		o.startDate = time.Time{}
		o.startDateIsDirty = false
	}

	if v, ok := m["end_date"]; ok {
		if v == nil {
			o.endDate = time.Time{}
			o.endDateIsNull = true
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else if o.endDate, ok = v.(time.Time); ok {
			o.endDateIsNull = false
			o.endDateIsValid = true
			o.endDateIsDirty = false
		} else {
			panic("Wrong type found for end_date.")
		}
	} else {
		o.endDateIsValid = false
		o.endDateIsNull = true
		o.endDate = time.Time{}
		o.endDateIsDirty = false
	}

	if v, ok := m["budget"]; ok {
		if v == nil {
			o.budget = []byte{}
			o.budgetIsNull = true
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else if o.budget, ok = v.([]byte); ok {
			o.budgetIsNull = false
			o.budgetIsValid = true
			o.budgetIsDirty = false
		} else {
			panic("Wrong type found for budget.")
		}
	} else {
		o.budgetIsValid = false
		o.budgetIsNull = true
		o.budget = []byte{}
		o.budgetIsDirty = false
	}

	if v, ok := m["spent"]; ok {
		if v == nil {
			o.spent = []byte{}
			o.spentIsNull = true
			o.spentIsValid = true
			o.spentIsDirty = false
		} else if o.spent, ok = v.([]byte); ok {
			o.spentIsNull = false
			o.spentIsValid = true
			o.spentIsDirty = false
		} else {
			panic("Wrong type found for spent.")
		}
	} else {
		o.spentIsValid = false
		o.spentIsNull = true
		o.spent = []byte{}
		o.spentIsDirty = false
	}

	if v, ok := m["parent_project_id"]; ok {
		if v == nil {
			o.parentProjectID = ""
			o.parentProjectIDIsNull = true
			o.parentProjectIDIsValid = true
			o.parentProjectIDIsDirty = false
		} else if o.parentProjectID, ok = v.(string); ok {
			o.parentProjectIDIsNull = false
			o.parentProjectIDIsValid = true
			o.parentProjectIDIsDirty = false
		} else {
			panic("Wrong type found for parent_project_id.")
		}
	} else {
		o.parentProjectIDIsValid = false
		o.parentProjectIDIsNull = true
		o.parentProjectID = ""
		o.parentProjectIDIsDirty = false
	}

	if v, ok := m["ParentProject"]; ok {
		if objParentProject, ok2 := v.(map[string]any); ok2 {
			o.objParentProject = new(Project)
			o.objParentProject.load(objParentProject, o.objParentProject)
			o.parentProjectIDIsValid = true
			o.parentProjectIDIsDirty = false
		} else {
			panic("Wrong type found for ParentProject object.")
		}
	} else {
		o.objParentProject = nil
	}

	// Many-Many references

	if v, ok := m["Children"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.mmChildren.Clear()

			for _, v3 := range v2 {
				obj := new(Project)
				obj.load(v3, obj)
				o.mmChildren.Set(obj.PrimaryKey(), obj)
			}
			o.mmChildrenPks = nil
		} else {
			panic("Wrong type found for mmChildren object.")
		}
	} else {
		o.mmChildren.Clear()
		o.mmChildrenPks = nil
	}

	if v, ok := m["Parents"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.mmParents.Clear()

			for _, v3 := range v2 {
				obj := new(Project)
				obj.load(v3, obj)
				o.mmParents.Set(obj.PrimaryKey(), obj)
			}
			o.mmParentsPks = nil
		} else {
			panic("Wrong type found for mmParents object.")
		}
	} else {
		o.mmParents.Clear()
		o.mmParentsPks = nil
	}

	if v, ok := m["TeamMembers"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.mmTeamMembers.Clear()

			for _, v3 := range v2 {
				obj := new(Person)
				obj.load(v3, obj)
				o.mmTeamMembers.Set(obj.PrimaryKey(), obj)
			}
			o.mmTeamMembersPks = nil
		} else {
			panic("Wrong type found for mmTeamMembers object.")
		}
	} else {
		o.mmTeamMembers.Clear()
		o.mmTeamMembersPks = nil
	}

	// Reverse references

	if v, ok := m["Milestones"]; ok {
		switch v2 := v.(type) {
		case []map[string]any: // array expansion
			o.revMilestones.Clear()
			o.revMilestonesIsDirty = false
			for _, v3 := range v2 {
				obj := new(Milestone)
				obj.load(v3, obj)
				o.revMilestones.Set(obj.PrimaryKey(), obj)
			}
		case map[string]any: // single expansion
			obj := new(Milestone)
			obj.load(v2, obj)
			o.revMilestones.Clear()
			o.revMilestones.Set(obj.PrimaryKey(), obj)
			o.revMilestonesIsDirty = false
		default:
			panic("Wrong type found for revMilestones object.")
		}
	} else {
		o.revMilestones.Clear()
		o.revMilestonesIsDirty = false
	}

	if v, ok := m["ParentProjectProjects"]; ok {
		switch v2 := v.(type) {
		case []map[string]any: // array expansion
			o.revParentProjectProjects.Clear()
			o.revParentProjectProjectsIsDirty = false
			for _, v3 := range v2 {
				obj := new(Project)
				obj.load(v3, obj)
				o.revParentProjectProjects.Set(obj.PrimaryKey(), obj)
			}
		case map[string]any: // single expansion
			obj := new(Project)
			obj.load(v2, obj)
			o.revParentProjectProjects.Clear()
			o.revParentProjectProjects.Set(obj.PrimaryKey(), obj)
			o.revParentProjectProjectsIsDirty = false
		default:
			panic("Wrong type found for revParentProjectProjects object.")
		}
	} else {
		o.revParentProjectProjects.Clear()
		o.revParentProjectProjectsIsDirty = false
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}

// Save will update or insert the object, depending on the state of the object.
// If it has any auto-generated ids, those will be updated.
// Database errors generally will be handled by the logger and not returned here,
// since those indicate a problem with database driver or configuration.
// Save will return a db.OptimisticLockError if it detects a collision when two users
// are attempting to change the same database record.
func (o *projectBase) Save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
func (o *projectBase) update(ctx context.Context) error {
	if !o._restored {
		panic("cannot update a record that was not originally read from the database.")
	}
	if !o.IsDirty() {
		return nil // nothing to save
	}

	var modifiedFields map[string]interface{}

	d := Database()
	err := db.ExecuteTransaction(ctx, d, func() error {

		// Save loaded Manager object to get its new pk and update it here.
		if o.objManager != nil {
			if err := o.objManager.Save(ctx); err != nil {
				return err
			}
			id := o.objManager.PrimaryKey()
			o.SetManagerID(id)
		}

		// Save loaded ParentProject object to get its new pk and update it here.
		if o.objParentProject != nil {
			if err := o.objParentProject.Save(ctx); err != nil {
				return err
			}
			id := o.objParentProject.PrimaryKey()
			o.SetParentProjectID(id)
		}

		modifiedFields = o.getModifiedFields()
		if len(modifiedFields) != 0 {
			var err2 error

			_, err2 = d.Update(ctx, "project", "id", o._originalPK, modifiedFields, "", 0)
			if err2 != nil {
				return err2
			}
		}

		if o.revMilestonesIsDirty {
			// relation connection changed

			// Since the other side of the relationship cannot be null, there cannot be objects that will be detached.
			oldObjs := QueryMilestones(ctx).
				Where(op.Equal(node.Milestone().ProjectID(), o.PrimaryKey())).
				Select(node.Milestone().ProjectID()).
				Load()
			for _, obj := range oldObjs {
				if !o.revMilestones.Has(obj.PrimaryKey()) {
					// The old object is not in the group of new objects
					panic(fmt.Sprintf("cannot remove a non-null reference. Point the reference new a new record first. Primary Key: %v", obj.PrimaryKey()))
				}
			}

			for obj := range o.revMilestones.ValuesIter() {
				obj.SetProjectID(o.PrimaryKey())
				obj.projectIDIsDirty = true // force a change in case data is stale
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}

		} else {

			// save related objects
			for obj := range o.revMilestones.ValuesIter() {
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}
		}
		if o.revParentProjectProjectsIsDirty {
			// relation connection changed

			currentObjs := QueryProjects(ctx).
				Where(op.Equal(node.Project().ParentProjectID(), o.PrimaryKey())).
				Select(node.Project().ParentProjectID()).
				Load()

			for _, obj := range currentObjs {
				if !o.revParentProjectProjects.Has(obj.PrimaryKey()) {
					// The old object is not in the group of new objects
					obj.SetParentProjectIDToNull()
					if err := obj.Save(ctx); err != nil {
						return err
					}
				}
			}
			for obj := range o.revParentProjectProjects.ValuesIter() {
				obj.parentProjectIDIsDirty = true // force a change in case data is stale
				obj.SetParentProjectID(o.PrimaryKey())
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}

		} else {

			// save related objects
			for obj := range o.revParentProjectProjects.ValuesIter() {
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}
		}

		for obj := range o.mmChildren.ValuesIter() {
			if err := obj.Save(ctx); err != nil {
				return err
			}
		}
		if o.mmChildrenIsDirty {
			if len(o.mmChildrenPks) != 0 {
				db.AssociateOnly(ctx,
					d,
					"related_project_assn",
					"parent_id",
					o.PrimaryKey(),
					"child_id",
					o.mmChildrenPks)
			} else {
				db.AssociateOnly(ctx,
					d,
					"related_project_assn",
					"parent_id",
					o.PrimaryKey(),
					"child_id",
					o.mmChildren.Keys())
			}
		}

		for obj := range o.mmParents.ValuesIter() {
			if err := obj.Save(ctx); err != nil {
				return err
			}
		}
		if o.mmParentsIsDirty {
			if len(o.mmParentsPks) != 0 {
				db.AssociateOnly(ctx,
					d,
					"related_project_assn",
					"child_id",
					o.PrimaryKey(),
					"parent_id",
					o.mmParentsPks)
			} else {
				db.AssociateOnly(ctx,
					d,
					"related_project_assn",
					"child_id",
					o.PrimaryKey(),
					"parent_id",
					o.mmParents.Keys())
			}
		}

		for obj := range o.mmTeamMembers.ValuesIter() {
			if err := obj.Save(ctx); err != nil {
				return err
			}
		}
		if o.mmTeamMembersIsDirty {
			if len(o.mmTeamMembersPks) != 0 {
				db.AssociateOnly(ctx,
					d,
					"team_member_project_assn",
					"project_id",
					o.PrimaryKey(),
					"team_member_id",
					o.mmTeamMembersPks)
			} else {
				db.AssociateOnly(ctx,
					d,
					"team_member_project_assn",
					"project_id",
					o.PrimaryKey(),
					"team_member_id",
					o.mmTeamMembers.Keys())
			}
		}

		return nil
	}) // transaction
	if err != nil {
		return err
	}

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd", "project", o._originalPK, all.SortedKeys(modifiedFields)...)
	}

	return nil
}

// insert will insert the object into the database. Related items will be saved.
func (o *projectBase) insert(ctx context.Context) (err error) {
	d := Database()
	err = db.ExecuteTransaction(ctx, d, func() error {

		if o.objManager != nil {
			if err = o.objManager.Save(ctx); err != nil {
				return err
			}
			o.managerID = o.objManager.PrimaryKey()
		}

		if o.objParentProject != nil {
			if err = o.objParentProject.Save(ctx); err != nil {
				return err
			}
			o.parentProjectID = o.objParentProject.PrimaryKey()
		}

		if !o.numIsValid {
			panic("a value for Num is required, and there is no default value. Call SetNum() before inserting the record.")
		}
		if !o.statusIsValid {
			panic("a value for Status is required, and there is no default value. Call SetStatus() before inserting the record.")
		}
		if !o.nameIsValid {
			panic("a value for Name is required, and there is no default value. Call SetName() before inserting the record.")
		}

		m := o.getValidFields()

		id := d.Insert(ctx, "project", m)
		o.id = id
		o._originalPK = id

		if o.revMilestones.Len() > 0 {
			for _, obj := range o.revMilestones.All() {
				obj.SetProjectID(id)
				if err = obj.Save(ctx); err != nil {
					return err
				}
				o.revMilestones.Set(obj.PrimaryKey(), obj)
			}
		}

		if o.revParentProjectProjects.Len() > 0 {
			for _, obj := range o.revParentProjectProjects.All() {
				obj.SetParentProjectID(id)
				if err = obj.Save(ctx); err != nil {
					return err
				}
				o.revParentProjectProjects.Set(obj.PrimaryKey(), obj)
			}
		}

		if o.mmChildren.Len() > 0 {
			for _, obj := range o.mmChildren.All() {
				if err = obj.Save(ctx); err != nil {
					return err
				}
				db.Associate(ctx,
					d,
					"related_project_assn",
					"parent_id",
					o.id,
					"child_id",
					obj.PrimaryKey(),
				)
			}
		} else if len(o.mmChildrenPks) > 0 {
			for _, pk := range o.mmChildrenPks {
				obj := LoadProject(ctx, pk)
				if obj != nil {
					db.Associate(ctx,
						d,
						"related_project_assn",
						"parent_id",
						o.id,
						"child_id",
						pk,
					)
				}
			}
		}
		if o.mmParents.Len() > 0 {
			for _, obj := range o.mmParents.All() {
				if err = obj.Save(ctx); err != nil {
					return err
				}
				db.Associate(ctx,
					d,
					"related_project_assn",
					"child_id",
					o.id,
					"parent_id",
					obj.PrimaryKey(),
				)
			}
		} else if len(o.mmParentsPks) > 0 {
			for _, pk := range o.mmParentsPks {
				obj := LoadProject(ctx, pk)
				if obj != nil {
					db.Associate(ctx,
						d,
						"related_project_assn",
						"child_id",
						o.id,
						"parent_id",
						pk,
					)
				}
			}
		}
		if o.mmTeamMembers.Len() > 0 {
			for _, obj := range o.mmTeamMembers.All() {
				if err = obj.Save(ctx); err != nil {
					return err
				}
				db.Associate(ctx,
					d,
					"team_member_project_assn",
					"project_id",
					o.id,
					"team_member_id",
					obj.PrimaryKey(),
				)
			}
		} else if len(o.mmTeamMembersPks) > 0 {
			for _, pk := range o.mmTeamMembersPks {
				obj := LoadPerson(ctx, pk)
				if obj != nil {
					db.Associate(ctx,
						d,
						"team_member_project_assn",
						"project_id",
						o.id,
						"team_member_id",
						pk,
					)
				}
			}
		}

		return nil

	}) // transaction

	if err != nil {
		return
	}

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "project", o.PrimaryKey())
	return
}

// getModifiedFields returns the database columns that have been modified. This
// will determine which specific fields are sent to the database to be changed.
func (o *projectBase) getModifiedFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.numIsDirty {
		fields["num"] = o.num
	}
	if o.statusIsDirty {
		fields["status_enum"] = o.status
	}
	if o.managerIDIsDirty {
		if o.managerIDIsNull {
			fields["manager_id"] = nil
		} else {
			fields["manager_id"] = o.managerID
		}
	}
	if o.nameIsDirty {
		fields["name"] = o.name
	}
	if o.descriptionIsDirty {
		if o.descriptionIsNull {
			fields["description"] = nil
		} else {
			fields["description"] = o.description
		}
	}
	if o.startDateIsDirty {
		if o.startDateIsNull {
			fields["start_date"] = nil
		} else {
			fields["start_date"] = o.startDate
		}
	}
	if o.endDateIsDirty {
		if o.endDateIsNull {
			fields["end_date"] = nil
		} else {
			fields["end_date"] = o.endDate
		}
	}
	if o.budgetIsDirty {
		if o.budgetIsNull {
			fields["budget"] = nil
		} else {
			fields["budget"] = o.budget
		}
	}
	if o.spentIsDirty {
		if o.spentIsNull {
			fields["spent"] = nil
		} else {
			fields["spent"] = o.spent
		}
	}
	if o.parentProjectIDIsDirty {
		if o.parentProjectIDIsNull {
			fields["parent_project_id"] = nil
		} else {
			fields["parent_project_id"] = o.parentProjectID
		}
	}
	return
}

// getValidFields returns the fields that have valid data in them in a form ready to send to the database.
func (o *projectBase) getValidFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.numIsValid {
		fields["num"] = o.num
	}
	if o.statusIsValid {
		fields["status_enum"] = o.status
	}
	if o.managerIDIsValid {
		if o.managerIDIsNull {
			fields["manager_id"] = nil
		} else {
			fields["manager_id"] = o.managerID
		}
	}
	if o.nameIsValid {
		fields["name"] = o.name
	}
	if o.descriptionIsValid {
		if o.descriptionIsNull {
			fields["description"] = nil
		} else {
			fields["description"] = o.description
		}
	}
	if o.startDateIsValid {
		if o.startDateIsNull {
			fields["start_date"] = nil
		} else {
			fields["start_date"] = o.startDate
		}
	}
	if o.endDateIsValid {
		if o.endDateIsNull {
			fields["end_date"] = nil
		} else {
			fields["end_date"] = o.endDate
		}
	}
	if o.budgetIsValid {
		if o.budgetIsNull {
			fields["budget"] = nil
		} else {
			fields["budget"] = o.budget
		}
	}
	if o.spentIsValid {
		if o.spentIsNull {
			fields["spent"] = nil
		} else {
			fields["spent"] = o.spent
		}
	}
	if o.parentProjectIDIsValid {
		if o.parentProjectIDIsNull {
			fields["parent_project_id"] = nil
		} else {
			fields["parent_project_id"] = o.parentProjectID
		}
	}
	return
}

// Delete deletes the record from the database.
//
// Associated Milestones will also be deleted since their ProjectID fields are not nullable.
// Associated ParentProjectProjects will have their ParentProjectID field set to NULL.
func (o *projectBase) Delete(ctx context.Context) (err error) {
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()
	err = db.ExecuteTransaction(ctx, d, func() error {

		{
			objs := QueryMilestones(ctx).
				Where(op.Equal(node.Milestone().ProjectID(), o.id)).
				Load()
			for _, obj := range objs {
				if err = obj.Delete(ctx); err != nil {
					return err
				}
			}
			o.revMilestones.Clear()
		}

		{
			objs := QueryProjects(ctx).
				Where(op.Equal(node.Project().ParentProjectID(), o.id)).
				Select(node.Project().ParentProjectID()).
				Load()
			for _, obj := range objs {
				obj.SetParentProjectIDToNull()
				if err = obj.Save(ctx); err != nil {
					return err
				}
			}
			o.revParentProjectProjects.Clear()
		}

		db.AssociateOnly(ctx,
			d,
			"related_project_assn",
			"parent_id",
			o.PrimaryKey(),
			"id",
			[]Project(nil))

		db.AssociateOnly(ctx,
			d,
			"related_project_assn",
			"child_id",
			o.PrimaryKey(),
			"id",
			[]Project(nil))

		db.AssociateOnly(ctx,
			d,
			"team_member_project_assn",
			"project_id",
			o.PrimaryKey(),
			"id",
			[]Person(nil))

		d.Delete(ctx, "project", map[string]any{"ID": o.id})
		return nil
	})

	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd", "project", fmt.Sprint(o.id))
	return
}

// deleteProject deletes the Project with primary key pk from the database
// and handles associated records.
func deleteProject(ctx context.Context, pk string) error {
	if obj := LoadProject(ctx, pk, node.Project().PrimaryKey()); obj != nil {
		if err := obj.Delete(ctx); err != nil {
			return err
		}
	}
	return nil
}

// resetDirtyStatus resets the dirty status of every field in the object.
func (o *projectBase) resetDirtyStatus() {
	o.numIsDirty = false
	o.statusIsDirty = false
	o.managerIDIsDirty = false
	o.nameIsDirty = false
	o.descriptionIsDirty = false
	o.startDateIsDirty = false
	o.endDateIsDirty = false
	o.budgetIsDirty = false
	o.spentIsDirty = false
	o.parentProjectIDIsDirty = false
	o.revMilestonesIsDirty = false
	o.revParentProjectProjectsIsDirty = false
	o.mmChildrenIsDirty = false
	o.mmParentsIsDirty = false
	o.mmTeamMembersIsDirty = false

}

// IsDirty returns true if the object has been changed since it was read from the database or created.
// However, a new object that has a column with a default value will be automatically marked as dirty upon creation.
func (o *projectBase) IsDirty() (dirty bool) {
	dirty = o.numIsDirty ||
		o.statusIsDirty ||
		o.managerIDIsDirty ||
		(o.objManager != nil && o.objManager.IsDirty()) ||
		o.nameIsDirty ||
		o.descriptionIsDirty ||
		o.startDateIsDirty ||
		o.endDateIsDirty ||
		o.budgetIsDirty ||
		o.spentIsDirty ||
		o.parentProjectIDIsDirty ||
		(o.objParentProject != nil && o.objParentProject.IsDirty())

	dirty = dirty ||
		o.revMilestonesIsDirty ||
		o.revParentProjectProjectsIsDirty

	for obj := range o.revMilestones.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}
	for obj := range o.revParentProjectProjects.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}

	dirty = dirty ||
		o.mmChildrenIsDirty ||
		o.mmParentsIsDirty ||
		o.mmTeamMembersIsDirty

	for obj := range o.mmChildren.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}

	for obj := range o.mmParents.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}

	for obj := range o.mmTeamMembers.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}

	return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil
func (o *projectBase) Get(key string) interface{} {

	switch key {

	case "ID":
		if !o.idIsValid {
			return nil
		}
		return o.id

	case "Num":
		if !o.numIsValid {
			return nil
		}
		return o.num

	case "Status":
		if !o.statusIsValid {
			return nil
		}
		return o.status

	case "ManagerID":
		if !o.managerIDIsValid {
			return nil
		}
		return o.managerID

	case "Manager":
		return o.Manager()

	case "Name":
		if !o.nameIsValid {
			return nil
		}
		return o.name

	case "Description":
		if !o.descriptionIsValid {
			return nil
		}
		return o.description

	case "StartDate":
		if !o.startDateIsValid {
			return nil
		}
		return o.startDate

	case "EndDate":
		if !o.endDateIsValid {
			return nil
		}
		return o.endDate

	case "Budget":
		if !o.budgetIsValid {
			return nil
		}
		return o.budget

	case "Spent":
		if !o.spentIsValid {
			return nil
		}
		return o.spent

	case "ParentProjectID":
		if !o.parentProjectIDIsValid {
			return nil
		}
		return o.parentProjectID

	case "ParentProject":
		return o.ParentProject()

	case "Milestones":
		return o.revMilestones.Values()
	case "ParentProjectProjects":
		return o.revParentProjectProjects.Values()

	case "Children":
		return o.mmChildren.Values()
	case "Parents":
		return o.mmParents.Values()
	case "TeamMembers":
		return o.mmTeamMembers.Values()

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *projectBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	encoder := gob.NewEncoder(buf)

	if err := encoder.Encode(o.id); err != nil {
		return nil, fmt.Errorf("error encoding Project.id: %w", err)
	}
	if err := encoder.Encode(o.idIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.idIsValid: %w", err)
	}

	if err := encoder.Encode(o.num); err != nil {
		return nil, fmt.Errorf("error encoding Project.num: %w", err)
	}
	if err := encoder.Encode(o.numIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.numIsValid: %w", err)
	}
	if err := encoder.Encode(o.numIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.numIsDirty: %w", err)
	}

	if err := encoder.Encode(o.status); err != nil {
		return nil, fmt.Errorf("error encoding Project.status: %w", err)
	}
	if err := encoder.Encode(o.statusIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.statusIsValid: %w", err)
	}
	if err := encoder.Encode(o.statusIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.statusIsDirty: %w", err)
	}

	if err := encoder.Encode(o.managerID); err != nil {
		return nil, fmt.Errorf("error encoding Project.managerID: %w", err)
	}
	if err := encoder.Encode(o.managerIDIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.managerIDIsNull: %w", err)
	}
	if err := encoder.Encode(o.managerIDIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.managerIDIsValid: %w", err)
	}
	if err := encoder.Encode(o.managerIDIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.managerIDIsDirty: %w", err)
	}

	if o.objManager == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.objManager); err != nil {
			return nil, fmt.Errorf("error encoding Project.objManager: %w", err)
		}
	}

	if err := encoder.Encode(o.name); err != nil {
		return nil, fmt.Errorf("error encoding Project.name: %w", err)
	}
	if err := encoder.Encode(o.nameIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.nameIsValid: %w", err)
	}
	if err := encoder.Encode(o.nameIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.nameIsDirty: %w", err)
	}

	if err := encoder.Encode(o.description); err != nil {
		return nil, fmt.Errorf("error encoding Project.description: %w", err)
	}
	if err := encoder.Encode(o.descriptionIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.descriptionIsNull: %w", err)
	}
	if err := encoder.Encode(o.descriptionIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.descriptionIsValid: %w", err)
	}
	if err := encoder.Encode(o.descriptionIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.descriptionIsDirty: %w", err)
	}

	if err := encoder.Encode(o.startDate); err != nil {
		return nil, fmt.Errorf("error encoding Project.startDate: %w", err)
	}
	if err := encoder.Encode(o.startDateIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.startDateIsNull: %w", err)
	}
	if err := encoder.Encode(o.startDateIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.startDateIsValid: %w", err)
	}
	if err := encoder.Encode(o.startDateIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.startDateIsDirty: %w", err)
	}

	if err := encoder.Encode(o.endDate); err != nil {
		return nil, fmt.Errorf("error encoding Project.endDate: %w", err)
	}
	if err := encoder.Encode(o.endDateIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.endDateIsNull: %w", err)
	}
	if err := encoder.Encode(o.endDateIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.endDateIsValid: %w", err)
	}
	if err := encoder.Encode(o.endDateIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.endDateIsDirty: %w", err)
	}

	if err := encoder.Encode(o.budget); err != nil {
		return nil, fmt.Errorf("error encoding Project.budget: %w", err)
	}
	if err := encoder.Encode(o.budgetIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.budgetIsNull: %w", err)
	}
	if err := encoder.Encode(o.budgetIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.budgetIsValid: %w", err)
	}
	if err := encoder.Encode(o.budgetIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.budgetIsDirty: %w", err)
	}

	if err := encoder.Encode(o.spent); err != nil {
		return nil, fmt.Errorf("error encoding Project.spent: %w", err)
	}
	if err := encoder.Encode(o.spentIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.spentIsNull: %w", err)
	}
	if err := encoder.Encode(o.spentIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.spentIsValid: %w", err)
	}
	if err := encoder.Encode(o.spentIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.spentIsDirty: %w", err)
	}

	if err := encoder.Encode(o.parentProjectID); err != nil {
		return nil, fmt.Errorf("error encoding Project.parentProjectID: %w", err)
	}
	if err := encoder.Encode(o.parentProjectIDIsNull); err != nil {
		return nil, fmt.Errorf("error encoding Project.parentProjectIDIsNull: %w", err)
	}
	if err := encoder.Encode(o.parentProjectIDIsValid); err != nil {
		return nil, fmt.Errorf("error encoding Project.parentProjectIDIsValid: %w", err)
	}
	if err := encoder.Encode(o.parentProjectIDIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.parentProjectIDIsDirty: %w", err)
	}

	if o.objParentProject == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o.objParentProject); err != nil {
			return nil, fmt.Errorf("error encoding Project.objParentProject: %w", err)
		}
	}

	if err := encoder.Encode(&o.revMilestones); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.revMilestonesIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(&o.revParentProjectProjects); err != nil {
		return nil, err
	}

	if err := encoder.Encode(o.revParentProjectProjectsIsDirty); err != nil {
		return nil, err
	}

	if err := encoder.Encode(&o.mmChildren); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmChildren: %w", err)
	}
	if err := encoder.Encode(o.mmChildrenIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmChildrenIsDirty: %w", err)
	}
	if err := encoder.Encode(o.mmChildrenPks != nil); err != nil {
		return nil, err
	}
	if o.mmChildrenPks != nil {
		if err := encoder.Encode(o.mmChildrenPks); err != nil {
			return nil, fmt.Errorf("error encoding Project.mmChildrenPks: %w", err)
		}
	}

	if err := encoder.Encode(&o.mmParents); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmParents: %w", err)
	}
	if err := encoder.Encode(o.mmParentsIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmParentsIsDirty: %w", err)
	}
	if err := encoder.Encode(o.mmParentsPks != nil); err != nil {
		return nil, err
	}
	if o.mmParentsPks != nil {
		if err := encoder.Encode(o.mmParentsPks); err != nil {
			return nil, fmt.Errorf("error encoding Project.mmParentsPks: %w", err)
		}
	}

	if err := encoder.Encode(&o.mmTeamMembers); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmTeamMembers: %w", err)
	}
	if err := encoder.Encode(o.mmTeamMembersIsDirty); err != nil {
		return nil, fmt.Errorf("error encoding Project.mmTeamMembersIsDirty: %w", err)
	}
	if err := encoder.Encode(o.mmTeamMembersPks != nil); err != nil {
		return nil, err
	}
	if o.mmTeamMembersPks != nil {
		if err := encoder.Encode(o.mmTeamMembersPks); err != nil {
			return nil, fmt.Errorf("error encoding Project.mmTeamMembersPks: %w", err)
		}
	}

	if o._aliases == nil {
		if err := encoder.Encode(false); err != nil {
			return nil, err
		}
	} else {
		if err := encoder.Encode(true); err != nil {
			return nil, err
		}
		if err := encoder.Encode(o._aliases); err != nil {
			return nil, fmt.Errorf("error encoding Project._aliases: %w", err)
		}
	}

	if err := encoder.Encode(o._restored); err != nil {
		return nil, fmt.Errorf("error encoding Project._restored: %w", err)
	}
	if err := encoder.Encode(o._originalPK); err != nil {
		return nil, fmt.Errorf("error encoding Project._originalPK: %w", err)
	}

	return buf.Bytes(), nil

	return buf.Bytes(), nil
}

// UnmarshalBinary converts a structure that was created with MarshalBinary into a Project object.
func (o *projectBase) UnmarshalBinary(data []byte) (err error) {

	buf := bytes.NewBuffer(data)
	dec := gob.NewDecoder(buf)
	var isPtr bool

	_ = isPtr
	if err = dec.Decode(&o.id); err != nil {
		return fmt.Errorf("error decoding Project.id: %w", err)
	}
	if err = dec.Decode(&o.idIsValid); err != nil {
		return fmt.Errorf("error decoding Project.idIsValid: %w", err)
	}

	if err = dec.Decode(&o.num); err != nil {
		return fmt.Errorf("error decoding Project.num: %w", err)
	}
	if err = dec.Decode(&o.numIsValid); err != nil {
		return fmt.Errorf("error decoding Project.numIsValid: %w", err)
	}
	if err = dec.Decode(&o.numIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.numIsDirty: %w", err)
	}

	if err = dec.Decode(&o.status); err != nil {
		return fmt.Errorf("error decoding Project.status: %w", err)
	}
	if err = dec.Decode(&o.statusIsValid); err != nil {
		return fmt.Errorf("error decoding Project.statusIsValid: %w", err)
	}
	if err = dec.Decode(&o.statusIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.statusIsDirty: %w", err)
	}

	if err = dec.Decode(&o.managerID); err != nil {
		return fmt.Errorf("error decoding Project.managerID: %w", err)
	}
	if err = dec.Decode(&o.managerIDIsNull); err != nil {
		return fmt.Errorf("error decoding Project.managerIDIsNull: %w", err)
	}
	if err = dec.Decode(&o.managerIDIsValid); err != nil {
		return fmt.Errorf("error decoding Project.managerIDIsValid: %w", err)
	}
	if err = dec.Decode(&o.managerIDIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.managerIDIsDirty: %w", err)
	}

	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Project.objManager isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.objManager); err != nil {
			return fmt.Errorf("error decoding Project.objManager: %w", err)
		}
	}
	if err = dec.Decode(&o.name); err != nil {
		return fmt.Errorf("error decoding Project.name: %w", err)
	}
	if err = dec.Decode(&o.nameIsValid); err != nil {
		return fmt.Errorf("error decoding Project.nameIsValid: %w", err)
	}
	if err = dec.Decode(&o.nameIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.nameIsDirty: %w", err)
	}

	if err = dec.Decode(&o.description); err != nil {
		return fmt.Errorf("error decoding Project.description: %w", err)
	}
	if err = dec.Decode(&o.descriptionIsNull); err != nil {
		return fmt.Errorf("error decoding Project.descriptionIsNull: %w", err)
	}
	if err = dec.Decode(&o.descriptionIsValid); err != nil {
		return fmt.Errorf("error decoding Project.descriptionIsValid: %w", err)
	}
	if err = dec.Decode(&o.descriptionIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.descriptionIsDirty: %w", err)
	}

	if err = dec.Decode(&o.startDate); err != nil {
		return fmt.Errorf("error decoding Project.startDate: %w", err)
	}
	if err = dec.Decode(&o.startDateIsNull); err != nil {
		return fmt.Errorf("error decoding Project.startDateIsNull: %w", err)
	}
	if err = dec.Decode(&o.startDateIsValid); err != nil {
		return fmt.Errorf("error decoding Project.startDateIsValid: %w", err)
	}
	if err = dec.Decode(&o.startDateIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.startDateIsDirty: %w", err)
	}

	if err = dec.Decode(&o.endDate); err != nil {
		return fmt.Errorf("error decoding Project.endDate: %w", err)
	}
	if err = dec.Decode(&o.endDateIsNull); err != nil {
		return fmt.Errorf("error decoding Project.endDateIsNull: %w", err)
	}
	if err = dec.Decode(&o.endDateIsValid); err != nil {
		return fmt.Errorf("error decoding Project.endDateIsValid: %w", err)
	}
	if err = dec.Decode(&o.endDateIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.endDateIsDirty: %w", err)
	}

	if err = dec.Decode(&o.budget); err != nil {
		return fmt.Errorf("error decoding Project.budget: %w", err)
	}
	if err = dec.Decode(&o.budgetIsNull); err != nil {
		return fmt.Errorf("error decoding Project.budgetIsNull: %w", err)
	}
	if err = dec.Decode(&o.budgetIsValid); err != nil {
		return fmt.Errorf("error decoding Project.budgetIsValid: %w", err)
	}
	if err = dec.Decode(&o.budgetIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.budgetIsDirty: %w", err)
	}

	if err = dec.Decode(&o.spent); err != nil {
		return fmt.Errorf("error decoding Project.spent: %w", err)
	}
	if err = dec.Decode(&o.spentIsNull); err != nil {
		return fmt.Errorf("error decoding Project.spentIsNull: %w", err)
	}
	if err = dec.Decode(&o.spentIsValid); err != nil {
		return fmt.Errorf("error decoding Project.spentIsValid: %w", err)
	}
	if err = dec.Decode(&o.spentIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.spentIsDirty: %w", err)
	}

	if err = dec.Decode(&o.parentProjectID); err != nil {
		return fmt.Errorf("error decoding Project.parentProjectID: %w", err)
	}
	if err = dec.Decode(&o.parentProjectIDIsNull); err != nil {
		return fmt.Errorf("error decoding Project.parentProjectIDIsNull: %w", err)
	}
	if err = dec.Decode(&o.parentProjectIDIsValid); err != nil {
		return fmt.Errorf("error decoding Project.parentProjectIDIsValid: %w", err)
	}
	if err = dec.Decode(&o.parentProjectIDIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.parentProjectIDIsDirty: %w", err)
	}

	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Project.objParentProject isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.objParentProject); err != nil {
			return fmt.Errorf("error decoding Project.objParentProject: %w", err)
		}
	}
	if err = dec.Decode(&o.revMilestones); err != nil {
		return fmt.Errorf("error decoding Project.revMilestones: %w", err)
	}

	if err = dec.Decode(&o.revMilestonesIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.revMilestonesIsDirty: %w", err)
	}

	if err = dec.Decode(&o.revParentProjectProjects); err != nil {
		return fmt.Errorf("error decoding Project.revParentProjectProjects: %w", err)
	}

	if err = dec.Decode(&o.revParentProjectProjectsIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.revParentProjectProjectsIsDirty: %w", err)
	}

	if err = dec.Decode(&o.mmChildren); err != nil {
		return fmt.Errorf("error decoding Project.mmChildrenPks: %w", err)
	}
	if err = dec.Decode(&o.mmChildrenIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.mmChildrenIsDirty: %w", err)
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Project.mmChildrenPks isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.mmChildrenPks); err != nil {
			return fmt.Errorf("error decoding Project.mmChildrenPks: %w", err)
		}
	}

	if err = dec.Decode(&o.mmParents); err != nil {
		return fmt.Errorf("error decoding Project.mmParentsPks: %w", err)
	}
	if err = dec.Decode(&o.mmParentsIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.mmParentsIsDirty: %w", err)
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Project.mmParentsPks isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.mmParentsPks); err != nil {
			return fmt.Errorf("error decoding Project.mmParentsPks: %w", err)
		}
	}

	if err = dec.Decode(&o.mmTeamMembers); err != nil {
		return fmt.Errorf("error decoding Project.mmTeamMembersPks: %w", err)
	}
	if err = dec.Decode(&o.mmTeamMembersIsDirty); err != nil {
		return fmt.Errorf("error decoding Project.mmTeamMembersIsDirty: %w", err)
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Project.mmTeamMembersPks isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.mmTeamMembersPks); err != nil {
			return fmt.Errorf("error decoding Project.mmTeamMembersPks: %w", err)
		}
	}
	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *projectBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *projectBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsValid {
		v["id"] = o.id
	}

	if o.numIsValid {
		v["num"] = o.num
	}

	if o.statusIsValid {
		v["status"] = o.status
	}

	if o.managerIDIsValid {
		if o.managerIDIsNull {
			v["managerID"] = nil
		} else {
			v["managerID"] = o.managerID
		}
	}

	if val := o.Manager(); val != nil {
		v["manager"] = val.MarshalStringMap()
	}

	if o.nameIsValid {
		v["name"] = o.name
	}

	if o.descriptionIsValid {
		if o.descriptionIsNull {
			v["description"] = nil
		} else {
			v["description"] = o.description
		}
	}

	if o.startDateIsValid {
		if o.startDateIsNull {
			v["startDate"] = nil
		} else {
			v["startDate"] = o.startDate
		}
	}

	if o.endDateIsValid {
		if o.endDateIsNull {
			v["endDate"] = nil
		} else {
			v["endDate"] = o.endDate
		}
	}

	if o.budgetIsValid {
		if o.budgetIsNull {
			v["budget"] = nil
		} else {
			v["budget"] = o.budget
		}
	}

	if o.spentIsValid {
		if o.spentIsNull {
			v["spent"] = nil
		} else {
			v["spent"] = o.spent
		}
	}

	if o.parentProjectIDIsValid {
		if o.parentProjectIDIsNull {
			v["parentProjectID"] = nil
		} else {
			v["parentProjectID"] = o.parentProjectID
		}
	}

	if val := o.ParentProject(); val != nil {
		v["parentProject"] = val.MarshalStringMap()
	}
	if o.revMilestones.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.revMilestones.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["milestones"] = vals
	}
	if o.revParentProjectProjects.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.revParentProjectProjects.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["parentProjectProjects"] = vals
	}
	if o.mmChildren.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.mmChildren.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["children"] = vals
	}
	if o.mmParents.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.mmParents.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["parents"] = vals
	}
	if o.mmTeamMembers.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.mmTeamMembers.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["teamMembers"] = vals
	}
	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the Project. The Project can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//
//	"id" - string
//	"num" - int
//	"status" - ProjectStatus
//	"managerID" - string, nullable
//	"name" - string
//	"description" - string, nullable
//	"startDate" - time.Time, nullable
//	"endDate" - time.Time, nullable
//	"budget" - []byte, nullable
//	"spent" - []byte, nullable
//	"parentProjectID" - string, nullable
func (o *projectBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if len(data) == 0 {
		return
	}
	d := json.NewDecoder(bytes.NewReader(data))
	d.UseNumber() // use a number to avoid precision errors
	if err = d.Decode(&v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in Project to modify the json before sending it here.
func (o *projectBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {

		case "num":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetNum(int(n2))
				case int:
					o.SetNum(n)
				case float64:
					o.SetNum(int(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}

		case "status":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				switch n := v.(type) {
				case json.Number:
					n2, err := n.Int64()
					if err != nil {
						return err
					}
					o.SetStatus(ProjectStatus(n2))
				case int:
					o.SetStatus(ProjectStatus(n))
				case float64:
					o.SetStatus(ProjectStatus(n))
				case string:
					o.SetStatus(ProjectStatusFromName(n))
				default:
					return fmt.Errorf("field %s must be a number", k)
				}
			}

		case "managerID":
			{
				if v == nil {
					o.SetManagerIDToNull()
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("field %s must be a string", k)
				} else {
					o.SetManagerID(s)
				}

			}

		case "name":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetName(s)
				}
			}

		case "description":
			{
				if v == nil {
					o.SetDescriptionToNull()
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetDescription(s)
				}
			}

		case "startDate":
			{
				if v == nil {
					o.SetStartDateToNull()
					continue
				}

				switch d := v.(type) {
				case json.Number:
					// a numeric value, which for JSON, means milliseconds since epoc
					n2, err := d.Int64()
					if err != nil {
						return err
					}
					o.SetStartDate(time.UnixMilli(n2).UTC())
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetStartDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetStartDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}

		case "endDate":
			{
				if v == nil {
					o.SetEndDateToNull()
					continue
				}

				switch d := v.(type) {
				case json.Number:
					// a numeric value, which for JSON, means milliseconds since epoc
					n2, err := d.Int64()
					if err != nil {
						return err
					}
					o.SetEndDate(time.UnixMilli(n2).UTC())
				case float64:
					// a numeric value, which for JSON, means milliseconds since epoc
					o.SetEndDate(time.UnixMilli(int64(d)).UTC())
				case string:
					// an ISO8601 string (hopefully)
					var t time.Time
					err = t.UnmarshalJSON([]byte(`"` + d + `"`))
					if err != nil {
						return fmt.Errorf("JSON format error for time field %s: %w", k, err)
					}
					t = t.UTC()
					o.SetEndDate(t)
				default:
					return fmt.Errorf("json field %s must be a number or a string", k)
				}
			}

		case "budget":
			{
				if v == nil {
					o.SetBudgetToNull()
					continue
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetBudget(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetBudget(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}

		case "spent":
			{
				if v == nil {
					o.SetSpentToNull()
					continue
				}

				switch d := v.(type) {
				case string:
					{
						// A base 64 encoded string
						if b, err2 := base64.StdEncoding.DecodeString(d); err2 == nil {
							o.SetSpent(b)
						} else {
							return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
						}
					}
				case []interface{}:
					{
						// An array of byte values. Unfortunately, these come through as float64s, and so need to be converted
						b := make([]byte, len(d), len(d))
						for i, b1 := range d {
							if f, ok := b1.(float64); !ok {
								return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
							} else {
								b[i] = uint8(f)
							}
						}
						o.SetSpent(b)
					}
				default:
					return fmt.Errorf("json field %s must be either a Base64 encoded string or an array of byte values", k)
				}

			}

		case "parentProjectID":
			{
				if v == nil {
					o.SetParentProjectIDToNull()
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("field %s must be a string", k)
				} else {
					o.SetParentProjectID(s)
				}

			}

		}
	}
	return
}
