// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"time"
	"unicode/utf8"

	"github.com/goradd/anyutil"
	"github.com/goradd/orm/_test/gen/orm/goradd/node"
	"github.com/goradd/orm/pkg/broadcast"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/query"
)

// LoginBase is embedded in a Login object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the Login embedder.
// Instead, use the accessor functions.
type loginBase struct {
	id                string
	idIsLoaded        bool
	idIsDirty         bool
	username          string
	usernameIsLoaded  bool
	usernameIsDirty   bool
	password          string
	passwordIsNull    bool
	passwordIsLoaded  bool
	passwordIsDirty   bool
	isEnabled         bool
	isEnabledIsLoaded bool
	isEnabledIsDirty  bool
	personID          string
	personIDIsLoaded  bool
	personIDIsDirty   bool

	// References
	person *Person

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

	_originalPK string
}

// IDs used to access the Login object fields by name using the Get function.
// doc: type=Login
const (
	LoginIDField        = `id`
	LoginUsernameField  = `username`
	LoginPasswordField  = `password`
	LoginIsEnabledField = `isEnabled`
	LoginPersonIDField  = `personID`
	LoginPersonField    = `person`
)

const LoginIDMaxLength = 32       // The number of runes the column can hold
const LoginUsernameMaxLength = 20 // The number of runes the column can hold
const LoginPasswordMaxLength = 20 // The number of runes the column can hold
const LoginPersonIDMaxLength = 32 // The number of runes the column can hold

// Initialize or re-initialize a Login database object to default values.
// The primary key will get a temporary unique value which will be replaced when the object is saved.
func (o *loginBase) Initialize() {
	o.id = db.TemporaryPrimaryKey()
	o.idIsLoaded = true
	o.idIsDirty = false

	o.username = ""
	o.usernameIsLoaded = false
	o.usernameIsDirty = false

	o.password = ""
	o.passwordIsNull = true
	o.passwordIsLoaded = false
	o.passwordIsDirty = false

	o.isEnabled = true
	o.isEnabledIsLoaded = true
	o.isEnabledIsDirty = false

	o.personID = ""
	o.personIDIsLoaded = false
	o.personIDIsDirty = false

	o._aliases = nil
	o._restored = false
}

// Copy copies most fields to a new Login object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Automatically generated fields will not be included in the copy.
// The primary key field will not be copied, since it is normally auto-generated.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *loginBase) Copy() (newObject *Login) {
	newObject = NewLogin()
	if o.idIsLoaded {
		newObject.SetID(o.id)
	}
	if o.usernameIsLoaded {
		newObject.SetUsername(o.username)
	}
	if o.passwordIsLoaded {
		newObject.SetPassword(o.password)
	}
	if o.isEnabledIsLoaded {
		newObject.SetIsEnabled(o.isEnabled)
	}
	if o.personIDIsLoaded {
		newObject.SetPersonID(o.personID)
	}
	return
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *loginBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// PrimaryKey returns the value of the primary key of the record.
func (o *loginBase) PrimaryKey() string {
	if o._restored && !o.idIsLoaded {
		panic("ID was not selected in the last query and has not been set, and so PrimaryKey is not valid")
	}
	return o.id
}

// SetPrimaryKey sets the value of the primary key in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the primary key value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *loginBase) SetPrimaryKey(v string) {
	if o._restored {
		panic("error: Do not change a primary key for a record that has been saved. Instead, save a copy and delete the original.")
	}
	if utf8.RuneCountInString(v) > LoginIDMaxLength {
		panic("attempted to set Login.ID to a value larger than its maximum length in runes")
	}
	o.idIsLoaded = true
	o.idIsDirty = true
	o.id = v
}

// ID returns the value of ID.
func (o *loginBase) ID() string {
	return o.PrimaryKey()
}

// IDIsLoaded returns true if the value was loaded from the database or has been set.
func (o *loginBase) IDIsLoaded() bool {
	return o.idIsLoaded
}

// SetID sets the value of ID in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the ID value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *loginBase) SetID(v string) {
	o.SetPrimaryKey(v)
}

// Username returns the value of Username.
func (o *loginBase) Username() string {
	if o._restored && !o.usernameIsLoaded {
		panic("Username was not selected in the last query and has not been set, and so is not valid")
	}
	return o.username
}

// UsernameIsLoaded returns true if the value was loaded from the database or has been set.
func (o *loginBase) UsernameIsLoaded() bool {
	return o.usernameIsLoaded
}

// SetUsername sets the value of Username in the object, to be saved later in the database using the Save() function.
func (o *loginBase) SetUsername(v string) {
	if utf8.RuneCountInString(v) > LoginUsernameMaxLength {
		panic("attempted to set Login.Username to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.usernameIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.username == v {
		// no change
		return
	}

	o.usernameIsLoaded = true
	o.username = v
	o.usernameIsDirty = true
}

// Password returns the value of Password.
func (o *loginBase) Password() string {
	if o._restored && !o.passwordIsLoaded {
		panic("Password was not selected in the last query and has not been set, and so is not valid")
	}
	return o.password
}

// PasswordIsLoaded returns true if the value was loaded from the database or has been set.
func (o *loginBase) PasswordIsLoaded() bool {
	return o.passwordIsLoaded
}

// PasswordIsNull returns true if the related database value is null.
func (o *loginBase) PasswordIsNull() bool {
	return o.passwordIsNull
}

// SetPassword sets the value of Password in the object, to be saved later in the database using the Save() function.
func (o *loginBase) SetPassword(v string) {
	if utf8.RuneCountInString(v) > LoginPasswordMaxLength {
		panic("attempted to set Login.Password to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.passwordIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.passwordIsNull && // if the db value is null, force a set of value
		o.password == v {
		// no change
		return
	}

	o.passwordIsLoaded = true
	o.password = v
	o.passwordIsDirty = true
	o.passwordIsNull = false
}

// SetPasswordToNull() will set the password value in the database to NULL.
// Password() will return the column's default value after this.
func (o *loginBase) SetPasswordToNull() {
	if !o.passwordIsLoaded || !o.passwordIsNull {
		// If we know it is null in the database, don't save it
		o.passwordIsDirty = true
	}
	o.passwordIsLoaded = true
	o.passwordIsNull = true
	o.password = ""
}

// IsEnabled returns the value of IsEnabled.
func (o *loginBase) IsEnabled() bool {
	if o._restored && !o.isEnabledIsLoaded {
		panic("IsEnabled was not selected in the last query and has not been set, and so is not valid")
	}
	return o.isEnabled
}

// IsEnabledIsLoaded returns true if the value was loaded from the database or has been set.
func (o *loginBase) IsEnabledIsLoaded() bool {
	return o.isEnabledIsLoaded
}

// SetIsEnabled sets the value of IsEnabled in the object, to be saved later in the database using the Save() function.
func (o *loginBase) SetIsEnabled(v bool) {
	if o._restored &&
		o.isEnabledIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.isEnabled == v {
		// no change
		return
	}

	o.isEnabledIsLoaded = true
	o.isEnabled = v
	o.isEnabledIsDirty = true
}

// PersonID returns the value of PersonID.
func (o *loginBase) PersonID() string {
	if o._restored && !o.personIDIsLoaded {
		panic("PersonID was not selected in the last query and has not been set, and so is not valid")
	}
	return o.personID
}

// PersonIDIsLoaded returns true if the value was loaded from the database or has been set.
func (o *loginBase) PersonIDIsLoaded() bool {
	return o.personIDIsLoaded
}

// SetPersonID sets the value of PersonID in the object, to be saved later in the database using the Save() function.
func (o *loginBase) SetPersonID(v string) {
	if utf8.RuneCountInString(v) > LoginPersonIDMaxLength {
		panic("attempted to set Login.PersonID to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.personIDIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.personID == v {
		// no change
		return
	}

	o.personIDIsLoaded = true
	o.personID = v
	o.personIDIsDirty = true
	if o.person != nil &&
		o.personID != o.person.PrimaryKey() {
		o.person = nil
	}
}

// Person returns the current value of the loaded Person, and nil if its not loaded.
func (o *loginBase) Person() *Person {
	return o.person
}

// LoadPerson returns the related Person. If it is not already loaded,
// it will attempt to load it, provided the PersonID column has been loaded first.
func (o *loginBase) LoadPerson(ctx context.Context) (*Person, error) {
	var err error

	if o.person == nil {
		if !o.personIDIsLoaded {
			panic("PersonID must be selected in the previous query")
		}
		// Load and cache
		o.person, err = LoadPerson(ctx, o.personID)
	}
	return o.person, err
}

// SetPerson sets the value of Person in the object, to be saved later using the Save() function.
func (o *loginBase) SetPerson(person *Person) {
	if person == nil {
		panic("Cannot set Person to a nil value since PersonID is not nullable.")
	} else {
		o.person = person
		o.personIDIsLoaded = true
		if o.personID != person.PrimaryKey() {
			o.personID = person.PrimaryKey()
			o.personIDIsDirty = true
		}
	}
}

// GetAlias returns the value for the Alias node aliasKey that was returned in the most
// recent query.
func (o *loginBase) GetAlias(aliasKey string) query.AliasValue {
	if a, ok := o._aliases[aliasKey]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + aliasKey + " not found.")
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *loginBase) IsNew() bool {
	return !o._restored
}

// LoadLogin returns a Login from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [LoginsBuilder.Select] for more info.
func LoadLogin(ctx context.Context, pk string, selectNodes ...query.Node) (*Login, error) {
	return queryLogins(ctx).
		Where(op.Equal(node.Login().ID(), pk)).
		Select(selectNodes...).
		Get()
}

// HasLogin returns true if a Login with the given primary key exists in the database.
// doc: type=Login
func HasLogin(ctx context.Context, pk string) (bool, error) {
	v, err := queryLogins(ctx).
		Where(op.Equal(node.Login().ID(), pk)).
		Count()
	return v > 0, err
}

// LoadLoginByUsername queries for a single Login object by the given unique index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [LoginsBuilder.Select].
// If you need a more elaborate query, use QueryLogins() to start a query builder.
func LoadLoginByUsername(ctx context.Context, username string, selectNodes ...query.Node) (*Login, error) {
	q := queryLogins(ctx)
	q = q.Where(op.Equal(node.Login().Username(), username))
	return q.Select(selectNodes...).Get()
}

// HasLoginByUsername returns true if the
// given unique index values exist in the database.
// doc: type=Login
func HasLoginByUsername(ctx context.Context, username string) (bool, error) {
	q := queryLogins(ctx)
	q = q.Where(op.Equal(node.Login().Username(), username))
	v, err := q.Count()
	return v > 0, err
}

// LoadLoginByPersonID queries for a single Login object by the given unique index values.
// selectNodes optionally let you provide nodes for joining to other tables or selecting specific fields.
// See [LoginsBuilder.Select].
// If you need a more elaborate query, use QueryLogins() to start a query builder.
func LoadLoginByPersonID(ctx context.Context, personID string, selectNodes ...query.Node) (*Login, error) {
	q := queryLogins(ctx)
	q = q.Where(op.Equal(node.Login().PersonID(), personID))
	return q.Select(selectNodes...).Get()
}

// HasLoginByPersonID returns true if the
// given unique index values exist in the database.
// doc: type=Login
func HasLoginByPersonID(ctx context.Context, personID string) (bool, error) {
	q := queryLogins(ctx)
	q = q.Where(op.Equal(node.Login().PersonID(), personID))
	v, err := q.Count()
	return v > 0, err
}

// The LoginBuilder uses a builder pattern to create a query on the database.
// Create a LoginBuilder by calling QueryLogins, which will select all
// the Login object in the database. Then filter and arrange those objects
// by calling Where, Select, etc.
// End a query by calling either Load, LoadI, LoadCursor, Get, or Count.
// A LoginBuilder stores the context it will use to perform the query, and thus is
// meant to be a short-lived object. You should not save it for later use.
type LoginBuilder struct {
	builder *query.Builder
	ctx     context.Context
}

func newLoginBuilder(ctx context.Context) *LoginBuilder {
	b := LoginBuilder{
		builder: query.NewBuilder(node.Login()),
		ctx:     ctx,
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of Login objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *LoginBuilder) Load() (logins []*Login, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any

	ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Login)
		o.unpack(item, o)
		logins = append(logins, o)
	}
	return
}

// LoadI terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a variety of interfaces that load arrays of objects, including KeyLabeler.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *LoginBuilder) LoadI() (logins []query.OrmObj, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any

	ctx := b.ctx
	results, err = database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Login)
		o.unpack(item, o)
		logins = append(logins, o)
	}
	return
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *LoginBuilder) LoadCursor() (loginsCursor, error) {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd")
	result, err := database.BuilderQuery(b.ctx, b.builder)
	var cursor query.CursorI
	if result != nil {
		cursor = result.(query.CursorI)
	}
	return loginsCursor{cursor}, err
}

type loginsCursor struct {
	query.CursorI
}

// Next returns the current Login object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c loginsCursor) Next() (*Login, error) {
	if c.CursorI == nil {
		return nil, nil
	}

	row, err := c.CursorI.Next()
	if row == nil || err != nil {
		return nil, err
	}
	o := new(Login)
	o.unpack(row, o)
	return o, nil
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
// If an error occurs, or no results are found, a nil is returned.
func (b *LoginBuilder) Get() (*Login, error) {
	results, err := b.Load()
	if err != nil || len(results) == 0 {
		return nil, err
	}
	return results[0], nil
}

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *LoginBuilder) Where(c query.Node) *LoginBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *LoginBuilder) OrderBy(nodes ...query.Sorter) *LoginBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *LoginBuilder) Limit(maxRowCount int, offset int) *LoginBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the login table will be queried and loaded.
// If nodes contains columns from the login table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *LoginBuilder) Select(nodes ...query.Node) *LoginBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *LoginBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) *LoginBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *LoginBuilder) Distinct() *LoginBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *LoginBuilder) GroupBy(nodes ...query.Node) *LoginBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *LoginBuilder) Having(node query.Node) *LoginBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *LoginBuilder) Count() (int, error) {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd")

	ctx := b.ctx
	results, err := database.BuilderQuery(ctx, b.builder)
	if results == nil || err != nil {
		return 0, err
	}
	return results.(int), nil
}

// CountLogins returns the total number of items in the login table.
func CountLogins(ctx context.Context) (int, error) {
	return QueryLogins(ctx).Count()
}

// CountLoginsByUsername queries the database and returns the number of Login objects that
// have username.
// doc: type=Login
func CountLoginsByUsername(ctx context.Context, username string) (int, error) {
	v_username := username
	return QueryLogins(ctx).
		Where(op.Equal(node.Login().Username(), v_username)).
		Count()
}

// CountLoginsByPersonID queries the database and returns the number of Login objects that
// have personID.
// doc: type=Login
func CountLoginsByPersonID(ctx context.Context, personID string) (int, error) {
	v_personID := personID
	return QueryLogins(ctx).
		Where(op.Equal(node.Login().PersonID(), v_personID)).
		Count()
}

// unpack recursively transforms data coming from the database into ORM objects.
func (o *loginBase) unpack(m map[string]interface{}, objThis *Login) {

	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsLoaded = true
			o.idIsDirty = false
			o._originalPK = o.id
		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsLoaded = false
		o.id = ""
		o.idIsDirty = false
	}

	if v, ok := m["username"]; ok && v != nil {
		if o.username, ok = v.(string); ok {
			o.usernameIsLoaded = true
			o.usernameIsDirty = false
		} else {
			panic("Wrong type found for username.")
		}
	} else {
		o.usernameIsLoaded = false
		o.username = ""
		o.usernameIsDirty = false
	}

	if v, ok := m["password"]; ok {
		if v == nil {
			o.password = ""
			o.passwordIsNull = true
			o.passwordIsLoaded = true
			o.passwordIsDirty = false
		} else if o.password, ok = v.(string); ok {
			o.passwordIsNull = false
			o.passwordIsLoaded = true
			o.passwordIsDirty = false
		} else {
			panic("Wrong type found for password.")
		}
	} else {
		o.passwordIsLoaded = false
		o.passwordIsNull = true
		o.password = ""
		o.passwordIsDirty = false
	}

	if v, ok := m["is_enabled"]; ok && v != nil {
		if o.isEnabled, ok = v.(bool); ok {
			o.isEnabledIsLoaded = true
			o.isEnabledIsDirty = false
		} else {
			panic("Wrong type found for is_enabled.")
		}
	} else {
		o.isEnabledIsLoaded = false
		o.isEnabled = true
		o.isEnabledIsDirty = false
	}

	if v, ok := m["person_id"]; ok && v != nil {
		if o.personID, ok = v.(string); ok {
			o.personIDIsLoaded = true
			o.personIDIsDirty = false
		} else {
			panic("Wrong type found for person_id.")
		}
	} else {
		o.personIDIsLoaded = false
		o.personID = ""
		o.personIDIsDirty = false
	}

	if v, ok := m["person"]; ok {
		if person, ok2 := v.(map[string]any); ok2 {
			o.person = new(Person)
			o.person.unpack(person, o.person)
			o.personIDIsLoaded = true
			o.personIDIsDirty = false
		} else {
			panic("Wrong type found for Person object.")
		}
	} else {
		o.person = nil
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}

// save will update or insert the object, depending on the state of the object.
func (o *loginBase) save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *loginBase) update(ctx context.Context) error {
	if !o._restored {
		panic("cannot update a record that was not originally read from the database.")
	}
	if !o.IsDirty() {
		return nil // nothing to save
	}

	var modifiedFields map[string]interface{}

	d := Database()
	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()
	err := db.WithTransaction(ctx, d, func(ctx context.Context) error {
		// Save loaded Person object to get its new pk and update it here.
		if o.person != nil {
			if err := o.person.Save(ctx); err != nil {
				return err
			}
			o.SetPersonID(o.person.PrimaryKey())
		}

		modifiedFields = getLoginUpdateFields(o)
		if len(modifiedFields) != 0 {
			err2 := d.Update(ctx, "login",
				map[string]any{
					"id": o._originalPK,
				},
				modifiedFields,
				"",
				0,
			)
			if err2 != nil {
				return err2
			}
		}

		return nil
	}) // transaction
	if err != nil {
		return err
	}

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd", "login", o._originalPK, anyutil.SortedKeys(modifiedFields)...)
	}

	return nil
}

// insert will insert the object into the database. Related items will be saved.
func (o *loginBase) insert(ctx context.Context) (err error) {
	var insertFields map[string]interface{}
	d := Database()

	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	err = db.WithTransaction(ctx, d, func(ctx context.Context) error {
		// Save loaded Person object to get its new pk and update it here.
		if o.person != nil {
			if err := o.person.Save(ctx); err != nil {
				return err
			}
			o.SetPersonID(o.person.PrimaryKey())
		}
		if !o.usernameIsLoaded {
			panic("a value for Username is required, and there is no default value. Call SetUsername() before inserting the record.")
		}
		if !o.isEnabledIsLoaded {
			panic("a value for IsEnabled is required, and there is no default value. Call SetIsEnabled() before inserting the record.")
		}
		if !o.personIDIsLoaded {
			panic("a value for PersonID is required, and there is no default value. Call SetPersonID() before inserting the record.")
		}
		insertFields = getLoginInsertFields(o)
		var newPK string
		newPK, err = d.Insert(ctx, "login", "id", insertFields)
		if err != nil {
			return err
		}
		o.id = newPK
		o._originalPK = newPK
		o.idIsLoaded = true

		return nil

	}) // transaction

	if err != nil {
		return
	}

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "login", o.PrimaryKey())
	return
}

// getUpdateFields returns the database columns that will be sent to the update process.
// This will include timestamp fields only if some other column has changed.
func (o *loginBase) getUpdateFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}
	if o.usernameIsDirty {
		fields["username"] = o.username
	}
	if o.passwordIsDirty {
		if o.passwordIsNull {
			fields["password"] = nil
		} else {
			fields["password"] = o.password
		}
	}
	if o.isEnabledIsDirty {
		fields["is_enabled"] = o.isEnabled
	}
	if o.personIDIsDirty {
		fields["person_id"] = o.personID
	}
	return
}

// getInsertFields returns the fields that will be specified in an insert operation.
// Optional fields that have not been set and have no default will be returned as nil.
// NoSql databases should interpret this as no value. Sql databases should interpret this as
// explicitly setting a NULL value, which would override any database specific default value.
// Auto-generated fields will be returned with their generated values, except AutoPK fields, which are generated by the
// database driver and updated after the insert.
func (o *loginBase) getInsertFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}

	fields["username"] = o.username
	if o.passwordIsNull {
		fields["password"] = nil
	} else {
		fields["password"] = o.password
	}

	fields["is_enabled"] = o.isEnabled

	fields["person_id"] = o.personID
	return
}

// Delete deletes the record from the database.
func (o *loginBase) Delete(ctx context.Context) (err error) {
	if o == nil {
		return // allow deleting of a nil object to be a noop
	}
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()
	err = d.Delete(ctx, "login",
		map[string]any{
			"id": o._originalPK,
		},
		"",
		0,
	)
	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd", "login", o._originalPK)
	return
}

// deleteLogin deletes the Login with primary key pk from the database
// and handles associated records.
func deleteLogin(ctx context.Context, pk string) error {
	d := db.GetDatabase("goradd")
	err := d.Delete(ctx, "login",
		map[string]any{
			"id": pk,
		},
		"", 0)

	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd", "login", pk)
	return err
}

// resetDirtyStatus resets the dirty status of every field in the object.
func (o *loginBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.usernameIsDirty = false
	o.passwordIsDirty = false
	o.isEnabledIsDirty = false
	o.personIDIsDirty = false

}

// IsDirty returns true if the object has been changed since it was read from the database or created.
func (o *loginBase) IsDirty() (dirty bool) {
	dirty = o.idIsDirty ||
		o.usernameIsDirty ||
		o.passwordIsDirty ||
		o.isEnabledIsDirty ||
		o.personIDIsDirty

	dirty = dirty ||
		o.person != nil && o.person.IsDirty()

	return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil.
// Get can be used to retrieve a value by using the Field() of a node.
func (o *loginBase) Get(key string) interface{} {
	switch key {
	case LoginIDField:
		if !o.idIsLoaded {
			return nil
		}
		return o.id
	case LoginUsernameField:
		if !o.usernameIsLoaded {
			return nil
		}
		return o.username
	case LoginPasswordField:
		if !o.passwordIsLoaded {
			return nil
		}
		return o.password
	case LoginIsEnabledField:
		if !o.isEnabledIsLoaded {
			return nil
		}
		return o.isEnabled
	case LoginPersonIDField:
		if !o.personIDIsLoaded {
			return nil
		}
		return o.personID
	case LoginPersonField:
		return o.Person()
	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *loginBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	enc := gob.NewEncoder(buf)
	if err := o.encodeTo(enc); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (o *loginBase) encodeTo(enc db.Encoder) error {

	if err := enc.Encode(o.id); err != nil {
		return fmt.Errorf("error encoding Login.id: %w", err)
	}
	if err := enc.Encode(o.idIsLoaded); err != nil {
		return fmt.Errorf("error encoding Login.idIsLoaded: %w", err)
	}
	if err := enc.Encode(o.idIsDirty); err != nil {
		return fmt.Errorf("error encoding Login.idIsDirty: %w", err)
	}

	if err := enc.Encode(o.username); err != nil {
		return fmt.Errorf("error encoding Login.username: %w", err)
	}
	if err := enc.Encode(o.usernameIsLoaded); err != nil {
		return fmt.Errorf("error encoding Login.usernameIsLoaded: %w", err)
	}
	if err := enc.Encode(o.usernameIsDirty); err != nil {
		return fmt.Errorf("error encoding Login.usernameIsDirty: %w", err)
	}

	if err := enc.Encode(o.password); err != nil {
		return fmt.Errorf("error encoding Login.password: %w", err)
	}
	if err := enc.Encode(o.passwordIsNull); err != nil {
		return fmt.Errorf("error encoding Login.passwordIsNull: %w", err)
	}
	if err := enc.Encode(o.passwordIsLoaded); err != nil {
		return fmt.Errorf("error encoding Login.passwordIsLoaded: %w", err)
	}
	if err := enc.Encode(o.passwordIsDirty); err != nil {
		return fmt.Errorf("error encoding Login.passwordIsDirty: %w", err)
	}

	if err := enc.Encode(o.isEnabled); err != nil {
		return fmt.Errorf("error encoding Login.isEnabled: %w", err)
	}
	if err := enc.Encode(o.isEnabledIsLoaded); err != nil {
		return fmt.Errorf("error encoding Login.isEnabledIsLoaded: %w", err)
	}
	if err := enc.Encode(o.isEnabledIsDirty); err != nil {
		return fmt.Errorf("error encoding Login.isEnabledIsDirty: %w", err)
	}

	if err := enc.Encode(o.personID); err != nil {
		return fmt.Errorf("error encoding Login.personID: %w", err)
	}
	if err := enc.Encode(o.personIDIsLoaded); err != nil {
		return fmt.Errorf("error encoding Login.personIDIsLoaded: %w", err)
	}
	if err := enc.Encode(o.personIDIsDirty); err != nil {
		return fmt.Errorf("error encoding Login.personIDIsDirty: %w", err)
	}

	if o.person == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o.person); err != nil {
			return fmt.Errorf("error encoding Login.person: %w", err)
		}
	}

	if o._aliases == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o._aliases); err != nil {
			return fmt.Errorf("error encoding Login._aliases: %w", err)
		}
	}

	if err := enc.Encode(o._restored); err != nil {
		return fmt.Errorf("error encoding Login._restored: %w", err)
	}
	if err := enc.Encode(o._originalPK); err != nil {
		return fmt.Errorf("error encoding Login._originalPK: %w", err)
	}
	return nil
}

// UnmarshalBinary converts a structure that was created with MarshalBinary into a Login object.
func (o *loginBase) UnmarshalBinary(data []byte) (err error) {
	buf := bytes.NewReader(data)
	dec := gob.NewDecoder(buf)
	return o.decodeFrom(dec)
}

func (o *loginBase) decodeFrom(dec db.Decoder) (err error) {
	var isPtr bool

	_ = isPtr
	if err = dec.Decode(&o.id); err != nil {
		return fmt.Errorf("error decoding Login.id: %w", err)
	}
	if err = dec.Decode(&o.idIsLoaded); err != nil {
		return fmt.Errorf("error decoding Login.idIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return fmt.Errorf("error decoding Login.idIsDirty: %w", err)
	}

	if err = dec.Decode(&o.username); err != nil {
		return fmt.Errorf("error decoding Login.username: %w", err)
	}
	if err = dec.Decode(&o.usernameIsLoaded); err != nil {
		return fmt.Errorf("error decoding Login.usernameIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.usernameIsDirty); err != nil {
		return fmt.Errorf("error decoding Login.usernameIsDirty: %w", err)
	}

	if err = dec.Decode(&o.password); err != nil {
		return fmt.Errorf("error decoding Login.password: %w", err)
	}
	if err = dec.Decode(&o.passwordIsNull); err != nil {
		return fmt.Errorf("error decoding Login.passwordIsNull: %w", err)
	}
	if err = dec.Decode(&o.passwordIsLoaded); err != nil {
		return fmt.Errorf("error decoding Login.passwordIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.passwordIsDirty); err != nil {
		return fmt.Errorf("error decoding Login.passwordIsDirty: %w", err)
	}

	if err = dec.Decode(&o.isEnabled); err != nil {
		return fmt.Errorf("error decoding Login.isEnabled: %w", err)
	}
	if err = dec.Decode(&o.isEnabledIsLoaded); err != nil {
		return fmt.Errorf("error decoding Login.isEnabledIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.isEnabledIsDirty); err != nil {
		return fmt.Errorf("error decoding Login.isEnabledIsDirty: %w", err)
	}

	if err = dec.Decode(&o.personID); err != nil {
		return fmt.Errorf("error decoding Login.personID: %w", err)
	}
	if err = dec.Decode(&o.personIDIsLoaded); err != nil {
		return fmt.Errorf("error decoding Login.personIDIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.personIDIsDirty); err != nil {
		return fmt.Errorf("error decoding Login.personIDIsDirty: %w", err)
	}

	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Login.person isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.person); err != nil {
			return fmt.Errorf("error decoding Login.person: %w", err)
		}
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Login._aliases isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o._aliases); err != nil {
			return fmt.Errorf("error decoding Login._aliases: %w", err)
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return fmt.Errorf("error decoding Login._restored: %w", err)
	}
	if err = dec.Decode(&o._originalPK); err != nil {
		return fmt.Errorf("error decoding Login._originalPK: %w", err)
	}
	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *loginBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *loginBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsLoaded {
		v["id"] = o.id
	}

	if o.usernameIsLoaded {
		v["username"] = o.username
	}

	if o.passwordIsLoaded {
		if o.passwordIsNull {
			v["password"] = nil
		} else {
			v["password"] = o.password
		}
	}

	if o.isEnabledIsLoaded {
		v["isEnabled"] = o.isEnabled
	}

	if o.personIDIsLoaded {
		v["personID"] = o.personID
	}

	if val := o.person; val != nil {
		v["person"] = val.MarshalStringMap()
	}
	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the Login. The Login can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//
//	"id" - string
//	"username" - string
//	"password" - string, nullable
//	"isEnabled" - bool
func (o *loginBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if len(data) == 0 {
		return
	}
	d := json.NewDecoder(bytes.NewReader(data))
	d.UseNumber() // use a number to avoid precision errors
	if err = d.Decode(&v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in Login to modify the json before sending it here.
func (o *loginBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {

		case "id":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetID(s)
				}
			}
		case "username":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetUsername(s)
				}
			}
		case "password":
			{
				if v == nil {
					o.SetPasswordToNull()
					continue
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetPassword(s)
				}
			}
		case "isEnabled":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if b, ok := v.(bool); !ok {
					return fmt.Errorf("json field %s must be a boolean", k)
				} else {
					o.SetIsEnabled(b)
				}
			}
		case "personID":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if _, ok := m["person"]; ok {
					continue // importing the foreign key will remove the object
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetPersonID(s)
				}
			}

		case "person":
			v2 := NewPerson()
			m2, ok := v.(map[string]any)
			if !ok {
				return fmt.Errorf("json field %s must be a map", k)
			}
			err = v2.UnmarshalStringMap(m2)
			if err != nil {
				return
			}
			o.SetPerson(v2)

		}
	}
	return
}
