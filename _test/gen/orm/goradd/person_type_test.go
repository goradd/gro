// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestPersonType_String(t *testing.T) {
	assert.Equal(t, PersonTypeContractor.String(), PersonTypeContractor.Identifier())
	assert.Equal(t, PersonTypeManager.String(), PersonTypeManager.Identifier())
	assert.Equal(t, PersonTypeInactive.String(), PersonTypeInactive.Identifier())
	assert.Equal(t, PersonTypeCompanyCar.String(), PersonTypeCompanyCar.Identifier())
	assert.Equal(t, PersonTypeWorksFromHome.String(), PersonTypeWorksFromHome.Identifier())
}

func TestPersonType_Label(t *testing.T) {
	assert.Equal(t, PersonTypeContractor.Label(), "Contractor")
	assert.Equal(t, PersonTypeManager.Label(), "Manager")
	assert.Equal(t, PersonTypeInactive.Label(), "Inactive")
	assert.Equal(t, PersonTypeCompanyCar.Label(), "Company Car")
	assert.Equal(t, PersonTypeWorksFromHome.Label(), "Works From Home")
	assert.Zero(t, PersonType(0).Label())
	assert.Panics(t, func() {
		PersonType(-1).Label()
	})
}

func TestPersonType_LabelSlice(t *testing.T) {
	a := PersonTypeLabels()
	assert.Equal(t, PersonTypeContractor.Label(), a[0])
	assert.Equal(t, PersonTypeManager.Label(), a[1])
	assert.Equal(t, PersonTypeInactive.Label(), a[2])
	assert.Equal(t, PersonTypeCompanyCar.Label(), a[3])
	assert.Equal(t, PersonTypeWorksFromHome.Label(), a[4])
}

func TestPersonType_Identifier(t *testing.T) {
	assert.Equal(t, PersonTypeContractor.Identifier(), "contractor")
	assert.Equal(t, PersonTypeManager.Identifier(), "manager")
	assert.Equal(t, PersonTypeInactive.Identifier(), "inactive")
	assert.Equal(t, PersonTypeCompanyCar.Identifier(), "company_car")
	assert.Equal(t, PersonTypeWorksFromHome.Identifier(), "works_from_home")
	assert.Zero(t, PersonType(0).Identifier())
	assert.Panics(t, func() {
		PersonType(-1).Identifier()
	})
}

func TestPersonType_IdentifierSlice(t *testing.T) {
	a := PersonTypeIdentifiers()
	assert.Equal(t, PersonTypeContractor.Identifier(), a[0])
	assert.Equal(t, PersonTypeManager.Identifier(), a[1])
	assert.Equal(t, PersonTypeInactive.Identifier(), a[2])
	assert.Equal(t, PersonTypeCompanyCar.Identifier(), a[3])
	assert.Equal(t, PersonTypeWorksFromHome.Identifier(), a[4])
}

func TestPersonType_Keys(t *testing.T) {
	var keys []string

	keys = append(keys, PersonTypeContractor.Key())
	keys = append(keys, PersonTypeManager.Key())
	keys = append(keys, PersonTypeInactive.Key())
	keys = append(keys, PersonTypeCompanyCar.Key())
	keys = append(keys, PersonTypeWorksFromHome.Key())
	v := PersonTypesFromKeys(keys)
	assert.Equal(t, PersonTypes(), v)

	assert.Equal(t, PersonType(0), PersonTypeFromKey(""))
}

func TestPersonType_Values(t *testing.T) {
	a1 := PersonTypes()
	a2 := PersonTypesI()
	for i, v1 := range a1 {
		assert.Equal(t, v1, a2[i].(PersonType))
		assert.True(t, IsValidPersonType(int(v1)))
	}
	assert.False(t, IsValidPersonType(0))
}

func TestPersonType_FromIdentifier(t *testing.T) {
	var v PersonType
	var err error

	v, err = PersonTypeFromIdentifier(PersonType(1).Identifier())
	assert.NoError(t, err)
	assert.Equal(t, PersonType(1), v)
	v, err = PersonTypeFromIdentifier(PersonType(2).Identifier())
	assert.NoError(t, err)
	assert.Equal(t, PersonType(2), v)
	v, err = PersonTypeFromIdentifier(PersonType(3).Identifier())
	assert.NoError(t, err)
	assert.Equal(t, PersonType(3), v)
	v, err = PersonTypeFromIdentifier(PersonType(4).Identifier())
	assert.NoError(t, err)
	assert.Equal(t, PersonType(4), v)
	v, err = PersonTypeFromIdentifier(PersonType(5).Identifier())
	assert.NoError(t, err)
	assert.Equal(t, PersonType(5), v)
}

func TestPersonType_FromInterface(t *testing.T) {
	v := PersonTypeContractor

	v2, err := PersonTypeFromInterface(int(v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(float64(v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(json.Number(fmt.Sprintf("%d", v)))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(fmt.Sprintf("%d", v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(0)
	assert.Error(t, err)
	assert.Equal(t, PersonType(0), v2)

	var t1 time.Time
	v2, err = PersonTypeFromInterface(t1)
	assert.Error(t, err)
	assert.Equal(t, PersonType(0), v2)
}

func TestPersonType_UnmarshalJSON(t *testing.T) {
	tests := []struct {
		input    string
		expected PersonType
		wantErr  bool
	}{
		// Integer JSON
		{input: `1`, expected: PersonTypeContractor, wantErr: false},
		// Float JSON
		{input: `1.0`, expected: PersonTypeContractor, wantErr: false},
		// Stringified numbers
		{input: `"1"`, expected: PersonTypeContractor, wantErr: false},
		// Invalid values
		{input: `"1.1.1"`, expected: PersonType(0), wantErr: true},
	}

	for _, tt := range tests {
		var s PersonType
		err := json.Unmarshal([]byte(tt.input), &s)
		if (err != nil) != tt.wantErr {
			t.Errorf("UnmarshalJSON(%s) error = %v, wantErr %v", tt.input, err, tt.wantErr)
			continue
		}
		if err == nil && s != tt.expected {
			t.Errorf("UnmarshalJSON(%s) = %v, want %v", tt.input, s, tt.expected)
		}
	}
}
