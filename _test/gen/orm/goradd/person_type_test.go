// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestPersonType_String(t *testing.T) {
	assert.Equal(t, PersonTypeContractor.String(), "PersonTypeContractor")
	assert.Equal(t, PersonTypeManager.String(), "PersonTypeManager")
	assert.Equal(t, PersonTypeInactive.String(), "PersonTypeInactive")
	assert.Equal(t, PersonTypeCustomer.String(), "PersonTypeCustomer")
	assert.Equal(t, PersonTypeVendor.String(), "PersonTypeVendor")
}

func TestPersonType_Keys(t *testing.T) {
	var keys []string

	keys = append(keys, PersonTypeContractor.Key())
	keys = append(keys, PersonTypeManager.Key())
	keys = append(keys, PersonTypeInactive.Key())
	keys = append(keys, PersonTypeCustomer.Key())
	keys = append(keys, PersonTypeVendor.Key())
	v := PersonTypesFromKeys(keys)
	assert.Equal(t, PersonTypes(), v)

	assert.Equal(t, PersonType(0), PersonTypeFromKey(""))
}

func TestPersonType_Values(t *testing.T) {
	a1 := PersonTypes()
	a2 := PersonTypesI()
	for i, v1 := range a1 {
		assert.Equal(t, v1, a2[i].(PersonType))
		assert.True(t, IsValidPersonType(int(v1)))
	}
	assert.False(t, IsValidPersonType(0))
}

func TestPersonType_FromKey(t *testing.T) {
	var v PersonType

	v = PersonTypeFromKey(PersonType(1).Key())
	assert.Equal(t, PersonType(1), v)
	v = PersonTypeFromKey(PersonType(2).Key())
	assert.Equal(t, PersonType(2), v)
	v = PersonTypeFromKey(PersonType(3).Key())
	assert.Equal(t, PersonType(3), v)
	v = PersonTypeFromKey(PersonType(4).Key())
	assert.Equal(t, PersonType(4), v)
	v = PersonTypeFromKey(PersonType(5).Key())
	assert.Equal(t, PersonType(5), v)
}

func TestPersonType_FromInterface(t *testing.T) {
	v := PersonTypeContractor

	v2, err := PersonTypeFromInterface(int(v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(float64(v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(json.Number(fmt.Sprintf("%d", v)))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(fmt.Sprintf("%d", v))
	assert.NoError(t, err)
	assert.Equal(t, v, v2)

	v2, err = PersonTypeFromInterface(0)
	assert.Error(t, err)
	assert.Equal(t, PersonType(0), v2)

	var t1 time.Time
	v2, err = PersonTypeFromInterface(t1)
	assert.Error(t, err)
	assert.Equal(t, PersonType(0), v2)
}

func TestPersonType_UnmarshalJSON(t *testing.T) {
	tests := []struct {
		input    string
		expected PersonType
		wantErr  bool
	}{
		// Integer JSON
		{input: `1`, expected: PersonTypeContractor, wantErr: false},
		// Float JSON
		{input: `1.0`, expected: PersonTypeContractor, wantErr: false},
		// Stringified numbers
		{input: `"1"`, expected: PersonTypeContractor, wantErr: false},
		// Invalid values
		{input: `"1.1.1"`, expected: PersonType(0), wantErr: true},
	}

	for _, tt := range tests {
		var s PersonType
		err := json.Unmarshal([]byte(tt.input), &s)
		if (err != nil) != tt.wantErr {
			t.Errorf("UnmarshalJSON(%s) error = %v, wantErr %v", tt.input, err, tt.wantErr)
			continue
		}
		if err == nil && s != tt.expected {
			t.Errorf("UnmarshalJSON(%s) = %v, want %v", tt.input, s, tt.expected)
		}
	}
}
