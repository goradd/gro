// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"encoding/gob"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"

	"github.com/goradd/maps"
)

type PersonType int

const (
	PersonTypeContractor    PersonType = 1
	PersonTypeManager       PersonType = 2
	PersonTypeInactive      PersonType = 3
	PersonTypeCompanyCar    PersonType = 4
	PersonTypeWorksFromHome PersonType = 5
)

// PersonTypeMaxValue is the maximum enumerated value of PersonType
// doc: type=PersonType
const PersonTypeMaxValue = 5

// String returns the name value of the type and satisfies the fmt.Stringer interface
func (e PersonType) String() string {
	return e.Identifier()
}

// IsValidPersonType returns true if i can validly be converted to a PersonType.
func IsValidPersonType(i int) bool {
	switch i {
	case 1:
		return true
	case 2:
		return true
	case 3:
		return true
	case 4:
		return true
	case 5:
		return true
	default:
		return false
	}
}

// Key returns a string representation of the primary key and satisfies KeyLabeler interface
func (e PersonType) Key() string {
	return strconv.Itoa(int(e))
}

// PersonTypeFromKey converts a PersonType Key to a PersonType
func PersonTypeFromKey(key string) PersonType {
	switch key {
	case `1`:
		return PersonTypeContractor
	case `2`:
		return PersonTypeManager
	case `3`:
		return PersonTypeInactive
	case `4`:
		return PersonTypeCompanyCar
	case `5`:
		return PersonTypeWorksFromHome
	}
	return PersonType(0)
}

// PersonTypesFromKeys converts a slice of PersonType Keys to a slice of PersonType
func PersonTypesFromKeys(keys []string) (values []PersonType) {
	values = make([]PersonType, 0, len(keys))
	for _, key := range keys {
		values = append(values, PersonTypeFromKey(key))
	}
	return
}

// PersonTypes returns a slice of all the PersonType values
// in key order.
func PersonTypes() []PersonType {
	return []PersonType{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCompanyCar,
		PersonTypeWorksFromHome,
	}
}

// PersonTypesI returns a slice of all the PersonType values as generic interfaces.
// doc: type=PersonType
func PersonTypesI() (values []any) {
	return []any{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCompanyCar,
		PersonTypeWorksFromHome,
	}
}

func (e PersonType) Label() string {
	switch e {
	case 0:
		return ""
	case PersonTypeContractor:
		return "Contractor"
	case PersonTypeManager:
		return "Manager"
	case PersonTypeInactive:
		return "Inactive"
	case PersonTypeCompanyCar:
		return "Company Car"
	case PersonTypeWorksFromHome:
		return "Works From Home"
	default:
		panic("Index out of range")
	}
}

// PersonTypeLabels returns a slice of all the Label values associated with PersonType.
// doc: type=PersonType
func PersonTypeLabels() []string {
	return []string{
		"Contractor",
		"Manager",
		"Inactive",
		"Company Car",
		"Works From Home",
	}
}

func (e PersonType) Identifier() string {
	switch e {
	case 0:
		return ""
	case PersonTypeContractor:
		return "contractor"
	case PersonTypeManager:
		return "manager"
	case PersonTypeInactive:
		return "inactive"
	case PersonTypeCompanyCar:
		return "company_car"
	case PersonTypeWorksFromHome:
		return "works_from_home"
	default:
		panic("Index out of range")
	}
}

// PersonTypeIdentifiers returns a slice of all the Identifier values associated with PersonType.
// doc: type=PersonType
func PersonTypeIdentifiers() []string {
	return []string{
		"contractor",
		"manager",
		"inactive",
		"company_car",
		"works_from_home",
	}
}

// MarshalJSON converts the type to its identifier for JSON output.
func (e PersonType) MarshalJSON() (data []byte, err error) {
	return json.Marshal(e.String()) // wraps it in quotes like "active"
}

// UnmarshalJSON converts a variety of possible JSON inputs to the enum type.
func (e *PersonType) UnmarshalJSON(data []byte) error {
	var i any
	var err error

	// Use Decoder or json.Unmarshal directly
	if err = json.Unmarshal(data, &i); err != nil {
		return fmt.Errorf("error unmarshaling PersonType: %w", err)
	}
	*e, err = PersonTypeFromInterface(i)
	return err
}

// PersonTypeFromInterface converts a variety of data types to a PersonType.
func PersonTypeFromInterface(i any) (PersonType, error) {
	switch v := i.(type) {
	case float64:
		if IsValidPersonType(int(v)) {
			return PersonType(int(v)), nil
		}
	case int:
		if IsValidPersonType(v) {
			return PersonType(v), nil
		}
	case string:
		// Try to parse as int
		if v2, err := strconv.Atoi(v); err == nil {
			if IsValidPersonType(v2) {
				return PersonType(v2), nil
			}
		}
		// Otherwise convert from the identifier
		return PersonTypeFromIdentifier(v)
	case json.Number:
		if v2, err := v.Int64(); err == nil {
			if IsValidPersonType(int(v2)) {
				return PersonType(int(v2)), nil
			}
		}
	default:
		return PersonType(0), fmt.Errorf("unsupported type for PersonType: %T", v)
	}
	return PersonType(0), errors.New("invalid value for PersonType")
}

func PersonTypeFromIdentifier(i string) (e PersonType, err error) {
	switch i {
	case "contractor":
		return PersonTypeContractor, nil
	case "manager":
		return PersonTypeManager, nil
	case "inactive":
		return PersonTypeInactive, nil
	case "company_car":
		return PersonTypeCompanyCar, nil
	case "works_from_home":
		return PersonTypeWorksFromHome, nil
	default:
		return PersonType(0), fmt.Errorf("PersonType  for %s not found", i)
	}
}

// PersonTypeSet is a pointer to a group of PersonType values.
type PersonTypeSet = *maps.OrderedSet[PersonType]

func NewPersonTypeSet(values ...PersonType) PersonTypeSet {
	return maps.NewOrderedSet[PersonType](values...)
}

func init() {
	gob.Register(new(PersonTypeSet))
}
