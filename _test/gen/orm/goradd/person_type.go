// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"encoding/gob"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"

	"github.com/goradd/maps"
)

type PersonType int

const (
	PersonTypeContractor PersonType = 1
	PersonTypeManager    PersonType = 2
	PersonTypeInactive   PersonType = 3
	PersonTypeCustomer   PersonType = 4
	PersonTypeVendor     PersonType = 5
)

// PersonTypeMaxValue is the maximum enumerated value of PersonType
// doc: type=PersonType
const PersonTypeMaxValue = 5

// String returns the name value of the type and satisfies the fmt.Stringer interface
// This is used primarily for debugging
func (e PersonType) String() string {
	switch e {
	case 1:
		return "PersonTypeContractor"
	case 2:
		return "PersonTypeManager"
	case 3:
		return "PersonTypeInactive"
	case 4:
		return "PersonTypeCustomer"
	case 5:
		return "PersonTypeVendor"
	default:
		return ""
	}
}

// IsValidPersonType returns true if i can validly be converted to a PersonType.
func IsValidPersonType(i int) bool {
	switch i {
	case 1:
		return true
	case 2:
		return true
	case 3:
		return true
	case 4:
		return true
	case 5:
		return true
	default:
		return false
	}
}

// Key returns a string representation of the primary key and satisfies KeyLabeler interface.
func (e PersonType) Key() string {
	// We use string keys so that if the number values change, keys will still relate to to the same conceptual item.
	switch e {
	case PersonTypeContractor:
		return "contractor"
	case PersonTypeManager:
		return "manager"
	case PersonTypeInactive:
		return "inactive"
	case PersonTypeCustomer:
		return "customer"
	case PersonTypeVendor:
		return "vendor"
	}
	return ""
}

// Keys returns all of the items in the enumerated type as string keys.
func (e PersonType) Keys() []string {
	return []string{
		"contractor",
		"manager",
		"inactive",
		"customer",
		"vendor",
	}
}

// PersonTypeFromKey converts a PersonType Key to a PersonType
func PersonTypeFromKey(key string) PersonType {
	switch key {
	case "contractor":
		return PersonTypeContractor
	case "manager":
		return PersonTypeManager
	case "inactive":
		return PersonTypeInactive
	case "customer":
		return PersonTypeCustomer
	case "vendor":
		return PersonTypeVendor
	}
	return PersonType(0)
}

// PersonTypesFromKeys converts a slice of PersonType Keys to a slice of PersonType
func PersonTypesFromKeys(keys []string) (values []PersonType) {
	values = make([]PersonType, 0, len(keys))
	for _, key := range keys {
		values = append(values, PersonTypeFromKey(key))
	}
	return
}

// PersonTypes returns a slice of all the PersonType values
// in key order.
func PersonTypes() []PersonType {
	return []PersonType{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCustomer,
		PersonTypeVendor,
	}
}

// PersonTypesI returns a slice of all the PersonType values as generic interfaces.
// doc: type=PersonType
func PersonTypesI() (values []any) {
	return []any{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCustomer,
		PersonTypeVendor,
	}
}

// PersonTypeLabel returns the Label values associated with PersonType.
func (e PersonType) Label() string {
	switch e {
	case 0:
		return ""
	case PersonTypeContractor:
		return "Contractor"
	case PersonTypeManager:
		return "Manager"
	case PersonTypeInactive:
		return "Inactive"
	case PersonTypeCustomer:
		return "Customer"
	case PersonTypeVendor:
		return "Vendor"
	default:
		panic("index out of range")
	}
}

// PersonTypeLabels returns a slice of all the Label values associated with PersonType.
// doc: type=PersonType
func PersonTypeLabels() []string {
	return []string{
		"Contractor",
		"Manager",
		"Inactive",
		"Customer",
		"Vendor",
	}
}

// MarshalJSON converts the type to its identifier for JSON output.
func (e PersonType) MarshalJSON() (data []byte, err error) {
	return json.Marshal(e.Key()) // wraps it in quotes like "active"
}

// UnmarshalJSON converts a variety of possible JSON inputs to the enum type.
func (e *PersonType) UnmarshalJSON(data []byte) error {
	var i any
	var err error

	// Use Decoder or json.Unmarshal directly
	if err = json.Unmarshal(data, &i); err != nil {
		return fmt.Errorf("error unmarshaling PersonType: %w", err)
	}
	*e, err = PersonTypeFromInterface(i)
	return err
}

// PersonTypeFromInterface converts a variety of data types to a PersonType.
func PersonTypeFromInterface(i any) (PersonType, error) {
	switch v := i.(type) {
	case float64:
		if IsValidPersonType(int(v)) {
			return PersonType(int(v)), nil
		}
	case int:
		if IsValidPersonType(v) {
			return PersonType(v), nil
		}
	case string:
		// Try to parse as int
		if v2, err := strconv.Atoi(v); err == nil {
			if IsValidPersonType(v2) {
				return PersonType(v2), nil
			}
		}
		// Otherwise convert from the identifier
		return PersonTypeFromKey(v)
	case json.Number:
		if v2, err := v.Int64(); err == nil {
			if IsValidPersonType(int(v2)) {
				return PersonType(int(v2)), nil
			}
		}
	default:
		return PersonType(0), fmt.Errorf("unsupported type for PersonType: %T", v)
	}
	return PersonType(0), errors.New("invalid value for PersonType")
}

// PersonTypeSet is a pointer to a group of PersonType values.
type PersonTypeSet = *maps.OrderedSet[PersonType]

func NewPersonTypeSet(values ...PersonType) PersonTypeSet {
	return maps.NewOrderedSet[PersonType](values...)
}

func init() {
	gob.Register(new(PersonTypeSet))
}
