// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"encoding/gob"
	"strconv"

	"github.com/goradd/maps"
	"golang.org/x/exp/constraints"
)

type PersonType int

const (
	PersonTypeContractor    PersonType = 1
	PersonTypeManager       PersonType = 2
	PersonTypeInactive      PersonType = 3
	PersonTypeCompanyCar    PersonType = 4
	PersonTypeWorksFromHome PersonType = 5
)

// PersonTypeMaxValue is the maximum enumerated value of PersonType
// doc: type=PersonType
const PersonTypeMaxValue = 5

// String returns the name value of the type and satisfies the fmt.Stringer interface
func (e PersonType) String() string {
	return e.Name()
}

// Title returns the publicly visible description of the value.
func (e PersonType) Title() string {
	switch e {
	case 0:
		return ""
	case PersonTypeContractor:
		return `Contractor`
	case PersonTypeManager:
		return `Manager`
	case PersonTypeInactive:
		return `Inactive`
	case PersonTypeCompanyCar:
		return `Company Car`
	case PersonTypeWorksFromHome:
		return `Works From Home`
	default:
		panic("index out of range")
	}
	return "" // prevent warning
}

// ID returns a string representation of the id and satisfies the IDer interface
func (e PersonType) ID() string {
	return strconv.Itoa(int(e))
}

// PersonTypeFromID converts a PersonType ID to a PersonType
func PersonTypeFromID(id string) PersonType {
	switch id {
	case `1`:
		return PersonTypeContractor
	case `2`:
		return PersonTypeManager
	case `3`:
		return PersonTypeInactive
	case `4`:
		return PersonTypeCompanyCar
	case `5`:
		return PersonTypeWorksFromHome
	}
	return PersonType(0)
}

// PersonTypesFromIDs converts a slice of PersonType IDs to a slice of PersonType
func PersonTypesFromIDs(ids []string) (values []PersonType) {
	values = make([]PersonType, 0, len(ids))
	for _, id := range ids {
		values = append(values, PersonTypeFromID(id))
	}
	return
}

// PersonTypeFromName converts a PersonType name to a PersonType
func PersonTypeFromName(name string) PersonType {
	switch name {
	case `contractor`:
		return PersonTypeContractor
	case `manager`:
		return PersonTypeManager
	case `inactive`:
		return PersonTypeInactive
	case `company_car`:
		return PersonTypeCompanyCar
	case `works_from_home`:
		return PersonTypeWorksFromHome
	}
	return PersonType(0)
}

// PersonTypes returns a slice of all the PersonType values
// in key order.
func PersonTypes() []PersonType {
	return []PersonType{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCompanyCar,
		PersonTypeWorksFromHome,
	}
}

// PersonTypesI returns a slice of all the PersonType values as generic interfaces.
// doc: type=PersonType
func PersonTypesI() (values []any) {
	return []any{
		PersonTypeContractor,
		PersonTypeManager,
		PersonTypeInactive,
		PersonTypeCompanyCar,
		PersonTypeWorksFromHome,
	}
}

// Label returns the string that will be displayed to a user for this item and satsifies goradd's Labeler interface.
func (e PersonType) Label() string {
	return e.Title()
}

// Value returns the value as an interface. It satisfies goradd's Valuer interface.
func (e PersonType) Value() any {
	return e.ID()
}

func (e PersonType) Name() string {
	switch e {
	case 0:
		return ""
	case PersonTypeContractor:
		return "contractor"
	case PersonTypeManager:
		return "manager"
	case PersonTypeInactive:
		return "inactive"
	case PersonTypeCompanyCar:
		return "company_car"
	case PersonTypeWorksFromHome:
		return "works_from_home"
	default:
		panic("Index out of range")
	}
	return "" // prevent warning
}

// PersonTypeNames returns a slice of all the Names associated with PersonType values.
// doc: type=PersonType
func PersonTypeNames() []string {
	return []string{
		// 0 item will be a zero value
		"",
		"contractor",
		"manager",
		"inactive",
		"company_car",
		"works_from_home",
	}
}

// PersonTypeSet is a pointer to a group of PersonType values.
type PersonTypeSet = *maps.OrderedSet[PersonType]

func NewPersonTypeSet(values ...PersonType) PersonTypeSet {
	return maps.NewOrderedSet[PersonType](values...)
}

func NewPersonTypeSetFrom[K constraints.Integer | constraints.Float](values ...K) PersonTypeSet {
	m := maps.NewOrderedSet[PersonType]()
	for _, v := range values {
		m.Add(PersonType(v))
	}
	return m
}

/*
// PersonTypeSetFromNumbers converts an array of numeric values into a PersonTypeSet.
func PersonTypeSetFromNumbers[T constraints.Integer | constraints.Float] (nums []T) (values PersonTypeSet) {
	var s PersonTypeSet
	for _, n := range nums {
		s.Add(PersonType(n))
	}
	return s
}

// PersonTypeSetToInts
func PersonTypeSetToInts(values PersonTypeSet) (ints []int) {
	for _,v := range values.Values() {
		ints = append(ints, int(v))
	}
	sort.Ints(ints)
	return
}
*/

func init() {
	gob.Register(new(PersonTypeSet))
}
