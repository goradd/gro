// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"strconv"
	"testing"
	"time"

	"github.com/goradd/orm/_test/gen/orm/goradd/node"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createMinimalSamplePerson creates an unsaved minimal version of a Person object
// for testing.
func createMinimalSamplePerson() *Person {
	obj := NewPerson()
	updateMinimalSamplePerson(obj)

	return obj
}

// updateMinimalSamplePerson sets the values of a minimal sample to new, random values.
func updateMinimalSamplePerson(obj *Person) {

	obj.SetFirstName(test.RandomValue[string](50))

	obj.SetLastName(test.RandomValue[string](50))

	obj.SetTypes(test.RandomEnumArray(PersonTypes()))

}

// createMaximalSamplePerson creates an unsaved version of a Person object
// for testing that includes references to minimal objects.
func createMaximalSamplePerson(ctx context.Context) *Person {
	obj := NewPerson()
	updateMaximalSamplePerson(ctx, obj)
	return obj
}

// updateMaximalSamplePerson sets all the maximal sample values to new values.
// This will set new values for references, so save the old values and delete them.
func updateMaximalSamplePerson(ctx context.Context, obj *Person) {
	updateMinimalSamplePerson(obj)

	obj.SetAddresses(createMinimalSampleAddress())
	{
		obj2, _ := obj.LoadEmployeeInfo(ctx)
		// only update if not already set, since it can't be changed once set unless the reverse object is deleted first.
		if obj2 == nil {
			obj.SetEmployeeInfo(createMinimalSampleEmployeeInfo())
		}
	}
	{
		obj2, _ := obj.LoadLogin(ctx)
		// only update if not already set, since it can't be changed once set unless the reverse object is deleted first.
		if obj2 == nil {
			obj.SetLogin(createMinimalSampleLogin())
		}
	}
	obj.SetManagerProjects(createMinimalSampleProject())
	obj.SetProjects(createMinimalSampleProject())
}

// deleteSamplePerson deletes an object created and saved by one of the sample creator functions.
func deleteSamplePerson(ctx context.Context, obj *Person) {
	if obj == nil {
		return
	}

	for _, item := range obj.Addresses() {
		deleteSampleAddress(ctx, item)
	}
	deleteSampleEmployeeInfo(ctx, obj.EmployeeInfo())
	deleteSampleLogin(ctx, obj.Login())
	for _, item := range obj.ManagerProjects() {
		deleteSampleProject(ctx, item)
	}

	for _, item := range obj.Projects() {
		deleteSampleProject(ctx, item)
	}

	_ = obj.Delete(ctx)

}

// assertEqualFieldsPerson compares two objects and asserts that the basic fields are equal.
func assertEqualFieldsPerson(t *testing.T, obj1, obj2 *Person) {
	if obj1.IDIsLoaded() && obj2.IDIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.ID(), obj2.ID())
	}
	if obj1.FirstNameIsLoaded() && obj2.FirstNameIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.FirstName(), obj2.FirstName())
	}
	if obj1.LastNameIsLoaded() && obj2.LastNameIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.LastName(), obj2.LastName())
	}
	if obj1.TypesIsLoaded() && obj2.TypesIsLoaded() { // only check loaded values
		assert.True(t, obj1.Types().Equal(obj2.Types()))
	}
	if obj1.CreatedIsLoaded() && obj2.CreatedIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Created(), obj2.Created(), time.Second)
	}
	if obj1.ModifiedIsLoaded() && obj2.ModifiedIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.Modified(), obj2.Modified(), time.Second)
	}

}

func TestPerson_SetID(t *testing.T) {

	obj := NewPerson()

	assert.True(t, obj.IsNew())
	val := test.RandomNumberString()
	obj.SetID(val)
	assert.Equal(t, val, obj.ID())

	// test default
	obj.SetID("")
	assert.EqualValues(t, "", obj.ID(), "set default")

}
func TestPerson_SetFirstName(t *testing.T) {

	obj := NewPerson()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](50)
	obj.SetFirstName(val)
	assert.Equal(t, val, obj.FirstName())

	// test default
	obj.SetFirstName("")
	assert.EqualValues(t, "", obj.FirstName(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](51)
	assert.Panics(t, func() {
		obj.SetFirstName(val)
	})
}
func TestPerson_SetLastName(t *testing.T) {

	obj := NewPerson()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](50)
	obj.SetLastName(val)
	assert.Equal(t, val, obj.LastName())

	// test default
	obj.SetLastName("")
	assert.EqualValues(t, "", obj.LastName(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](51)
	assert.Panics(t, func() {
		obj.SetLastName(val)
	})
}
func TestPerson_SetTypes(t *testing.T) {

	obj := NewPerson()

	assert.True(t, obj.IsNew())

	val := test.RandomEnumArray(PersonTypes())
	obj.SetTypes(val)

	assert.Equal(t, val, obj.Types())
	assert.False(t, obj.TypesIsNull())

	// Test NULL
	obj.SetTypesToNull()
	assert.Nil(t, obj.Types())
	assert.True(t, obj.TypesIsNull())

	// test default
	obj.SetTypes(nil)
	assert.True(t, obj.Types().Equal(PersonTypeSet(nil)), "set default")

}

func TestPerson_Copy(t *testing.T) {
	obj := createMinimalSamplePerson()

	obj2 := obj.Copy()

	assert.Equal(t, obj.FirstName(), obj2.FirstName())
	assert.Equal(t, obj.LastName(), obj2.LastName())
	assert.Equal(t, obj.Types(), obj2.Types())

}

func TestPerson_BasicInsert(t *testing.T) {
	obj := createMinimalSamplePerson()
	ctx := db.NewContext(nil)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)

	// Test retrieval
	obj2, err := LoadPerson(ctx, obj.PrimaryKey())
	require.NotNil(t, obj2)
	assert.NoError(t, err)

	assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

	assert.True(t, obj2.IDIsLoaded())
	assert.Panics(t, func() {
		obj2.SetID(obj2.ID())
	})

	assert.True(t, obj2.FirstNameIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.firstNameIsDirty)
	obj2.SetFirstName(obj2.FirstName())
	assert.False(t, obj2.firstNameIsDirty)

	assert.True(t, obj2.LastNameIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.lastNameIsDirty)
	obj2.SetLastName(obj2.LastName())
	assert.False(t, obj2.lastNameIsDirty)

	assert.True(t, obj2.TypesIsLoaded())
	assert.False(t, obj2.TypesIsNull())
	assert.True(t, obj.Types().Equal(obj2.Types()))
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.typesIsDirty)
	obj2.SetTypes(obj2.Types())
	assert.False(t, obj2.typesIsDirty)

	assert.True(t, obj2.CreatedIsLoaded())

	assert.True(t, obj2.ModifiedIsLoaded())
	assert.False(t, obj2.ModifiedIsNull())

}

func TestPerson_InsertPanics(t *testing.T) {
	obj := createMinimalSamplePerson()
	_ = obj
	ctx := db.NewContext(nil)
	_ = ctx

	obj.firstNameIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.firstNameIsLoaded = true

	obj.lastNameIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.lastNameIsLoaded = true

}

func TestPerson_BasicUpdate(t *testing.T) {
	obj := createMinimalSamplePerson()
	ctx := db.NewContext(nil)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)
	updateMinimalSamplePerson(obj)
	assert.NoError(t, obj.Save(ctx))
	obj2, err := LoadPerson(ctx, obj.PrimaryKey())
	assert.NoError(t, err)

	assert.Equal(t, obj2.ID(), obj.ID(), "ID did not update")
	assert.Equal(t, obj2.FirstName(), obj.FirstName(), "FirstName did not update")
	assert.Equal(t, obj2.LastName(), obj.LastName(), "LastName did not update")
	assert.Equal(t, obj2.Types(), obj.Types(), "Types did not update")

	assert.WithinDuration(t, obj2.Created(), obj.Created(), time.Second, "Created not within one second")

	assert.WithinDuration(t, obj2.Modified(), obj.Modified(), time.Second, "Modified not within one second")
}

func TestPerson_ReferenceLoad(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSamplePerson(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)

	// Test that referenced objects were saved and assigned ids

	// Test lazy loading
	obj2, err := LoadPerson(ctx, obj.PrimaryKey())
	assert.NoError(t, err)
	objPkOnly, err2 := LoadPerson(ctx, obj.PrimaryKey(), node.Person().PrimaryKey())
	assert.NoError(t, err2)
	_ = obj2 // avoid error if there are no references
	_ = objPkOnly

	assert.Nil(t, obj2.Addresses(), "Addresses is not loaded initially")
	v_Addresses, _ := obj2.LoadAddresses(ctx)
	assert.NotNil(t, v_Addresses)
	assert.Len(t, v_Addresses, 1)
	assert.Nil(t, obj2.EmployeeInfo(), "EmployeeInfo is not loaded initially")
	v_EmployeeInfo, _ := obj2.LoadEmployeeInfo(ctx)
	assert.NotNil(t, v_EmployeeInfo)
	assert.Equal(t, v_EmployeeInfo.PrimaryKey(), obj2.EmployeeInfo().PrimaryKey())
	assert.Equal(t, obj.EmployeeInfo().PrimaryKey(), obj2.EmployeeInfo().PrimaryKey())
	assert.Nil(t, obj2.Login(), "Login is not loaded initially")
	v_Login, _ := obj2.LoadLogin(ctx)
	assert.NotNil(t, v_Login)
	assert.Equal(t, v_Login.PrimaryKey(), obj2.Login().PrimaryKey())
	assert.Equal(t, obj.Login().PrimaryKey(), obj2.Login().PrimaryKey())
	assert.Nil(t, obj2.ManagerProjects(), "ManagerProjects is not loaded initially")
	v_ManagerProjects, _ := obj2.LoadManagerProjects(ctx)
	assert.NotNil(t, v_ManagerProjects)
	assert.Len(t, v_ManagerProjects, 1)

	assert.Nil(t, obj2.Projects(), "Projects is not loaded initially")
	v_Projects, _ := obj2.LoadProjects(ctx)
	assert.NotNil(t, v_Projects)
	assert.Len(t, v_Projects, 1)

	// test eager loading
	obj3, _ := LoadPerson(ctx, obj.PrimaryKey(), node.Person().Addresses(),
		node.Person().EmployeeInfo(),
		node.Person().Login(),
		node.Person().ManagerProjects(),
		node.Person().Projects(),
	)
	_ = obj3 // avoid error if there are no references

	assert.Equal(t, len(obj2.Addresses()), len(obj3.Addresses()))
	assert.Equal(t, obj2.EmployeeInfo().PrimaryKey(), obj3.EmployeeInfo().PrimaryKey())
	assert.Equal(t, obj2.Login().PrimaryKey(), obj3.Login().PrimaryKey())
	assert.Equal(t, len(obj2.ManagerProjects()), len(obj3.ManagerProjects()))
	assert.Equal(t, len(obj2.Projects()), len(obj3.Projects()))

}

func TestPerson_ReferenceUpdateNewObjects(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSamplePerson(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)

	obj2, _ := LoadPerson(ctx, obj.PrimaryKey())
	updateMaximalSamplePerson(ctx, obj2)
	assert.NoError(t, obj2.Save(ctx))
	defer deleteSamplePerson(ctx, obj2)

	obj3, _ := LoadPerson(ctx, obj2.PrimaryKey(), node.Person().Addresses(),
		node.Person().EmployeeInfo(),
		node.Person().Login(),
		node.Person().ManagerProjects(),
		node.Person().Projects(),
	)
	_ = obj3 // avoid error if there are no references

	assert.Equal(t, len(obj2.Addresses()), len(obj3.Addresses()))
	assert.Equal(t, obj2.EmployeeInfo().PrimaryKey(), obj3.EmployeeInfo().PrimaryKey())
	assert.Equal(t, obj2.Login().PrimaryKey(), obj3.Login().PrimaryKey())
	assert.Equal(t, len(obj2.ManagerProjects()), len(obj3.ManagerProjects()))

	assert.Equal(t, len(obj2.Projects()), len(obj3.Projects()))

}

func TestPerson_ReferenceUpdateOldObjects(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSamplePerson(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)

	updateMinimalSampleAddress(obj.Addresses()[0])
	updateMinimalSampleEmployeeInfo(obj.EmployeeInfo())
	updateMinimalSampleLogin(obj.Login())
	updateMinimalSampleProject(obj.ManagerProjects()[0])
	updateMinimalSampleProject(obj.Projects()[0])

	assert.NoError(t, obj.Save(ctx))

	obj2, _ := LoadPerson(ctx, obj.PrimaryKey(),

		node.Person().Addresses(),
		node.Person().EmployeeInfo(),
		node.Person().Login(),
		node.Person().ManagerProjects(),
		node.Person().Projects(),
	)
	_ = obj2 // avoid error if there are no references

	assertEqualFieldsAddress(t, obj2.Addresses()[0], obj.Addresses()[0])
	assertEqualFieldsEmployeeInfo(t, obj2.EmployeeInfo(), obj.EmployeeInfo())
	assertEqualFieldsLogin(t, obj2.Login(), obj.Login())
	assertEqualFieldsProject(t, obj2.ManagerProjects()[0], obj.ManagerProjects()[0])

	assertEqualFieldsProject(t, obj2.Projects()[0], obj.Projects()[0])
}
func TestPerson_EmptyPrimaryKeyGetter(t *testing.T) {
	obj := NewPerson()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)
}

func TestPerson_Getters(t *testing.T) {
	obj := createMinimalSamplePerson()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)

	ctx := db.NewContext(nil)
	require.NoError(t, obj.Save(ctx))
	defer deleteSamplePerson(ctx, obj)

	has, _ := HasPerson(ctx, obj.PrimaryKey())
	assert.True(t, has)

	obj2, _ := LoadPerson(ctx, obj.PrimaryKey(), node.Person().PrimaryKey())

	assert.Equal(t, obj.ID(), obj.Get(node.Person().ID().Identifier))
	assert.Equal(t, obj.FirstName(), obj.Get(node.Person().FirstName().Identifier))
	assert.Panics(t, func() { obj2.FirstName() })
	assert.Nil(t, obj2.Get(node.Person().FirstName().Identifier))
	assert.Equal(t, obj.LastName(), obj.Get(node.Person().LastName().Identifier))
	assert.Panics(t, func() { obj2.LastName() })
	assert.Nil(t, obj2.Get(node.Person().LastName().Identifier))
	assert.Equal(t, obj.Types(), obj.Get(node.Person().Types().Identifier))
	assert.Panics(t, func() { obj2.Types() })
	assert.Nil(t, obj2.Get(node.Person().Types().Identifier))
	assert.Equal(t, obj.Created(), obj.Get(node.Person().Created().Identifier))
	assert.Panics(t, func() { obj2.Created() })
	assert.Nil(t, obj2.Get(node.Person().Created().Identifier))
	assert.Equal(t, obj.Modified(), obj.Get(node.Person().Modified().Identifier))
	assert.Panics(t, func() { obj2.Modified() })
	assert.Nil(t, obj2.Get(node.Person().Modified().Identifier))
}

func TestPerson_QueryLoad(t *testing.T) {
	obj := createMinimalSamplePerson()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSamplePerson(ctx, obj)

	objs, _ := QueryPeople(ctx).
		Where(op.Equal(node.Person().PrimaryKey(), obj.PrimaryKey())).
		OrderBy(node.Person().PrimaryKey()). // exercise order by
		Limit(1, 0).                         // exercise limit
		Calculation(node.Person(), "IsTrue", op.Equal(1, 1)).
		Load()

	assert.Equal(t, obj.PrimaryKey(), objs[0].PrimaryKey())
	assert.True(t, objs[0].GetAlias("IsTrue").Bool())
}
func TestPerson_QueryLoadI(t *testing.T) {
	obj := createMinimalSamplePerson()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSamplePerson(ctx, obj)

	objs, _ := QueryPeople(ctx).
		Where(op.Equal(node.Person().PrimaryKey(), obj.PrimaryKey())).
		LoadI()

	assert.Equal(t, obj.PrimaryKey(), objs[0].Get("ID"))
}
func TestPerson_QueryCursor(t *testing.T) {
	obj := createMinimalSamplePerson()
	ctx := db.NewContext(nil)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSamplePerson(ctx, obj)

	cursor, _ := QueryPeople(ctx).
		Where(op.Equal(node.Person().PrimaryKey(), obj.PrimaryKey())).
		LoadCursor()

	obj2, err2 := cursor.Next()
	assert.Equal(t, obj.PrimaryKey(), obj2.PrimaryKey())
	assert.NoError(t, err2)
	obj2, err2 = cursor.Next()
	assert.Nil(t, obj2)
	assert.NoError(t, err2)
	assert.NoError(t, cursor.Close())

	// test empty cursor result
	cursor, err = QueryPeople(ctx).
		Where(op.Equal(1, 0)).
		LoadCursor()
	obj2, err = cursor.Next()
	assert.Nil(t, obj2)
	assert.NoError(t, err)
	assert.NoError(t, cursor.Close())
}
func TestPerson_Count(t *testing.T) {
	ctx := db.NewContext(nil)
	obj := createMaximalSamplePerson(ctx)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSamplePerson(ctx, obj)
	// reread in case there are data limitations imposed by the database
	obj2, _ := LoadPerson(ctx, obj.PrimaryKey())

	assert.Positive(t, func() int { i, _ := CountPeople(ctx); return i }())
	assert.Positive(t, func() int { i, _ := CountPeopleByID(ctx, obj2.ID()); return i }())
	assert.Positive(t, func() int { i, _ := CountPeopleByFirstName(ctx, obj2.FirstName()); return i }())
	assert.Positive(t, func() int { i, _ := CountPeopleByLastName(ctx, obj2.LastName()); return i }())
	assert.Positive(t, func() int { i, _ := CountPeopleByCreated(ctx, obj2.Created()); return i }())
	assert.Positive(t, func() int { i, _ := CountPeopleByModified(ctx, obj2.Modified()); return i }())

}

func TestPerson_MarshalJSON(t *testing.T) {
	obj := createMinimalSamplePerson()

	b, err := json.Marshal(obj)
	assert.NoError(t, err)

	obj2 := NewPerson()
	err = json.Unmarshal(b, &obj2)
	assert.NoError(t, err)

	assertEqualFieldsPerson(t, obj, obj2)
}

func TestPerson_MarshalBinary(t *testing.T) {
	obj := createMinimalSamplePerson()

	b, err := obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 := NewPerson()
	err = obj2.UnmarshalBinary(b)
	assert.NoError(t, err)

	assertEqualFieldsPerson(t, obj, obj2)
}

func TestPerson_FailingMarshalBinary(t *testing.T) {
	obj := createMinimalSamplePerson()
	var err error

	for i := 0; i < 31; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
	// do it again with aliases
	obj._aliases = make(map[string]any)
	for i := 0; i < 32; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
}

func TestPerson_FailingUnmarshalBinary(t *testing.T) {
	obj := createMinimalSamplePerson()
	b, err := obj.MarshalBinary()
	assert.NoError(t, err)
	obj2 := NewPerson()
	for i := 0; i < 31; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}

	// do it again with aliases
	obj = createMinimalSamplePerson()
	obj._aliases = map[string]any{"a": 1}
	b, err = obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 = NewPerson()
	for i := 0; i < 32; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}
}
