// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"time"
	"unicode/utf8"

	"github.com/goradd/anyutil"
	"github.com/goradd/maps"
	"github.com/goradd/orm/_test/gen/orm/goradd/node"
	"github.com/goradd/orm/pkg/broadcast"
	"github.com/goradd/orm/pkg/db"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/query"
)

// PersonBase is embedded in a Person object and provides the ORM access to the database.
// The member variables of the structure are private and should not normally be accessed by the Person embedder.
// Instead, use the accessor functions.
type personBase struct {
	id                string
	idIsLoaded        bool
	idIsDirty         bool
	firstName         string
	firstNameIsLoaded bool
	firstNameIsDirty  bool
	lastName          string
	lastNameIsLoaded  bool
	lastNameIsDirty   bool
	types             PersonTypeSet
	typesIsNull       bool
	typesIsLoaded     bool
	typesIsDirty      bool
	created           time.Time
	createdIsLoaded   bool
	modified          time.Time
	modifiedIsNull    bool
	modifiedIsLoaded  bool

	// Reverse reference objects.
	revManagerProjects        maps.SliceMap[string, *Project] // Objects in the order they were queried
	revManagerProjectsIsDirty bool
	revAddresses              maps.SliceMap[string, *Address] // Objects in the order they were queried
	revAddressesIsDirty       bool
	revEmployeeInfo           *EmployeeInfo
	revEmployeeInfoIsDirty    bool // is a new one being associated
	revLogin                  *Login
	revLoginIsDirty           bool // is a new one being associated

	// Many-Many reference objects.
	mmProjects        maps.SliceMap[string, *Project]
	mmProjectsPks     []string // Primary keys to associate at Save time
	mmProjectsIsDirty bool

	// Custom aliases, if specified
	_aliases map[string]any

	// Indicates whether this is a new object, or one loaded from the database. Used by Save to know whether to Insert or Update.
	_restored bool

	_originalPK string
}

// IDs used to access the Person object fields by name using the Get function.
// doc: type=Person
const (
	Person_ID             = `ID`
	Person_FirstName      = `FirstName`
	Person_LastName       = `LastName`
	Person_Types          = `Types`
	Person_Created        = `Created`
	Person_Modified       = `Modified`
	PersonManagerProjects = `ManagerProjects`
	PersonAddresses       = `Addresses`
	PersonEmployeeInfo    = `EmployeeInfo`
	PersonLogin           = `Login`
	PersonProject         = `Project`
	PersonProjects        = `Projects`
)

const PersonIDMaxLength = 32        // The number of runes the column can hold
const PersonFirstNameMaxLength = 50 // The number of runes the column can hold
const PersonLastNameMaxLength = 50  // The number of runes the column can hold

// Initialize or re-initialize a Person database object to default values.
// The primary key will get a temporary negative number which will be replaced when the object is saved.
// Multiple calls to Initialize are not guaranteed to create sequential values for the primary key.
func (o *personBase) Initialize() {
	o.id = db.TemporaryPrimaryKey()
	o.idIsLoaded = true
	o.idIsDirty = false

	o.firstName = ""
	o.firstNameIsLoaded = false
	o.firstNameIsDirty = false

	o.lastName = ""
	o.lastNameIsLoaded = false
	o.lastNameIsDirty = false

	o.types = nil
	o.typesIsNull = true
	o.typesIsLoaded = false
	o.typesIsDirty = false

	o.created = time.Time{}
	o.createdIsLoaded = true

	o.modified = time.Time{}
	o.modifiedIsNull = false
	o.modifiedIsLoaded = true

	// Reverse reference objects.

	o.revManagerProjects.Clear()
	o.revManagerProjectsIsDirty = false

	o.revAddresses.Clear()
	o.revAddressesIsDirty = false

	o.revEmployeeInfo = nil
	o.revEmployeeInfoIsDirty = false

	o.revLogin = nil
	o.revLoginIsDirty = false

	// Many-Many reference objects.
	o.mmProjects.Clear()
	o.mmProjectsPks = nil
	o.mmProjectsIsDirty = false

	o._aliases = nil
	o._restored = false
}

// PrimaryKey returns the current value of the primary key field.
func (o *personBase) PrimaryKey() string {
	return o.id
}

// OriginalPrimaryKey returns the value of the primary key that was originally loaded into the object when it was
// read from the database.
func (o *personBase) OriginalPrimaryKey() string {
	return o._originalPK
}

// Copy copies most fields to a new Person object.
// Forward reference ids will be copied, but reverse and many-many references will not.
// Attached objects will not be included in the copy.
// Automatically generated fields will not be included in the copy.
// The primary key field will not be copied, since it is normally auto-generated.
// Call Save() on the new object to save it into the database.
// Copy might panic if any fields in the database were set to a size larger than the
// maximum size through a process that accessed the database outside of the ORM.
func (o *personBase) Copy() (newObject *Person) {
	newObject = NewPerson()
	if o.idIsLoaded {
		newObject.SetID(o.id)
	}
	if o.firstNameIsLoaded {
		newObject.SetFirstName(o.firstName)
	}
	if o.lastNameIsLoaded {
		newObject.SetLastName(o.lastName)
	}
	if o.typesIsLoaded {
		newObject.SetTypes(o.types)
	}
	return
}

// ID returns the value of ID.
func (o *personBase) ID() string {
	if o._restored && !o.idIsLoaded {
		panic("ID was not selected in the last query and has not been set, and so is not valid")
	}
	return o.id
}

// IDIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) IDIsLoaded() bool {
	return o.idIsLoaded
}

// SetID sets the value of ID in the object, to be saved later in the database using the Save() function.
// Normally you will not need to call this function, since the ID value is automatically generated by the
// database driver. Exceptions might include importing data to a new database, or correcting primary key conflicts when
// merging data.
// You cannot change a primary key for a record that has been written to the database. While SQL databases will
// allow it, NoSql databases will not. Save a copy and delete this one instead.
func (o *personBase) SetID(v string) {
	if o._restored {
		panic("error: Do not change a primary key for a record that has been saved. Instead, save a copy and delete the original.")
	}
	if utf8.RuneCountInString(v) > PersonIDMaxLength {
		panic("attempted to set Person.ID to a value larger than its maximum length in runes")
	}

	o.idIsLoaded = true
	o.id = v
	o.idIsDirty = true
}

// FirstName returns the value of FirstName.
func (o *personBase) FirstName() string {
	if o._restored && !o.firstNameIsLoaded {
		panic("FirstName was not selected in the last query and has not been set, and so is not valid")
	}
	return o.firstName
}

// FirstNameIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) FirstNameIsLoaded() bool {
	return o.firstNameIsLoaded
}

// SetFirstName sets the value of FirstName in the object, to be saved later in the database using the Save() function.
func (o *personBase) SetFirstName(v string) {
	if utf8.RuneCountInString(v) > PersonFirstNameMaxLength {
		panic("attempted to set Person.FirstName to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.firstNameIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.firstName == v {
		// no change
		return
	}

	o.firstNameIsLoaded = true
	o.firstName = v
	o.firstNameIsDirty = true
}

// LastName returns the value of LastName.
func (o *personBase) LastName() string {
	if o._restored && !o.lastNameIsLoaded {
		panic("LastName was not selected in the last query and has not been set, and so is not valid")
	}
	return o.lastName
}

// LastNameIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) LastNameIsLoaded() bool {
	return o.lastNameIsLoaded
}

// SetLastName sets the value of LastName in the object, to be saved later in the database using the Save() function.
func (o *personBase) SetLastName(v string) {
	if utf8.RuneCountInString(v) > PersonLastNameMaxLength {
		panic("attempted to set Person.LastName to a value larger than its maximum length in runes")
	}
	if o._restored &&
		o.lastNameIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		o.lastName == v {
		// no change
		return
	}

	o.lastNameIsLoaded = true
	o.lastName = v
	o.lastNameIsDirty = true
}

// Types returns the value of Types.
func (o *personBase) Types() PersonTypeSet {
	if o._restored && !o.typesIsLoaded {
		panic("Types was not selected in the last query and has not been set, and so is not valid")
	}
	if o.types == nil {
		return nil
	}
	return o.types.Clone()
}

// TypesIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) TypesIsLoaded() bool {
	return o.typesIsLoaded
}

// TypesIsNull returns true if the related database value is null.
func (o *personBase) TypesIsNull() bool {
	return o.typesIsNull
}

// SetTypes sets the value of Types in the object, to be saved later in the database using the Save() function.
func (o *personBase) SetTypes(v PersonTypeSet) {
	if o._restored &&
		o.typesIsLoaded && // if it was not selected, then make sure it gets set, since our end comparison won't be valid
		!o.typesIsNull && // if the db value is null, force a set of value
		o.types.Equal(v) {
		// no change
		return
	}

	o.typesIsLoaded = true
	o.types = v.Clone()
	o.typesIsDirty = true
	o.typesIsNull = false
}

// SetTypesToNull() will set the type_enum value in the database to NULL.
// Types() will return the column's default value after this.
func (o *personBase) SetTypesToNull() {
	if !o.typesIsLoaded || !o.typesIsNull {
		// If we know it is null in the database, don't save it
		o.typesIsDirty = true
	}
	o.typesIsLoaded = true
	o.typesIsNull = true
	o.types = nil
}

// Created returns the value of Created.
func (o *personBase) Created() time.Time {
	if o._restored && !o.createdIsLoaded {
		panic("Created was not selected in the last query and has not been set, and so is not valid")
	}
	return o.created
}

// CreatedIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) CreatedIsLoaded() bool {
	return o.createdIsLoaded
}

// Modified returns the value of Modified.
func (o *personBase) Modified() time.Time {
	if o._restored && !o.modifiedIsLoaded {
		panic("Modified was not selected in the last query and has not been set, and so is not valid")
	}
	return o.modified
}

// ModifiedIsLoaded returns true if the value was loaded from the database or has been set.
func (o *personBase) ModifiedIsLoaded() bool {
	return o.modifiedIsLoaded
}

// ModifiedIsNull returns true if the related database value is null.
func (o *personBase) ModifiedIsNull() bool {
	return o.modifiedIsNull
}

// GetAlias returns the value for the Alias node aliasKey that was returned in the most
// recent query.
func (o *personBase) GetAlias(aliasKey string) query.AliasValue {
	if a, ok := o._aliases[aliasKey]; ok {
		return query.NewAliasValue(a)
	} else {
		panic("Alias " + aliasKey + " not found.")
	}
}

// IsNew returns true if the object will create a new record when saved.
func (o *personBase) IsNew() bool {
	return !o._restored
}

// Project returns a single Project object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *personBase) Project(pk string) *Project {
	return o.mmProjects.Get(pk)
}

// Projects returns a slice of Project objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *personBase) Projects() []*Project {
	return o.mmProjects.Values()
}

// SetProjects sets the associated objects to the given slice of Project objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *personBase) SetProjects(objs ...*Project) {
	o.mmProjects.Clear()
	o.mmProjectsIsDirty = true
	o.mmProjectsPks = nil
	for _, obj := range objs {
		o.mmProjects.Set(obj.PrimaryKey(), obj)
	}
}

// SetProjectsByID prepares to associate Project objects by
// the primary keys in ids.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *personBase) SetProjectsByID(ids ...string) {
	o.mmProjects.Clear()
	o.mmProjectsPks = ids
	o.mmProjectsIsDirty = true
}

// LoadProjects loads the Project objects associated through the Project-TeamMember relationship.
func (o *personBase) LoadProjects(ctx context.Context) ([]*Project, error) {
	if o.mmProjectsIsDirty && o.mmProjectsPks == nil {
		panic("dirty many-many relationships cannot be loaded; call Save() first")
	}

	var objs []*Project
	var err error

	if o.mmProjectsPks != nil {
		// Load the objects that will be associated after a Save
		objs, err = QueryProjects(ctx).
			Where(op.In(node.Project().PrimaryKey(), o.mmProjectsPks...)).
			Load()
	} else {
		objs, err = QueryProjects(ctx).
			Where(op.Equal(node.Project().TeamMembers(), o.PrimaryKey())).
			Load()
	}
	if err != nil {
		return nil, err
	}

	o.mmProjects.Clear()
	for _, obj := range objs {
		o.mmProjects.Set(obj.PrimaryKey(), obj)
	}
	return o.mmProjects.Values(), err
}

// CountProjects counts the number of associated mmProjects objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *personBase) CountProjects(ctx context.Context) (int, error) {
	return QueryProjects(ctx).
		Where(op.Equal(node.Project().TeamMembers(), o.PrimaryKey())).
		Count()

}

// ManagerProject returns a single Project object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return Project objects that are not saved.
func (o *personBase) ManagerProject(pk string) *Project {
	v := o.revManagerProjects.Get(pk)
	return v
}

// ManagerProjects returns a slice of Project objects if loaded.
func (o *personBase) ManagerProjects() []*Project {
	return o.revManagerProjects.Values()
}

// LoadManagerProjects loads a new slice of Project objects and returns it.
func (o *personBase) LoadManagerProjects(ctx context.Context, conditions ...interface{}) ([]*Project, error) {
	if o.IsNew() {
		return nil, nil
	}
	for obj := range o.revManagerProjects.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot load over items that have changed but have not been saved.")
		}
	}

	qb := queryProjects(ctx)
	cond := op.Equal(node.Project().ManagerID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = op.And(conditions...)
	}

	objs, err := qb.Where(cond).Load()
	if err != nil {
		return nil, err
	}
	o.revManagerProjects.Clear()

	for _, obj := range objs {
		pk := obj.ID()
		o.revManagerProjects.Set(pk, obj)
	}

	if o.revManagerProjects.Len() == 0 {
		return nil, nil
	}
	return o.revManagerProjects.Values(), nil
}

// CountManagerProjects does a database query and returns the number of Project
// objects currently in the database connected to this object.
func (o *personBase) CountManagerProjects(ctx context.Context) (int, error) {
	return CountProjectsByManagerID(ctx, o.PrimaryKey())
}

// SetManagerProjects associates the objects in objs with the Person.
// If it has ManagerProjects already associated with it that will not be associated after a save,
// the foreign keys for those ManagerProjects will be set to null.
// If you did not use a join to query the items in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be changing items
// that are not currently attached to this Person.
func (o *personBase) SetManagerProjects(objs ...*Project) {
	for obj := range o.revManagerProjects.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot overwrite items that have changed but have not been saved.")
		}
	}

	o.revManagerProjects.Clear()
	for _, obj := range objs {
		pk := obj.ID()
		o.revManagerProjects.Set(pk, obj)
	}
	o.revManagerProjectsIsDirty = true
}

// Address returns a single Address object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return Address objects that are not saved.
func (o *personBase) Address(pk string) *Address {
	v := o.revAddresses.Get(pk)
	return v
}

// Addresses returns a slice of Address objects if loaded.
func (o *personBase) Addresses() []*Address {
	return o.revAddresses.Values()
}

// LoadAddresses loads a new slice of Address objects and returns it.
func (o *personBase) LoadAddresses(ctx context.Context, conditions ...interface{}) ([]*Address, error) {
	if o.IsNew() {
		return nil, nil
	}
	for obj := range o.revAddresses.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot load over items that have changed but have not been saved.")
		}
	}

	qb := queryAddresses(ctx)
	cond := op.Equal(node.Address().PersonID(), o.PrimaryKey())
	if conditions != nil {
		conditions = append(conditions, cond)
		cond = op.And(conditions...)
	}

	objs, err := qb.Where(cond).Load()
	if err != nil {
		return nil, err
	}
	o.revAddresses.Clear()

	for _, obj := range objs {
		pk := obj.ID()
		o.revAddresses.Set(pk, obj)
	}

	if o.revAddresses.Len() == 0 {
		return nil, nil
	}
	return o.revAddresses.Values(), nil
}

// CountAddresses does a database query and returns the number of Address
// objects currently in the database connected to this object.
func (o *personBase) CountAddresses(ctx context.Context) (int, error) {
	return CountAddressesByPersonID(ctx, o.PrimaryKey())
}

// SetAddresses associates the objects in objs with the Person.
// WARNING! If it has Addresses already associated with it that will not be associated after a save,
// Save will panic. Be sure to delete those Addresses or otherwise fix those pointers before calling save.
func (o *personBase) SetAddresses(objs ...*Address) {
	for obj := range o.revAddresses.ValuesIter() {
		if obj.IsDirty() {
			panic("You cannot overwrite items that have changed but have not been saved.")
		}
	}

	o.revAddresses.Clear()
	for _, obj := range objs {
		pk := obj.ID()
		o.revAddresses.Set(pk, obj)
	}
	o.revAddressesIsDirty = true
}

// EmployeeInfo returns the connected EmployeeInfo object, if one was loaded.
// Otherwise, it will return nil.
func (o *personBase) EmployeeInfo() *EmployeeInfo {
	if o.revEmployeeInfo == nil {
		return nil
	}
	return o.revEmployeeInfo
}

// LoadEmployeeInfo returns the connected EmployeeInfo object, if one was loaded.
// Otherwise, it will load a new one and return it.
func (o *personBase) LoadEmployeeInfo(ctx context.Context) (*EmployeeInfo, error) {
	if o.revEmployeeInfo != nil && o.revEmployeeInfo.IsDirty() {
		panic("The EmployeeInfo has changed. You must save it first before changing to a different one.")
	}
	var err error
	if o.revEmployeeInfo == nil {
		pk := o.ID()
		o.revEmployeeInfo, err = LoadEmployeeInfoByPersonID(ctx, pk)
	}
	return o.revEmployeeInfo, err
}

// SetEmployeeInfo associates obj with this Person
// through the reverse relationship in EmployeeInfo.PersonID.
//
// The association is temporary until you call Save().
// WARNING! Since this is a non-nullable unique relationship,
// if a different EmployeeInfo object is currently pointing to this Person,
// it will be deleted. Pass nil to just delete the old object.
func (o *personBase) SetEmployeeInfo(obj *EmployeeInfo) {
	if o.revEmployeeInfo != nil && o.revEmployeeInfo.IsDirty() {
		panic("The EmployeeInfo has changed. You must save it first before changing to a different one.")
	}
	o.revEmployeeInfo = obj
	o.revEmployeeInfoIsDirty = true
}

// Login returns the connected Login object, if one was loaded.
// Otherwise, it will return nil.
func (o *personBase) Login() *Login {
	if o.revLogin == nil {
		return nil
	}
	return o.revLogin
}

// LoadLogin returns the connected Login object, if one was loaded.
// Otherwise, it will load a new one and return it.
func (o *personBase) LoadLogin(ctx context.Context) (*Login, error) {
	if o.revLogin != nil && o.revLogin.IsDirty() {
		panic("The Login has changed. You must save it first before changing to a different one.")
	}
	var err error
	if o.revLogin == nil {
		pk := o.ID()
		o.revLogin, err = LoadLoginByPersonID(ctx, pk)
	}
	return o.revLogin, err
}

// SetLogin associates obj with this Person
// through the reverse relationship in Login.PersonID.
//
// The association is temporary until you call Save().
// Since this is a unique relationship, if a different Login object is currently pointing to this Person,
// that Login's PersonID value will be set to null when Save is called.
// If you did not use a join to query the attached Login in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be inadvertently changing an item
// that is not currently attached to this Person.
func (o *personBase) SetLogin(obj *Login) {
	if o.revLogin != nil && o.revLogin.IsDirty() {
		panic("The Login has changed. You must save it first before changing to a different one.")
	}
	o.revLogin = obj
	o.revLoginIsDirty = true
}

// LoadPerson returns a Person from the database.
// selectNodes lets you provide nodes for selecting specific fields or additional fields from related tables.
// See [PeopleBuilder.Select] for more info.
func LoadPerson(ctx context.Context, id string, selectNodes ...query.Node) (*Person, error) {
	return queryPeople(ctx).
		Where(op.Equal(node.Person().ID(), id)).
		Select(selectNodes...).
		Get()
}

// HasPerson returns true if a Person with the given primary key exists in the database.
// doc: type=Person
func HasPerson(ctx context.Context, id string) (bool, error) {
	v, err := queryPeople(ctx).
		Where(op.Equal(node.Person().ID(), id)).
		Count()
	return v > 0, err
}

// The PersonBuilder uses a builder pattern to create a query on the database.
// Start a query by calling QueryPeople, which will select all
// the Person object in the database. Then filter and arrange those objects
// by calling Where, Select, etc.
// End a query by calling either Load, LoadI, LoadCursor, Get, or Count.
// A PersonBuilder stores the context it will use to perform the query, and thus is
// meant to be a short-lived object. You should not save a query builder for later use.
type PersonBuilder interface {
	// Where adds a condition to filter what gets selected.
	// Calling Where multiple times will AND the conditions together.
	// See the op package for the usable conditions.
	Where(c query.Node) PersonBuilder

	// OrderBy specifies how the resulting data should be sorted.
	// By default, the given nodes are sorted in ascending order.
	// Add Descending() to the node to specify that it should be sorted in descending order.
	OrderBy(nodes ...query.Sorter) PersonBuilder

	// Limit will return a subset of the data, limited to the offset and number of rows specified.
	// For large data sets and specific types of queries, this can be slow, because it will perform
	// the entire query before computing the limit.
	// You cannot limit a query that has selected a "many" relationship.
	Limit(maxRowCount int, offset int) PersonBuilder

	// Select performs two functions:
	//  - Passing a table type node will join the object or objects from that table to this object.
	//  - Passing a column node will optimize the query to only return the specified fields.
	// Once you select at least one column, you must select all the columns that you want in the result.
	// Some fields, like primary keys, are always selected.
	// If you are using a GroupBy, you must select the fields in the GroupBy.
	Select(nodes ...query.Node) PersonBuilder

	// Calculation adds a calculation described by operation with alias.
	// After the query, you can read the data using GetAlias() on the object identified by base.
	Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) PersonBuilder

	// Distinct removes duplicates from the results of the query.
	// Adding a Select() is required when using Distinct.
	Distinct() PersonBuilder

	// GroupBy controls how results are grouped when using aggregate functions with Calculation.
	GroupBy(nodes ...query.Node) PersonBuilder

	// Having does additional filtering on the results of the query after the query is performed.
	Having(node query.Node) PersonBuilder

	// Load terminates the query builder, performs the query, and returns a slice of Person objects.
	// If there are any errors, nil is returned along with the error.
	// If no results come back from the query, it will return a non-nil empty slice.
	Load() ([]*Person, error)
	// Load terminates the query builder, performs the query, and returns a slice of interfaces.
	// This can then satisfy a general interface that loads arrays of objects.
	// If there are any errors, nil is returned along with the error.
	// If no results come back from the query, it will return a non-nil empty slice.
	LoadI() ([]query.OrmObj, error)

	// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
	//
	// A query cursor is useful for dealing with large amounts of query results. However, there are some
	// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
	// many-to-many or reverse relationships that will create an array of values.
	//
	// Call Next() on the returned cursor object to step through the results. Make sure you call Close
	// on the cursor object when you are done. You should use
	//   defer cursor.Close()
	// to make sure the cursor gets closed.
	LoadCursor() (peopleCursor, error)

	// Get is a convenience method to return only the first item found in a query.
	// The entire query is performed, so you should generally use this only if you know
	// you are selecting on one or very few items.
	// If an error occurs, or no results are found, a nil is returned.
	Get() (*Person, error)

	// Count terminates a query and returns just the number of items in the result.
	// If you have Select or Calculation columns in the query, it will count NULL results as well.
	// To not count NULL values, use Where in the builder with a NotNull operation.
	// To count distinct combinations of items, call Distinct() on the builder.
	Count() (int, error)
}

type personQueryBuilder struct {
	builder *query.Builder
}

func newPersonBuilder(ctx context.Context) PersonBuilder {
	b := personQueryBuilder{
		builder: query.NewBuilder(ctx, node.Person()),
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of Person objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *personQueryBuilder) Load() (people []*Person, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any
	results, err = database.BuilderQuery(b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Person)
		o.load(item, o)
		people = append(people, o)
	}
	return
}

// Load terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a variety of interfaces that load arrays of objects, including KeyLabeler.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *personQueryBuilder) LoadI() (people []query.OrmObj, err error) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("goradd")
	var results any
	results, err = database.BuilderQuery(b.builder)
	if results == nil || err != nil {
		return
	}
	for _, item := range results.([]map[string]any) {
		o := new(Person)
		o.load(item, o)
		people = append(people, o)
	}
	return
}

// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//
//	defer cursor.Close()
//
// to make sure the cursor gets closed.
func (b *personQueryBuilder) LoadCursor() (peopleCursor, error) {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("goradd")
	result, err := database.BuilderQuery(b.builder)
	cursor := result.(query.CursorI)

	return peopleCursor{cursor}, err
}

type peopleCursor struct {
	query.CursorI
}

// Next returns the current Person object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c peopleCursor) Next() (*Person, error) {
	if c.CursorI == nil {
		return nil, nil
	}

	row, err := c.CursorI.Next()
	if row == nil || err != nil {
		return nil, err
	}
	o := new(Person)
	o.load(row, o)
	return o, nil
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
// If an error occurs, or no results are found, a nil is returned.
func (b *personQueryBuilder) Get() (*Person, error) {
	results, err := b.Load()
	if err != nil || len(results) == 0 {
		return nil, err
	}
	return results[0], nil
}

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *personQueryBuilder) Where(c query.Node) PersonBuilder {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *personQueryBuilder) OrderBy(nodes ...query.Sorter) PersonBuilder {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *personQueryBuilder) Limit(maxRowCount int, offset int) PersonBuilder {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the person table will be queried and loaded.
// If nodes contains columns from the person table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *personQueryBuilder) Select(nodes ...query.Node) PersonBuilder {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds operation as an aliased value onto base.
// After the query, you can read the data by passing alias to GetAlias on the returned object.
func (b *personQueryBuilder) Calculation(base query.TableNodeI, alias string, operation query.OperationNodeI) PersonBuilder {
	b.builder.Calculation(base, alias, operation)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *personQueryBuilder) Distinct() PersonBuilder {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *personQueryBuilder) GroupBy(nodes ...query.Node) PersonBuilder {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *personQueryBuilder) Having(node query.Node) PersonBuilder {
	b.builder.Having(node)
	return b
}

// Count terminates a query and returns just the number of items in the result.
// If you have Select or Calculation columns in the query, it will count NULL results as well.
// To not count NULL values, use Where in the builder with a NotNull operation.
// To count distinct combinations of items, call Distinct() on the builder.
func (b *personQueryBuilder) Count() (int, error) {
	b.builder.Command = query.BuilderCommandCount
	database := db.GetDatabase("goradd")
	results, err := database.BuilderQuery(b.builder)
	if results == nil || err != nil {
		return 0, err
	}
	return results.(int), nil
}

// CountPeople returns the total number of items in the person table.
func CountPeople(ctx context.Context) (int, error) {
	return QueryPeople(ctx).Count()
}

// CountPeopleByID queries the database and returns the number of Person objects that
// have id.
// doc: type=Person
func CountPeopleByID(ctx context.Context, id string) (int, error) {
	return QueryPeople(ctx).Where(op.Equal(node.Person().ID(), id)).Count()
}

// CountPeopleByFirstName queries the database and returns the number of Person objects that
// have firstName.
// doc: type=Person
func CountPeopleByFirstName(ctx context.Context, firstName string) (int, error) {
	return QueryPeople(ctx).Where(op.Equal(node.Person().FirstName(), firstName)).Count()
}

// CountPeopleByLastName queries the database and returns the number of Person objects that
// have lastName.
// doc: type=Person
func CountPeopleByLastName(ctx context.Context, lastName string) (int, error) {
	return QueryPeople(ctx).Where(op.Equal(node.Person().LastName(), lastName)).Count()
}

// CountPeopleByCreated queries the database and returns the number of Person objects that
// have created.
// doc: type=Person
func CountPeopleByCreated(ctx context.Context, created time.Time) (int, error) {
	return QueryPeople(ctx).Where(op.Equal(node.Person().Created(), created)).Count()
}

// CountPeopleByModified queries the database and returns the number of Person objects that
// have modified.
// doc: type=Person
func CountPeopleByModified(ctx context.Context, modified time.Time) (int, error) {
	return QueryPeople(ctx).Where(op.Equal(node.Person().Modified(), modified)).Count()
}

// load is the private loader that transforms data coming from the database into a tree structure reflecting the relationships
// between the object chain requested by the user in the query.
func (o *personBase) load(m map[string]interface{}, objThis *Person) {

	if v, ok := m["id"]; ok && v != nil {
		if o.id, ok = v.(string); ok {
			o.idIsLoaded = true
			o.idIsDirty = false

			o._originalPK = o.id

		} else {
			panic("Wrong type found for id.")
		}
	} else {
		o.idIsLoaded = false
		o.id = ""
		o.idIsDirty = false
	}

	if v, ok := m["first_name"]; ok && v != nil {
		if o.firstName, ok = v.(string); ok {
			o.firstNameIsLoaded = true
			o.firstNameIsDirty = false

		} else {
			panic("Wrong type found for first_name.")
		}
	} else {
		o.firstNameIsLoaded = false
		o.firstName = ""
		o.firstNameIsDirty = false
	}

	if v, ok := m["last_name"]; ok && v != nil {
		if o.lastName, ok = v.(string); ok {
			o.lastNameIsLoaded = true
			o.lastNameIsDirty = false

		} else {
			panic("Wrong type found for last_name.")
		}
	} else {
		o.lastNameIsLoaded = false
		o.lastName = ""
		o.lastNameIsDirty = false
	}

	if v, ok := m["type_enum"]; ok {
		if v == nil {
			o.types = nil
			o.typesIsNull = true
			o.typesIsLoaded = true
			o.typesIsDirty = false
		} else if s, ok2 := v.(string); ok2 {
			var v PersonTypeSet
			if s == "" {
				o.types = nil
			} else if err := json.Unmarshal([]byte(s), &v); err != nil {
				panic("Value for type_enum is not valid json")
			} else {
				o.types = v
			}
			o.typesIsNull = false
			o.typesIsLoaded = true
			o.typesIsDirty = false
		} else {
			panic("Wrong type found for type_enum.")
		}
	} else {
		o.typesIsLoaded = false
		o.typesIsNull = true
		o.types = nil
		o.typesIsDirty = false
	}

	if v, ok := m["created"]; ok && v != nil {
		if o.created, ok = v.(time.Time); ok {
			o.createdIsLoaded = true

		} else {
			panic("Wrong type found for created.")
		}
	} else {
		o.createdIsLoaded = false
		o.created = time.Time{}
	}

	if v, ok := m["modified"]; ok {
		if v == nil {
			o.modified = time.Time{}
			o.modifiedIsNull = true
			o.modifiedIsLoaded = true
		} else if o.modified, ok = v.(time.Time); ok {
			o.modifiedIsNull = false
			o.modifiedIsLoaded = true
		} else {
			panic("Wrong type found for modified.")
		}
	} else {
		o.modifiedIsLoaded = false
		o.modifiedIsNull = true
		o.modified = time.Time{}
	}

	// Many-Many references

	if v, ok := m["Projects"]; ok {
		if v2, ok2 := v.([]map[string]any); ok2 {
			o.mmProjects.Clear()

			for _, v3 := range v2 {
				obj := new(Project)
				obj.load(v3, obj)
				o.mmProjects.Set(obj.PrimaryKey(), obj)
			}
			o.mmProjectsPks = nil
		} else {
			panic("Wrong type found for mmProjects object.")
		}
	} else {
		o.mmProjects.Clear()
		o.mmProjectsPks = nil
	}

	// Reverse references

	if v, ok := m["ManagerProjects"]; ok {
		switch v2 := v.(type) {
		case []map[string]any: // array expansion
			o.revManagerProjects.Clear()
			o.revManagerProjectsIsDirty = false
			for _, v3 := range v2 {
				obj := new(Project)
				obj.load(v3, obj)
				o.revManagerProjects.Set(obj.PrimaryKey(), obj)
			}
		default:
			panic("Wrong type found for revManagerProjects object.")
		}
	} else {
		o.revManagerProjects.Clear()
		o.revManagerProjectsIsDirty = false
	}

	if v, ok := m["Addresses"]; ok {
		switch v2 := v.(type) {
		case []map[string]any: // array expansion
			o.revAddresses.Clear()
			o.revAddressesIsDirty = false
			for _, v3 := range v2 {
				obj := new(Address)
				obj.load(v3, obj)
				o.revAddresses.Set(obj.PrimaryKey(), obj)
			}
		default:
			panic("Wrong type found for revAddresses object.")
		}
	} else {
		o.revAddresses.Clear()
		o.revAddressesIsDirty = false
	}

	if v, ok := m["EmployeeInfo"]; ok {
		if v2, ok2 := v.(map[string]any); ok2 {
			o.revEmployeeInfo = new(EmployeeInfo)
			o.revEmployeeInfo.load(v2, o.revEmployeeInfo)
			o.revEmployeeInfoIsDirty = false
		} else {
			panic("Wrong type found for personID object.")
		}
	} else {
		o.revEmployeeInfo = nil
		o.revEmployeeInfoIsDirty = false
	}

	if v, ok := m["Login"]; ok {
		if v2, ok2 := v.(map[string]any); ok2 {
			o.revLogin = new(Login)
			o.revLogin.load(v2, o.revLogin)
			o.revLoginIsDirty = false
		} else {
			panic("Wrong type found for personID object.")
		}
	} else {
		o.revLogin = nil
		o.revLoginIsDirty = false
	}

	if v, ok := m["aliases_"]; ok {
		o._aliases = v.(map[string]any)
	}

	o._restored = true

}

// save will update or insert the object, depending on the state of the object.
func (o *personBase) save(ctx context.Context) error {
	if o._restored {
		return o.update(ctx)
	} else {
		return o.insert(ctx)
	}
}

// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *personBase) update(ctx context.Context) error {
	if !o._restored {
		panic("cannot update a record that was not originally read from the database.")
	}
	if !o.IsDirty() {
		return nil // nothing to save
	}

	var modifiedFields map[string]interface{}

	d := Database()
	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()
	err := db.ExecuteTransaction(ctx, d, func() error {

		modifiedFields = getPersonUpdateFields(o)
		if len(modifiedFields) != 0 {
			var err2 error

			_, err2 = d.Update(ctx, "person", "id", o._originalPK, modifiedFields, "", 0)
			if err2 != nil {
				return err2
			}
		}

		if o.revManagerProjectsIsDirty {
			// relation connection changed

			if currentObjs, err := QueryProjects(ctx).
				Where(op.Equal(node.Project().ManagerID(), o.PrimaryKey())).
				Select(node.Project().ManagerID()).
				Load(); err != nil {
				return err
			} else {
				for _, obj := range currentObjs {
					if !o.revManagerProjects.Has(obj.PrimaryKey()) {
						// The old object is not in the group of new objects
						obj.SetManagerIDToNull()
						if err = obj.Save(ctx); err != nil {
							return err
						}
					}
				}
				keys := o.revManagerProjects.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
				for i, k := range keys {
					obj := o.revManagerProjects.Get(k)
					obj.SetManagerID(o.PrimaryKey())
					obj.managerIDIsDirty = true // force a change in case data is stale
					if err = obj.Save(ctx); err != nil {
						return err
					}
					if obj.PrimaryKey() != k {
						// update slice map key without changing order
						o.revManagerProjects.Delete(k)
						o.revManagerProjects.SetAt(i, obj.PrimaryKey(), obj)
					}
				}
			}

		} else {

			// save related objects in case internal values changed
			for obj := range o.revManagerProjects.ValuesIter() {
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}
		}
		if o.revAddressesIsDirty {
			// relation connection changed

			// Since the other side of the relationship cannot be null, there cannot be objects that will be detached.
			if oldObjs, err := QueryAddresses(ctx).
				Where(op.Equal(node.Address().PersonID(), o.PrimaryKey())).
				Select(node.Address().PersonID()).
				Load(); err != nil {
				return err
			} else {
				for _, obj := range oldObjs {
					if !o.revAddresses.Has(obj.PrimaryKey()) {
						err = obj.Delete(ctx) // old object is not in group of new objects, so delete it since it has a non-null reference to o.
						if err != nil {
							return err
						}
					}
				}
				keys := o.revAddresses.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
				for i, k := range keys {
					obj := o.revAddresses.Get(k)
					if obj == nil {
						// object was deleted during save?
						continue
					}
					obj.SetPersonID(o.PrimaryKey())
					obj.personIDIsDirty = true // force a change in case data is stale
					if err = obj.Save(ctx); err != nil {
						return err
					}
					if obj.PrimaryKey() != k {
						// update slice map key without changing order
						o.revAddresses.Delete(k)
						o.revAddresses.SetAt(i, obj.PrimaryKey(), obj)
					}
				}
			}

		} else {

			// save related objects in case internal values changed
			for obj := range o.revAddresses.ValuesIter() {
				if err := obj.Save(ctx); err != nil {
					return err
				}
			}
		}
		if o.revEmployeeInfoIsDirty {
			// relation connection changed

			// Since the other side of the relationship cannot be null, if there is an object already attached
			// that is different than the one we are trying to attach, we will panic to warn the developer.
			if oldObj, err := QueryEmployeeInfos(ctx).
				Where(op.Equal(node.EmployeeInfo().PersonID(), o.PrimaryKey())).
				Select(node.EmployeeInfo().PersonID()).
				Get(); err != nil {
				return err
			} else if oldObj != nil {
				if o.revEmployeeInfo == nil || oldObj.PrimaryKey() != o.revEmployeeInfo.PrimaryKey() {
					// Delete the old object
					err = oldObj.Delete(ctx)
					if err != nil {
						return err
					}
				}
			}
			// we are moving the attachment from another object to our object, or attaching an object that is already attached.
			if o.revEmployeeInfo != nil {
				o.revEmployeeInfo.SetPersonID(o.PrimaryKey())
				if err := o.revEmployeeInfo.Save(ctx); err != nil {
					return err
				}
			}

		} else {

			// save related object in case internal values changed
			if o.revEmployeeInfo != nil {
				if err := o.revEmployeeInfo.Save(ctx); err != nil {
					return err
				}
			}
		}
		if o.revLoginIsDirty {
			// relation connection changed

			if obj, err := QueryLogins(ctx).
				Where(op.Equal(node.Login().PersonID(), o.PrimaryKey())).
				Select(node.Login().PersonID()).
				Get(); err != nil {
				return err
			} else if obj != nil &&
				(o.revLogin == nil ||
					obj.PrimaryKey() != o.revLogin.PrimaryKey()) {

				obj.SetPersonIDToNull()
				if err = obj.Save(ctx); err != nil {
					return err
				}
			}

			if o.revLogin != nil {
				o.revLogin.personIDIsDirty = true // force a change in case data is stale
				o.revLogin.SetPersonID(o.PrimaryKey())
				if err := o.revLogin.Save(ctx); err != nil {
					return err
				}
			}

		} else {

			// save related object in case internal values changed
			if o.revLogin != nil {
				if err := o.revLogin.Save(ctx); err != nil {
					return err
				}
			}
		}

		{
			keys := o.mmProjects.Keys() // Make a copy of the keys, since we will change the slicemap while iterating
			for i, k := range keys {
				obj := o.mmProjects.Get(k)
				if err := obj.Save(ctx); err != nil {
					return err
				}
				if obj.PrimaryKey() != k {
					// update key in the slice map without changing the order
					o.mmProjects.Delete(k)
					o.mmProjects.SetAt(i, obj.PrimaryKey(), obj)
				}
			}
			if o.mmProjectsIsDirty {
				if len(o.mmProjectsPks) != 0 {
					if err := db.AssociateOnly(ctx,
						d,
						"team_member_project_assn",
						"team_member_id",
						o.PrimaryKey(),
						"project_id",
						o.mmProjectsPks); err != nil {
						return err
					}
				} else {
					if err := db.AssociateOnly(ctx,
						d,
						"team_member_project_assn",
						"team_member_id",
						o.PrimaryKey(),
						"project_id",
						o.mmProjects.Keys()); err != nil {
						return err
					}
				}
			}
		}

		return nil
	}) // transaction
	if err != nil {
		return err
	}
	if t, ok := modifiedFields["modified"]; ok {
		o.modified = t.(time.Time)
		o.modifiedIsLoaded = true
	}

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
		broadcast.Update(ctx, "goradd", "person", o._originalPK, anyutil.SortedKeys(modifiedFields)...)
	}

	return nil
}

// insert will insert the object into the database. Related items will be saved.
func (o *personBase) insert(ctx context.Context) (err error) {
	var insertFields map[string]interface{}
	d := Database()

	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	err = db.ExecuteTransaction(ctx, d, func() error {

		if !o.firstNameIsLoaded {
			panic("a value for FirstName is required, and there is no default value. Call SetFirstName() before inserting the record.")
		}
		if !o.lastNameIsLoaded {
			panic("a value for LastName is required, and there is no default value. Call SetLastName() before inserting the record.")
		}
		insertFields = getPersonInsertFields(o)
		var newPk string

		newPk, err = d.Insert(ctx, "person", "id", insertFields)
		if err != nil {
			return err
		}
		o.id = newPk
		o._originalPK = newPk
		o.idIsLoaded = true

		if o.revManagerProjects.Len() > 0 {
			keys := o.revManagerProjects.Keys()
			for i, k := range keys {
				obj := o.revManagerProjects.Get(k)
				obj.SetManagerID(newPk)
				if err = obj.Save(ctx); err != nil {
					return err
				}
				if obj.PrimaryKey() != k {
					o.revManagerProjects.Delete(k)
					o.revManagerProjects.SetAt(i, obj.PrimaryKey(), obj)
				}
			}
		}

		if o.revAddresses.Len() > 0 {
			keys := o.revAddresses.Keys()
			for i, k := range keys {
				obj := o.revAddresses.Get(k)
				obj.SetPersonID(newPk)
				if err = obj.Save(ctx); err != nil {
					return err
				}
				if obj.PrimaryKey() != k {
					o.revAddresses.Delete(k)
					o.revAddresses.SetAt(i, obj.PrimaryKey(), obj)
				}
			}
		}

		if o.revEmployeeInfo != nil {
			o.revEmployeeInfo.SetPersonID(newPk)
			if err = o.revEmployeeInfo.Save(ctx); err != nil {
				return err
			}
		}

		if o.revLogin != nil {
			o.revLogin.SetPersonID(newPk)
			if err = o.revLogin.Save(ctx); err != nil {
				return err
			}
		}

		if o.mmProjects.Len() > 0 {
			keys := o.mmProjects.Keys()
			for i, k := range keys {
				obj := o.mmProjects.Get(k)
				if err = obj.Save(ctx); err != nil {
					return err
				}
				if k != obj.PrimaryKey() {
					o.mmProjects.Delete(k)
					o.mmProjects.SetAt(i, obj.PrimaryKey(), obj)
				}
				db.Associate(ctx,
					d,
					"team_member_project_assn",
					"team_member_id",
					newPk,
					"project_id",
					obj.PrimaryKey(),
				)
			}
		} else if len(o.mmProjectsPks) > 0 {
			for _, k := range o.mmProjectsPks {
				obj, err2 := LoadProject(ctx, k)
				if err2 != nil {
					return err2
				}
				if obj != nil {
					db.Associate(ctx,
						d,
						"team_member_project_assn",
						"team_member_id",
						newPk,
						"project_id",
						k,
					)
				}
			}
		}

		return nil

	}) // transaction

	if err != nil {
		return
	}
	if t, ok := insertFields["created"]; ok {
		o.created = t.(time.Time)
		o.createdIsLoaded = true
	}
	if t, ok := insertFields["modified"]; ok {
		o.modified = t.(time.Time)
		o.modifiedIsLoaded = true
	}

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "goradd", "person", o.PrimaryKey())
	return
}

// getUpdateFields returns the database columns that will be sent to the update process.
// This will include timestamp fields only if some other column has changed.
func (o *personBase) getUpdateFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}
	if o.firstNameIsDirty {
		fields["first_name"] = o.firstName
	}
	if o.lastNameIsDirty {
		fields["last_name"] = o.lastName
	}
	if o.typesIsDirty {
		if o.typesIsNull {
			fields["type_enum"] = nil
		} else {
			var a []int
			for _, v := range o.types.Values() {
				a = append(a, int(v))
			}
			b, _ := json.Marshal(a)
			fields["type_enum"] = string(b)
		}
	}
	if len(fields) > 0 {
		fields["modified"] = time.Now().UTC()
	}
	return
}

// getInsertFields returns the fields that will be specified in an insert operation.
// Optional fields that have not been set and have no default will be returned as nil.
// NoSql databases should interpret this as no value. Sql databases should interpret this as
// explicitly setting a NULL value, which would override any database specific default value.
// Auto-generated fields will be returned with their generated values, except AutoPK fields, which are generated by the
// database driver and updated after the insert.
func (o *personBase) getInsertFields() (fields map[string]interface{}) {
	fields = map[string]interface{}{}
	if o.idIsDirty {
		fields["id"] = o.id
	}

	fields["first_name"] = o.firstName

	fields["last_name"] = o.lastName
	if o.typesIsNull {
		fields["type_enum"] = nil
	} else {
		var a []int
		for _, v := range o.types.Values() {
			a = append(a, int(v))
		}
		b, _ := json.Marshal(a)
		fields["type_enum"] = string(b)
	}
	fields["created"] = time.Now().UTC()
	fields["modified"] = time.Now().UTC()
	return
}

// Delete deletes the record from the database.
//
// Associated ManagerProjects will have their ManagerID field set to NULL.
// Associated Addresses will also be deleted since their PersonID fields are not nullable.
// An associated {= rev.ReverseIdentifier()  will also be deleted since its PersonID field is not nullable.
// An associated Login will have its PersonID field set to NULL.
func (o *personBase) Delete(ctx context.Context) (err error) {
	if o == nil {
		return // allow deleting of a nil object to be a noop
	}
	if !o._restored {
		panic("Cannot delete a record that has no primary key value.")
	}
	d := Database()

	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	err = db.ExecuteTransaction(ctx, d, func() error {

		{
			objs, err := QueryProjects(ctx).
				Where(op.Equal(node.Project().ManagerID(), o.id)).
				Select(node.Project().ManagerID()).
				Load()
			if err != nil {
				return err
			}
			for _, obj := range objs {
				obj.SetManagerIDToNull()
				if err = obj.Save(ctx); err != nil {
					return err
				}
			}
			o.revManagerProjects.Clear()
		}

		{
			objs, err := QueryAddresses(ctx).
				Where(op.Equal(node.Address().PersonID(), o.id)).
				Load()
			if err != nil {
				return err
			}
			for _, obj := range objs {
				if err = obj.Delete(ctx); err != nil {
					return err
				}
			}
			o.revAddresses.Clear()
		}

		{
			obj, err := QueryEmployeeInfos(ctx).
				Where(op.Equal(node.EmployeeInfo().PersonID(), o.id)).
				Get()
			if err != nil {
				return err
			}
			if obj != nil {
				if err = obj.Delete(ctx); err != nil {
					return err
				}
			}
			// Set this object's pointer to the reverse object to nil to mark that we broke the link
			o.revEmployeeInfo = nil
		}

		{
			// Set the related objects pointer to us to NULL in the database
			obj, err := QueryLogins(ctx).
				Where(op.Equal(node.Login().PersonID(), o.id)).
				Select(node.Login().PersonID()).
				Get()
			if err != nil {
				return err
			}
			if obj != nil {
				obj.SetPersonIDToNull()
				if err = obj.Save(ctx); err != nil {
					return err
				}
			}
			// Set this object's pointer to the reverse object to nil to mark that we broke the link
			o.revLogin = nil
		}

		if err := db.AssociateOnly(ctx,
			d,
			"team_member_project_assn",
			"team_member_id",
			o.PrimaryKey(),
			"id",
			[]Project(nil)); err != nil {
			return err
		}

		return d.Delete(ctx, "person", "ID", o.id, "", 0)
	})

	if err != nil {
		return err
	}
	broadcast.Delete(ctx, "goradd", "person", fmt.Sprint(o.id))
	return
}

// deletePerson deletes the Person with primary key pk from the database
// and handles associated records.
func deletePerson(ctx context.Context, pk string) error {
	d := db.GetDatabase("goradd")

	var cancel context.CancelFunc
	ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	err := db.ExecuteTransaction(ctx, d, func() error {
		if obj, err := LoadPerson(ctx,
			pk,
			node.Person().PrimaryKey(),
		); err != nil {
			return err
		} else if obj == nil {
			return db.NewRecordNotFoundError("person", pk)
		} else {
			if err := obj.Delete(ctx); err != nil {
				return err
			}
		}
		return nil
	})
	return err
}

// resetDirtyStatus resets the dirty status of every field in the object.
func (o *personBase) resetDirtyStatus() {
	o.idIsDirty = false
	o.firstNameIsDirty = false
	o.lastNameIsDirty = false
	o.typesIsDirty = false
	o.revManagerProjectsIsDirty = false
	o.revAddressesIsDirty = false
	o.revEmployeeInfoIsDirty = false
	o.revLoginIsDirty = false
	o.mmProjectsIsDirty = false
	o.mmProjectsPks = nil

}

// IsDirty returns true if the object has been changed since it was read from the database or created.
// However, a new object that has a column with a default value will be automatically marked as dirty upon creation.
func (o *personBase) IsDirty() (dirty bool) {
	dirty = o.idIsDirty ||
		o.firstNameIsDirty ||
		o.lastNameIsDirty ||
		o.typesIsDirty

	dirty = dirty ||
		o.revManagerProjectsIsDirty ||
		o.revAddressesIsDirty ||
		o.revEmployeeInfoIsDirty ||
		o.revLoginIsDirty

	for obj := range o.revManagerProjects.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}
	for obj := range o.revAddresses.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}
	dirty = dirty || (o.revEmployeeInfo != nil && o.revEmployeeInfo.IsDirty())
	dirty = dirty || (o.revLogin != nil && o.revLogin.IsDirty())

	dirty = dirty ||
		o.mmProjectsIsDirty

	for obj := range o.mmProjects.ValuesIter() {
		dirty = dirty || obj.IsDirty()
	}

	return
}

// Get returns the value of a field in the object based on the field's name.
// It will also get related objects if they are loaded.
// Invalid fields and objects are returned as nil.
// Get can be used to retrieve a value by using the Identifier of a node.
func (o *personBase) Get(key string) interface{} {

	switch key {

	case "ID":
		if !o.idIsLoaded {
			return nil
		}
		return o.id

	case "FirstName":
		if !o.firstNameIsLoaded {
			return nil
		}
		return o.firstName

	case "LastName":
		if !o.lastNameIsLoaded {
			return nil
		}
		return o.lastName

	case "Types":
		if !o.typesIsLoaded {
			return nil
		}
		return o.types

	case "Created":
		if !o.createdIsLoaded {
			return nil
		}
		return o.created

	case "Modified":
		if !o.modifiedIsLoaded {
			return nil
		}
		return o.modified

	case "ManagerProjects":
		return o.revManagerProjects.Values()
	case "Addresses":
		return o.revAddresses.Values()
	case "EmployeeInfo":
		return o.revEmployeeInfo
	case "Login":
		return o.revLogin

	case "Projects":
		return o.mmProjects.Values()

	}
	return nil
}

// MarshalBinary serializes the object into a buffer that is deserializable using UnmarshalBinary.
// It should be used for transmitting database objects over the wire, or for temporary storage. It does not send
// a version number, so if the data format changes, its up to you to invalidate the old stored objects.
// The framework uses this to serialize the object when it is stored in a control.
func (o *personBase) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	enc := gob.NewEncoder(buf)
	if err := o.encodeTo(enc); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (o *personBase) encodeTo(enc db.Encoder) error {

	if err := enc.Encode(o.id); err != nil {
		return fmt.Errorf("error encoding Person.id: %w", err)
	}
	if err := enc.Encode(o.idIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.idIsLoaded: %w", err)
	}
	if err := enc.Encode(o.idIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.idIsDirty: %w", err)
	}

	if err := enc.Encode(o.firstName); err != nil {
		return fmt.Errorf("error encoding Person.firstName: %w", err)
	}
	if err := enc.Encode(o.firstNameIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.firstNameIsLoaded: %w", err)
	}
	if err := enc.Encode(o.firstNameIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.firstNameIsDirty: %w", err)
	}

	if err := enc.Encode(o.lastName); err != nil {
		return fmt.Errorf("error encoding Person.lastName: %w", err)
	}
	if err := enc.Encode(o.lastNameIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.lastNameIsLoaded: %w", err)
	}
	if err := enc.Encode(o.lastNameIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.lastNameIsDirty: %w", err)
	}

	if err := enc.Encode(o.types); err != nil {
		return fmt.Errorf("error encoding Person.types: %w", err)
	}
	if err := enc.Encode(o.typesIsNull); err != nil {
		return fmt.Errorf("error encoding Person.typesIsNull: %w", err)
	}
	if err := enc.Encode(o.typesIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.typesIsLoaded: %w", err)
	}
	if err := enc.Encode(o.typesIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.typesIsDirty: %w", err)
	}

	if err := enc.Encode(o.created); err != nil {
		return fmt.Errorf("error encoding Person.created: %w", err)
	}
	if err := enc.Encode(o.createdIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.createdIsLoaded: %w", err)
	}

	if err := enc.Encode(o.modified); err != nil {
		return fmt.Errorf("error encoding Person.modified: %w", err)
	}
	if err := enc.Encode(o.modifiedIsNull); err != nil {
		return fmt.Errorf("error encoding Person.modifiedIsNull: %w", err)
	}
	if err := enc.Encode(o.modifiedIsLoaded); err != nil {
		return fmt.Errorf("error encoding Person.modifiedIsLoaded: %w", err)
	}

	if err := enc.Encode(&o.revManagerProjects); err != nil {
		return err
	}

	if err := enc.Encode(o.revManagerProjectsIsDirty); err != nil {
		return err
	}

	if err := enc.Encode(&o.revAddresses); err != nil {
		return err
	}

	if err := enc.Encode(o.revAddressesIsDirty); err != nil {
		return err
	}

	if o.revEmployeeInfo == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o.revEmployeeInfo); err != nil {
			return fmt.Errorf("error encoding Person.revEmployeeInfo: %w", err)
		}
	}

	if err := enc.Encode(o.revEmployeeInfoIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.revEmployeeInfoIsDirty: %w", err)
	}
	if o.revLogin == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o.revLogin); err != nil {
			return fmt.Errorf("error encoding Person.revLogin: %w", err)
		}
	}

	if err := enc.Encode(o.revLoginIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.revLoginIsDirty: %w", err)
	}
	if err := enc.Encode(&o.mmProjects); err != nil {
		return fmt.Errorf("error encoding Person.mmProjects: %w", err)
	}
	if err := enc.Encode(o.mmProjectsIsDirty); err != nil {
		return fmt.Errorf("error encoding Person.mmProjectsIsDirty: %w", err)
	}
	if err := enc.Encode(o.mmProjectsPks != nil); err != nil {
		return err
	}
	if o.mmProjectsPks != nil {
		if err := enc.Encode(o.mmProjectsPks); err != nil {
			return fmt.Errorf("error encoding Person.mmProjectsPks: %w", err)
		}
	}

	if o._aliases == nil {
		if err := enc.Encode(false); err != nil {
			return err
		}
	} else {
		if err := enc.Encode(true); err != nil {
			return err
		}
		if err := enc.Encode(o._aliases); err != nil {
			return fmt.Errorf("error encoding Person._aliases: %w", err)
		}
	}

	if err := enc.Encode(o._restored); err != nil {
		return fmt.Errorf("error encoding Person._restored: %w", err)
	}
	if err := enc.Encode(o._originalPK); err != nil {
		return fmt.Errorf("error encoding Person._originalPK: %w", err)
	}
	return nil
}

// UnmarshalBinary converts a structure that was created with MarshalBinary into a Person object.
func (o *personBase) UnmarshalBinary(data []byte) (err error) {
	buf := bytes.NewReader(data)
	dec := gob.NewDecoder(buf)
	return o.decodeFrom(dec)
}

func (o *personBase) decodeFrom(dec db.Decoder) (err error) {
	var isPtr bool

	_ = isPtr
	if err = dec.Decode(&o.id); err != nil {
		return fmt.Errorf("error decoding Person.id: %w", err)
	}
	if err = dec.Decode(&o.idIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.idIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.idIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.idIsDirty: %w", err)
	}

	if err = dec.Decode(&o.firstName); err != nil {
		return fmt.Errorf("error decoding Person.firstName: %w", err)
	}
	if err = dec.Decode(&o.firstNameIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.firstNameIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.firstNameIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.firstNameIsDirty: %w", err)
	}

	if err = dec.Decode(&o.lastName); err != nil {
		return fmt.Errorf("error decoding Person.lastName: %w", err)
	}
	if err = dec.Decode(&o.lastNameIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.lastNameIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.lastNameIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.lastNameIsDirty: %w", err)
	}

	if err = dec.Decode(&o.types); err != nil {
		return fmt.Errorf("error decoding Person.types: %w", err)
	}
	if err = dec.Decode(&o.typesIsNull); err != nil {
		return fmt.Errorf("error decoding Person.typesIsNull: %w", err)
	}
	if err = dec.Decode(&o.typesIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.typesIsLoaded: %w", err)
	}
	if err = dec.Decode(&o.typesIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.typesIsDirty: %w", err)
	}

	if err = dec.Decode(&o.created); err != nil {
		return fmt.Errorf("error decoding Person.created: %w", err)
	}
	if err = dec.Decode(&o.createdIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.createdIsLoaded: %w", err)
	}

	if err = dec.Decode(&o.modified); err != nil {
		return fmt.Errorf("error decoding Person.modified: %w", err)
	}
	if err = dec.Decode(&o.modifiedIsNull); err != nil {
		return fmt.Errorf("error decoding Person.modifiedIsNull: %w", err)
	}
	if err = dec.Decode(&o.modifiedIsLoaded); err != nil {
		return fmt.Errorf("error decoding Person.modifiedIsLoaded: %w", err)
	}

	if err = dec.Decode(&o.revManagerProjects); err != nil {
		return fmt.Errorf("error decoding Person.revManagerProjects: %w", err)
	}

	if err = dec.Decode(&o.revManagerProjectsIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.revManagerProjectsIsDirty: %w", err)
	}

	if err = dec.Decode(&o.revAddresses); err != nil {
		return fmt.Errorf("error decoding Person.revAddresses: %w", err)
	}

	if err = dec.Decode(&o.revAddressesIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.revAddressesIsDirty: %w", err)
	}

	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Person.revEmployeeInfo isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.revEmployeeInfo); err != nil {
			return fmt.Errorf("error decoding Person.revEmployeeInfo: %w", err)
		}
	}

	if err = dec.Decode(&o.revEmployeeInfoIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.revEmployeeInfoIsDirty: %w", err)
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Person.revLogin isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.revLogin); err != nil {
			return fmt.Errorf("error decoding Person.revLogin: %w", err)
		}
	}

	if err = dec.Decode(&o.revLoginIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.revLoginIsDirty: %w", err)
	}

	if err = dec.Decode(&o.mmProjects); err != nil {
		return fmt.Errorf("error decoding Person.mmProjectsPks: %w", err)
	}
	if err = dec.Decode(&o.mmProjectsIsDirty); err != nil {
		return fmt.Errorf("error decoding Person.mmProjectsIsDirty: %w", err)
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Person.mmProjectsPks isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o.mmProjectsPks); err != nil {
			return fmt.Errorf("error decoding Person.mmProjectsPks: %w", err)
		}
	}
	if err = dec.Decode(&isPtr); err != nil {
		return fmt.Errorf("error decoding Person._aliases isPtr: %w", err)
	}
	if isPtr {
		if err = dec.Decode(&o._aliases); err != nil {
			return fmt.Errorf("error decoding Person._aliases: %w", err)
		}
	}

	if err = dec.Decode(&o._restored); err != nil {
		return fmt.Errorf("error decoding Person._restored: %w", err)
	}
	if err = dec.Decode(&o._originalPK); err != nil {
		return fmt.Errorf("error decoding Person._originalPK: %w", err)
	}
	return
}

// MarshalJSON serializes the object into a JSON object.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. Another way to control the output
// is to call MarshalStringMap, modify the map, then encode the map.
func (o *personBase) MarshalJSON() (data []byte, err error) {
	v := o.MarshalStringMap()
	return json.Marshal(v)
}

// MarshalStringMap serializes the object into a string map of interfaces.
// Only valid data will be serialized, meaning, you can control what gets serialized by using Select to
// select only the fields you want when you query for the object. The keys are the same as the json keys.
func (o *personBase) MarshalStringMap() map[string]interface{} {
	v := make(map[string]interface{})

	if o.idIsLoaded {
		v["id"] = o.id
	}

	if o.firstNameIsLoaded {
		v["firstName"] = o.firstName
	}

	if o.lastNameIsLoaded {
		v["lastName"] = o.lastName
	}

	if o.typesIsLoaded {
		if o.typesIsNull {
			v["types"] = nil
		} else {
			v["types"] = o.types
		}
	}

	if o.createdIsLoaded {
		v["created"] = o.created
	}

	if o.modifiedIsLoaded {
		if o.modifiedIsNull {
			v["modified"] = nil
		} else {
			v["modified"] = o.modified
		}
	}

	if o.revManagerProjects.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.revManagerProjects.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["managerProjects"] = vals
	}
	if o.revAddresses.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.revAddresses.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["addresses"] = vals
	}
	if obj := o.revEmployeeInfo; obj != nil {
		v["employeeInfo"] = obj.MarshalStringMap()
	}
	if obj := o.revLogin; obj != nil {
		v["login"] = obj.MarshalStringMap()
	}
	if o.mmProjects.Len() != 0 {
		var vals []map[string]interface{}
		for obj := range o.mmProjects.ValuesIter() {
			vals = append(vals, obj.MarshalStringMap())
		}
		v["projects"] = vals
	}
	for _k, _v := range o._aliases {
		v[_k] = _v
	}
	return v
}

// UnmarshalJSON unmarshalls the given json data into the Person. The Person can be a
// newly created object, or one loaded from the database.
//
// After unmarshalling, the object is not  saved. You must call Save to insert it into the database
// or update it.
//
// Unmarshalling of sub-objects, as in objects linked via foreign keys, is not currently supported.
//
// The fields it expects are:
//
//	"id" - string
//	"firstName" - string
//	"lastName" - string
//	"types" - PersonTypeSet, nullable
//	"created" - time.Time
//	"modified" - time.Time, nullable
func (o *personBase) UnmarshalJSON(data []byte) (err error) {
	var v map[string]interface{}
	if len(data) == 0 {
		return
	}
	d := json.NewDecoder(bytes.NewReader(data))
	d.UseNumber() // use a number to avoid precision errors
	if err = d.Decode(&v); err != nil {
		return err
	}
	return o.UnmarshalStringMap(v)
}

// UnmarshalStringMap will load the values from the stringmap into the object.
//
// Override this in Person to modify the json before sending it here.
func (o *personBase) UnmarshalStringMap(m map[string]interface{}) (err error) {
	for k, v := range m {
		switch k {

		case "id":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetID(s)
				}
			}

		case "firstName":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetFirstName(s)
				}
			}

		case "lastName":
			{
				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}

				if s, ok := v.(string); !ok {
					return fmt.Errorf("json field %s must be a string", k)
				} else {
					o.SetLastName(s)
				}
			}

		case "types":
			{
				if v == nil {
					o.SetTypesToNull()
					continue
				}

				if v == nil {
					return fmt.Errorf("field %s cannot be null", k)
				}
				if v2, ok := v.([]any); ok {
					a := NewPersonTypeSet()
					for _, i := range v2 {
						v3, err := PersonTypeFromInterface(i)
						if err != nil {
							return err
						}
						a.Add(v3)
					}
					o.SetTypes(a)
				} else {
					return fmt.Errorf("field '%s' must be an array of numbers or strings", k)
				}
			}

		case "managerProjects":
			v2, ok := v.([]any)
			if !ok {
				return fmt.Errorf("json field %s must be an array of maps", k)
			}
			var s []*Project
			for _, i2 := range v2 {
				m2, ok := i2.(map[string]any)
				if !ok {
					return fmt.Errorf("json field %s must be an array of maps", k)
				}
				v3 := NewProject()
				err = v3.UnmarshalStringMap(m2)
				if err != nil {
					return
				}
				s = append(s, v3)
			}
			o.SetManagerProjects(s...)

		case "addresses":
			v2, ok := v.([]any)
			if !ok {
				return fmt.Errorf("json field %s must be an array of maps", k)
			}
			var s []*Address
			for _, i2 := range v2 {
				m2, ok := i2.(map[string]any)
				if !ok {
					return fmt.Errorf("json field %s must be an array of maps", k)
				}
				v3 := NewAddress()
				err = v3.UnmarshalStringMap(m2)
				if err != nil {
					return
				}
				s = append(s, v3)
			}
			o.SetAddresses(s...)

		case "employeeInfo":
			v2 := NewEmployeeInfo()
			m2, ok := v.(map[string]any)
			if !ok {
				return fmt.Errorf("json field %s must be a map", k)
			}
			err = v2.UnmarshalStringMap(m2)
			if err != nil {
				return
			}
			o.SetEmployeeInfo(v2)

		case "login":
			v2 := NewLogin()
			m2, ok := v.(map[string]any)
			if !ok {
				return fmt.Errorf("json field %s must be a map", k)
			}
			err = v2.UnmarshalStringMap(m2)
			if err != nil {
				return
			}
			o.SetLogin(v2)

		case "projects":
			v2, ok := v.([]any)
			if !ok {
				return fmt.Errorf("json field %s must be an array of maps", k)
			}
			var s []*Project
			for _, i2 := range v2 {
				m2, ok := i2.(map[string]any)
				if !ok {
					return fmt.Errorf("json field %s must be an array of maps", k)
				}
				v3 := NewProject()
				err = v3.UnmarshalStringMap(m2)
				if err != nil {
					return
				}
				s = append(s, v3)
			}
			o.SetProjects(s...)

		}
	}
	return
}
