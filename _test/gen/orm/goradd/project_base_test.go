// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"bytes"
	"context"
	"encoding/gob"
	"encoding/json"
	"strconv"
	"testing"
	"time"

	"github.com/goradd/orm/_test/gen/orm/goradd/node"
	"github.com/goradd/orm/pkg/op"
	"github.com/goradd/orm/pkg/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createMinimalSampleProject creates an unsaved minimal version of a Project object
// for testing.
func createMinimalSampleProject() *Project {
	obj := NewProject()
	updateMinimalSampleProject(obj)

	// A required forward reference will need to be fulfilled just to save the minimal version of this object
	// If the database is configured so that the referenced object points back here, either directly or through multiple
	// forward references, it possible this could create an endless loop.
	obj.SetManager(createMinimalSamplePerson())
	// A required forward reference will need to be fulfilled just to save the minimal version of this object
	// If the database is configured so that the referenced object points back here, either directly or through multiple
	// forward references, it possible this could create an endless loop.
	obj.SetParent(createMinimalSampleProject())

	return obj
}

// updateMinimalSampleProject sets the values of a minimal sample to new, random values.
func updateMinimalSampleProject(obj *Project) {

	obj.SetNum(test.RandomValue[int](32))

	obj.SetStatusEnum(test.RandomEnum(ProjectStatuses()))

	obj.SetName(test.RandomValue[string](100))

	obj.SetDescription(test.RandomValue[string](0))

	obj.SetStartDate(test.RandomValue[time.Time](0))

	obj.SetEndDate(test.RandomValue[time.Time](0))

	obj.SetBudget(test.RandomDecimal(12, 2))

	obj.SetSpent(test.RandomDecimal(12, 2))

}

// createMaximalSampleProject creates an unsaved version of a Project object
// for testing that includes references to minimal objects.
func createMaximalSampleProject(ctx context.Context) *Project {
	obj := NewProject()
	updateMaximalSampleProject(ctx, obj)
	return obj
}

// updateMaximalSampleProject sets all the maximal sample values to new values.
// This will set new values for references, so save the old values and delete them.
func updateMaximalSampleProject(ctx context.Context, obj *Project) {
	updateMinimalSampleProject(obj)
	obj.SetManager(createMinimalSamplePerson())
	obj.SetParent(createMinimalSampleProject())

	obj.SetChildren(createMinimalSampleProject())
	obj.SetProjectMilestones(createMinimalSampleMilestone())
	obj.SetTeamMembers(createMinimalSamplePerson())
}

// deleteSampleProject deletes an object created and saved by one of the sample creator functions.
func deleteSampleProject(ctx context.Context, obj *Project) {
	if obj == nil {
		return
	}

	for _, item := range obj.Children() {
		deleteSampleProject(ctx, item)
	}
	for _, item := range obj.ProjectMilestones() {
		deleteSampleMilestone(ctx, item)
	}

	for _, item := range obj.TeamMembers() {
		deleteSamplePerson(ctx, item)
	}

	_ = obj.Delete(ctx)
	deleteSamplePerson(ctx, obj.Manager())
	deleteSampleProject(ctx, obj.Parent())
}

// assertEqualFieldsProject compares two objects and asserts that the basic fields are equal.
func assertEqualFieldsProject(t *testing.T, obj1, obj2 *Project) {
	if obj1.IDIsLoaded() && obj2.IDIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.ID(), obj2.ID())
	}
	if obj1.NumIsLoaded() && obj2.NumIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.Num(), obj2.Num())
	}
	if obj1.StatusEnumIsLoaded() && obj2.StatusEnumIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.StatusEnum(), obj2.StatusEnum())
	}
	if obj1.NameIsLoaded() && obj2.NameIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.Name(), obj2.Name())
	}
	if obj1.DescriptionIsLoaded() && obj2.DescriptionIsLoaded() { // only check loaded values
		assert.EqualValues(t, obj1.Description(), obj2.Description())
	}
	if obj1.StartDateIsLoaded() && obj2.StartDateIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.StartDate(), obj2.StartDate(), time.Second)
	}
	if obj1.EndDateIsLoaded() && obj2.EndDateIsLoaded() { // only check loaded values
		// ignore fractional seconds since some types truncate to the second.
		assert.WithinDuration(t, obj1.EndDate(), obj2.EndDate(), time.Second)
	}
	if obj1.BudgetIsLoaded() && obj2.BudgetIsLoaded() { // only check loaded values
		assert.True(t, test.EqualDecimals(obj1.Budget(), obj2.Budget()))
	}
	if obj1.SpentIsLoaded() && obj2.SpentIsLoaded() { // only check loaded values
		assert.True(t, test.EqualDecimals(obj1.Spent(), obj2.Spent()))
	}

}

func TestProject_SetID(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomNumberString()
	obj.SetID(val)
	assert.Equal(t, val, obj.ID())

	// test default
	obj.SetID("")
	assert.EqualValues(t, "", obj.ID(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](33)
	assert.Panics(t, func() {
		obj.SetID(val)
	})
}
func TestProject_SetNum(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[int](32)
	obj.SetNum(val)
	assert.Equal(t, val, obj.Num())

	// test default
	obj.SetNum(0)
	assert.EqualValues(t, 0, obj.Num(), "set default")

}
func TestProject_SetStatusEnum(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomEnum(ProjectStatuses())
	obj.SetStatusEnum(val)
	assert.Equal(t, val, obj.StatusEnum())

	// test default
	obj.SetStatusEnum(0)
	assert.EqualValues(t, 0, obj.StatusEnum(), "set default")

}
func TestProject_SetName(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](100)
	obj.SetName(val)
	assert.Equal(t, val, obj.Name())

	// test default
	obj.SetName("")
	assert.EqualValues(t, "", obj.Name(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](101)
	assert.Panics(t, func() {
		obj.SetName(val)
	})
}
func TestProject_SetDescription(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](0)
	obj.SetDescription(val)
	assert.Equal(t, val, obj.Description())
	assert.False(t, obj.DescriptionIsNull())

	// Test NULL
	obj.SetDescriptionToNull()
	assert.EqualValues(t, "", obj.Description())
	assert.True(t, obj.DescriptionIsNull())

	// test default
	obj.SetDescription("")
	assert.EqualValues(t, "", obj.Description(), "set default")

}
func TestProject_SetStartDate(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[time.Time](0)
	obj.SetStartDate(val)
	val = obj.StartDate()
	assert.Zero(t, val.Minute()) // make sure minute part is zero'd
	assert.Zero(t, val.Hour())   // make sure hour part is zero'd
	assert.Zero(t, val.Second()) // make sure second part is zero'd
	assert.False(t, obj.StartDateIsNull())

	// Test NULL
	obj.SetStartDateToNull()
	assert.EqualValues(t, time.Time{}, obj.StartDate())
	assert.True(t, obj.StartDateIsNull())

	// test default
	obj.SetStartDate(time.Time{})
	assert.EqualValues(t, time.Time{}, obj.StartDate(), "set default")

}
func TestProject_SetEndDate(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[time.Time](0)
	obj.SetEndDate(val)
	val = obj.EndDate()
	assert.Zero(t, val.Minute()) // make sure minute part is zero'd
	assert.Zero(t, val.Hour())   // make sure hour part is zero'd
	assert.Zero(t, val.Second()) // make sure second part is zero'd
	assert.False(t, obj.EndDateIsNull())

	// Test NULL
	obj.SetEndDateToNull()
	assert.EqualValues(t, time.Time{}, obj.EndDate())
	assert.True(t, obj.EndDateIsNull())

	// test default
	obj.SetEndDate(time.Time{})
	assert.EqualValues(t, time.Time{}, obj.EndDate(), "set default")

}
func TestProject_SetBudget(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomDecimal(12, 2)
	obj.SetBudget(val)
	assert.Equal(t, val, obj.Budget())
	assert.False(t, obj.BudgetIsNull())

	// Test NULL
	obj.SetBudgetToNull()
	assert.EqualValues(t, "", obj.Budget())
	assert.True(t, obj.BudgetIsNull())

	// test default
	obj.SetBudget("")
	assert.EqualValues(t, "", obj.Budget(), "set default")

}
func TestProject_SetSpent(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomDecimal(12, 2)
	obj.SetSpent(val)
	assert.Equal(t, val, obj.Spent())
	assert.False(t, obj.SpentIsNull())

	// Test NULL
	obj.SetSpentToNull()
	assert.EqualValues(t, "", obj.Spent())
	assert.True(t, obj.SpentIsNull())

	// test default
	obj.SetSpent("")
	assert.EqualValues(t, "", obj.Spent(), "set default")

}
func TestProject_SetManagerID(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](32)
	obj.SetManagerID(val)
	assert.Equal(t, val, obj.ManagerID())

	// test default
	obj.SetManagerID("")
	assert.EqualValues(t, "", obj.ManagerID(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](33)
	assert.Panics(t, func() {
		obj.SetManagerID(val)
	})
}
func TestProject_SetParentID(t *testing.T) {

	obj := NewProject()

	assert.True(t, obj.IsNew())
	val := test.RandomValue[string](32)
	obj.SetParentID(val)
	assert.Equal(t, val, obj.ParentID())

	// test default
	obj.SetParentID("")
	assert.EqualValues(t, "", obj.ParentID(), "set default")

	// test panic on setting value larger than maximum size allowed
	val = test.RandomValue[string](33)
	assert.Panics(t, func() {
		obj.SetParentID(val)
	})
}

func TestProject_Copy(t *testing.T) {
	obj := createMinimalSampleProject()

	obj2 := obj.Copy()

	assert.Equal(t, obj.Num(), obj2.Num())
	assert.Equal(t, obj.StatusEnum(), obj2.StatusEnum())
	assert.Equal(t, obj.Name(), obj2.Name())
	assert.Equal(t, obj.Description(), obj2.Description())
	assert.Equal(t, obj.StartDate(), obj2.StartDate())
	assert.Equal(t, obj.EndDate(), obj2.EndDate())
	assert.Equal(t, obj.Budget(), obj2.Budget())
	assert.Equal(t, obj.Spent(), obj2.Spent())
	assert.Equal(t, obj.ManagerID(), obj2.ManagerID())
	assert.Equal(t, obj.ParentID(), obj2.ParentID())

}

func TestProject_BasicInsert(t *testing.T) {
	obj := createMinimalSampleProject()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	// Test retrieval
	obj2, err := LoadProject(ctx, obj.PrimaryKey())
	require.NotNil(t, obj2)
	assert.NoError(t, err)

	assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

	assert.True(t, obj2.IDIsLoaded())
	assert.Panics(t, func() {
		obj2.SetID(obj2.ID())
	})

	assert.True(t, obj2.NumIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.numIsDirty)
	obj2.SetNum(obj2.Num())
	assert.False(t, obj2.numIsDirty)

	assert.True(t, obj2.StatusEnumIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.statusEnumIsDirty)
	obj2.SetStatusEnum(obj2.StatusEnum())
	assert.False(t, obj2.statusEnumIsDirty)

	assert.True(t, obj2.NameIsLoaded())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.nameIsDirty)
	obj2.SetName(obj2.Name())
	assert.False(t, obj2.nameIsDirty)

	assert.True(t, obj2.DescriptionIsLoaded())
	assert.False(t, obj2.DescriptionIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.descriptionIsDirty)
	obj2.SetDescription(obj2.Description())
	assert.False(t, obj2.descriptionIsDirty)

	assert.True(t, obj2.StartDateIsLoaded())
	assert.False(t, obj2.StartDateIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.startDateIsDirty)
	obj2.SetStartDate(obj2.StartDate())
	assert.False(t, obj2.startDateIsDirty)

	assert.True(t, obj2.EndDateIsLoaded())
	assert.False(t, obj2.EndDateIsNull())
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.endDateIsDirty)
	obj2.SetEndDate(obj2.EndDate())
	assert.False(t, obj2.endDateIsDirty)

	assert.True(t, obj2.BudgetIsLoaded())
	assert.False(t, obj2.BudgetIsNull())
	assert.True(t, test.EqualDecimals(obj.Budget(), obj2.Budget()))
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.budgetIsDirty)
	obj2.SetBudget(obj2.Budget())
	assert.False(t, obj2.budgetIsDirty)

	assert.True(t, obj2.SpentIsLoaded())
	assert.False(t, obj2.SpentIsNull())
	assert.True(t, test.EqualDecimals(obj.Spent(), obj2.Spent()))
	// test that setting it to the same value will not change the dirty bit
	assert.False(t, obj2.spentIsDirty)
	obj2.SetSpent(obj2.Spent())
	assert.False(t, obj2.spentIsDirty)

}

func TestProject_InsertPanics(t *testing.T) {
	obj := createMinimalSampleProject()
	_ = obj
	ctx := context.Background()
	_ = ctx

	obj.manager = nil
	obj.parent = nil

	obj.numIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.numIsLoaded = true

	obj.statusEnumIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.statusEnumIsLoaded = true

	obj.nameIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.nameIsLoaded = true

	obj.managerIDIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.managerIDIsLoaded = true

	obj.parentIDIsLoaded = false
	assert.Panics(t, func() { obj.Save(ctx) })
	obj.parentIDIsLoaded = true

}

func TestProject_BasicUpdate(t *testing.T) {
	obj := createMinimalSampleProject()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)
	updateMinimalSampleProject(obj)
	assert.NoError(t, obj.Save(ctx))
	obj2, err := LoadProject(ctx, obj.PrimaryKey())
	assert.NoError(t, err)

	assert.Equal(t, obj2.ID(), obj.ID(), "ID did not update")
	assert.Equal(t, obj2.Num(), obj.Num(), "Num did not update")
	assert.Equal(t, obj2.StatusEnum(), obj.StatusEnum(), "StatusEnum did not update")
	assert.Equal(t, obj2.Name(), obj.Name(), "Name did not update")
	assert.Equal(t, obj2.Description(), obj.Description(), "Description did not update")

	assert.WithinDuration(t, obj2.StartDate(), obj.StartDate(), time.Second, "StartDate not within one second")

	assert.WithinDuration(t, obj2.EndDate(), obj.EndDate(), time.Second, "EndDate not within one second")
}

func TestProject_ReferenceLoad(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleProject(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	// Test that referenced objects were saved and assigned ids
	assert.NotNil(t, obj.Manager())
	assert.NotEqual(t, '-', obj.Manager().PrimaryKey()[0])

	assert.NotNil(t, obj.Parent())
	assert.NotEqual(t, '-', obj.Parent().PrimaryKey()[0])

	// Test lazy loading
	obj2, err := LoadProject(ctx, obj.PrimaryKey())
	assert.NoError(t, err)
	objPkOnly, err2 := LoadProject(ctx, obj.PrimaryKey(),
		node.Project().ID())
	assert.NoError(t, err2)
	_ = obj2 // avoid error if there are no references
	_ = objPkOnly

	assert.Nil(t, obj2.Manager(), "Manager is not loaded initially")
	v_Manager, _ := obj2.LoadManager(ctx)
	assert.NotNil(t, v_Manager)
	assert.Equal(t, v_Manager.PrimaryKey(), obj2.Manager().PrimaryKey())
	assert.Equal(t, obj.Manager().PrimaryKey(), obj2.Manager().PrimaryKey())
	assert.True(t, obj2.ManagerIDIsLoaded())

	assert.False(t, objPkOnly.ManagerIDIsLoaded())
	assert.Panics(t, func() { _, _ = objPkOnly.LoadManager(ctx) })

	assert.Panics(t, func() {
		objPkOnly.SetManager(nil)
	})

	assert.Nil(t, obj2.Parent(), "Parent is not loaded initially")
	v_Parent, _ := obj2.LoadParent(ctx)
	assert.NotNil(t, v_Parent)
	assert.Equal(t, v_Parent.PrimaryKey(), obj2.Parent().PrimaryKey())
	assert.Equal(t, obj.Parent().PrimaryKey(), obj2.Parent().PrimaryKey())
	assert.True(t, obj2.ParentIDIsLoaded())

	assert.False(t, objPkOnly.ParentIDIsLoaded())
	assert.Panics(t, func() { _, _ = objPkOnly.LoadParent(ctx) })

	assert.Panics(t, func() {
		objPkOnly.SetParent(nil)
	})

	assert.Nil(t, obj2.Children(), "Children is not loaded initially")
	v_Children, _ := obj2.LoadChildren(ctx)
	assert.NotNil(t, v_Children)
	assert.Len(t, v_Children, 1)
	assert.Nil(t, obj2.ProjectMilestones(), "ProjectMilestones is not loaded initially")
	v_ProjectMilestones, _ := obj2.LoadProjectMilestones(ctx)
	assert.NotNil(t, v_ProjectMilestones)
	assert.Len(t, v_ProjectMilestones, 1)

	assert.Nil(t, obj2.TeamMembers(), "TeamMembers is not loaded initially")
	v_TeamMembers, _ := obj2.LoadTeamMembers(ctx)
	assert.NotNil(t, v_TeamMembers)
	assert.Len(t, v_TeamMembers, 1)

	// test eager loading
	obj3, _ := LoadProject(ctx, obj.PrimaryKey(), node.Project().ID(),
		node.Project().Num(),
		node.Project().StatusEnum(),
		node.Project().Name(),
		node.Project().Description(),
		node.Project().StartDate(),
		node.Project().EndDate(),
		node.Project().Budget(),
		node.Project().Spent(),
		node.Project().Children(),
		node.Project().ProjectMilestones(),
		node.Project().TeamMembers(),
	)
	_ = obj3 // avoid error if there are no references

	assert.Equal(t, obj2.Manager().PrimaryKey(), obj3.Manager().PrimaryKey())
	assert.Equal(t, obj2.Parent().PrimaryKey(), obj3.Parent().PrimaryKey())
	assert.Equal(t, len(obj2.Children()), len(obj3.Children()))
	assert.Equal(t, len(obj2.ProjectMilestones()), len(obj3.ProjectMilestones()))
	assert.Equal(t, len(obj2.TeamMembers()), len(obj3.TeamMembers()))

}

func TestProject_ReferenceUpdateNewObjects(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleProject(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	obj2, _ := LoadProject(ctx, obj.PrimaryKey())
	updateMaximalSampleProject(ctx, obj2)
	assert.NoError(t, obj2.Save(ctx))
	defer deleteSampleProject(ctx, obj2)

	obj3, _ := LoadProject(ctx, obj2.PrimaryKey(), node.Project().Manager(),
		node.Project().Parent(),
		node.Project().Children(),
		node.Project().ProjectMilestones(),
		node.Project().TeamMembers(),
	)
	_ = obj3 // avoid error if there are no references

	assert.Equal(t, obj2.Manager().PrimaryKey(), obj3.Manager().PrimaryKey())
	assert.Equal(t, obj2.Parent().PrimaryKey(), obj3.Parent().PrimaryKey())

	assert.Equal(t, len(obj2.Children()), len(obj3.Children()))
	assert.Equal(t, len(obj2.ProjectMilestones()), len(obj3.ProjectMilestones()))

	assert.Equal(t, len(obj2.TeamMembers()), len(obj3.TeamMembers()))

}

func TestProject_ReferenceUpdateOldObjects(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleProject(ctx)
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	updateMinimalSamplePerson(obj.Manager())
	updateMinimalSampleProject(obj.Parent())
	updateMinimalSampleProject(obj.Children()[0])
	updateMinimalSampleMilestone(obj.ProjectMilestones()[0])
	updateMinimalSamplePerson(obj.TeamMembers()[0])

	assert.NoError(t, obj.Save(ctx))

	obj2, _ := LoadProject(ctx, obj.PrimaryKey(), node.Project().ID(),
		node.Project().Num(),
		node.Project().StatusEnum(),
		node.Project().Name(),
		node.Project().Description(),
		node.Project().StartDate(),
		node.Project().EndDate(),
		node.Project().Budget(),
		node.Project().Spent(),
		node.Project().Children(),
		node.Project().ProjectMilestones(),
		node.Project().TeamMembers(),
	)
	_ = obj2 // avoid error if there are no references

	assertEqualFieldsPerson(t, obj2.Manager(), obj.Manager())
	assertEqualFieldsProject(t, obj2.Parent(), obj.Parent())

	assertEqualFieldsProject(t, obj2.Children()[0], obj.Children()[0])
	assertEqualFieldsMilestone(t, obj2.ProjectMilestones()[0], obj.ProjectMilestones()[0])

	assertEqualFieldsPerson(t, obj2.TeamMembers()[0], obj.TeamMembers()[0])
}
func TestProject_EmptyPrimaryKeyGetter(t *testing.T) {
	obj := NewProject()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)
}

func TestProject_Getters(t *testing.T) {
	obj := createMinimalSampleProject()

	i, err := strconv.Atoi(obj.ID())
	assert.NoError(t, err)
	assert.True(t, i < 0)

	ctx := context.Background()
	require.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	has, _ := HasProject(ctx, obj.PrimaryKey())
	assert.True(t, has)

	obj2, _ := LoadProject(ctx, obj.PrimaryKey(),
		node.Project().ID())

	assert.Equal(t, obj.ID(), obj.Get(node.Project().ID().Identifier))
	assert.Equal(t, obj.Num(), obj.Get(node.Project().Num().Identifier))
	assert.Panics(t, func() { obj2.Num() })
	assert.Nil(t, obj2.Get(node.Project().Num().Identifier))
	assert.Equal(t, obj.StatusEnum(), obj.Get(node.Project().StatusEnum().Identifier))
	assert.Panics(t, func() { obj2.StatusEnum() })
	assert.Nil(t, obj2.Get(node.Project().StatusEnum().Identifier))
	assert.Equal(t, obj.Name(), obj.Get(node.Project().Name().Identifier))
	assert.Panics(t, func() { obj2.Name() })
	assert.Nil(t, obj2.Get(node.Project().Name().Identifier))
	assert.Equal(t, obj.Description(), obj.Get(node.Project().Description().Identifier))
	assert.Panics(t, func() { obj2.Description() })
	assert.Nil(t, obj2.Get(node.Project().Description().Identifier))
	assert.Equal(t, obj.StartDate(), obj.Get(node.Project().StartDate().Identifier))
	assert.Panics(t, func() { obj2.StartDate() })
	assert.Nil(t, obj2.Get(node.Project().StartDate().Identifier))
	assert.Equal(t, obj.EndDate(), obj.Get(node.Project().EndDate().Identifier))
	assert.Panics(t, func() { obj2.EndDate() })
	assert.Nil(t, obj2.Get(node.Project().EndDate().Identifier))
	assert.Equal(t, obj.Budget(), obj.Get(node.Project().Budget().Identifier))
	assert.Panics(t, func() { obj2.Budget() })
	assert.Nil(t, obj2.Get(node.Project().Budget().Identifier))
	assert.Equal(t, obj.Spent(), obj.Get(node.Project().Spent().Identifier))
	assert.Panics(t, func() { obj2.Spent() })
	assert.Nil(t, obj2.Get(node.Project().Spent().Identifier))
}

func TestProject_QueryLoad(t *testing.T) {
	obj := createMinimalSampleProject()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	objs, err := QueryProjects(ctx).
		Where(op.Equal(node.Project().ID(), obj.ID())).
		OrderBy(node.Project().ID()). // exercise order by
		Limit(1, 0).                  // exercise limit
		Calculation(node.Project(), "IsTrue", op.Equal("A", "A")).
		Load()
	assert.NoError(t, err)
	assert.Equal(t, obj.PrimaryKey(), objs[0].PrimaryKey())
	assert.True(t, objs[0].GetAlias("IsTrue").Bool())
}
func TestProject_QueryLoadI(t *testing.T) {
	obj := createMinimalSampleProject()
	ctx := context.Background()
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleProject(ctx, obj)

	objs, _ := QueryProjects(ctx).
		Where(op.Equal(node.Project().ID(), obj.ID())).
		LoadI()

	assert.Equal(t, obj.PrimaryKey(), objs[0].Get("ID"))
}
func TestProject_QueryCursor(t *testing.T) {
	obj := createMinimalSampleProject()
	ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
	defer deleteSampleProject(ctx, obj)

	cursor, err := QueryProjects(ctx).
		Where(op.Equal(node.Project().ID(), obj.ID())).
		LoadCursor()
	require.NoError(t, err)
	obj2, err2 := cursor.Next()
	assert.Equal(t, obj.PrimaryKey(), obj2.PrimaryKey())
	require.NoError(t, err2)
	obj2, err2 = cursor.Next()
	assert.Nil(t, obj2)
	require.NoError(t, err2)
	assert.NoError(t, cursor.Close())

	// test empty cursor result
	cursor, err = QueryProjects(ctx).
		Where(op.Equal("B", "A")).
		LoadCursor()
	require.NoError(t, err)

	obj2, err = cursor.Next()
	assert.Nil(t, obj2)
	require.NoError(t, err)
	assert.NoError(t, cursor.Close())
}
func TestProject_Count(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleProject(ctx)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleProject(ctx, obj)
	assert.Positive(t, func() int { i, _ := CountProjects(ctx); return i }())

	// reread in case there are data limitations imposed by the database
	obj2, _ := LoadProject(ctx, obj.PrimaryKey())
	assert.Positive(t,
		func() int {
			i, _ := CountProjectsByNum(ctx,
				obj2.Num())
			return i
		}())
	assert.Positive(t,
		func() int {
			i, _ := CountProjectsByStatusEnum(ctx,
				obj2.StatusEnum())
			return i
		}())
	assert.Positive(t,
		func() int {
			i, _ := CountProjectsByManagerID(ctx,
				obj2.ManagerID())
			return i
		}())
	assert.Positive(t,
		func() int {
			i, _ := CountProjectsByParentID(ctx,
				obj2.ParentID())
			return i
		}())

}

func TestProject_MarshalJSON(t *testing.T) {
	obj := createMinimalSampleProject()

	b, err := json.Marshal(obj)
	assert.NoError(t, err)

	obj2 := NewProject()
	err = json.Unmarshal(b, &obj2)
	assert.NoError(t, err)

	assertEqualFieldsProject(t, obj, obj2)
}

func TestProject_MarshalBinary(t *testing.T) {
	obj := createMinimalSampleProject()

	b, err := obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 := NewProject()
	err = obj2.UnmarshalBinary(b)
	assert.NoError(t, err)

	assertEqualFieldsProject(t, obj, obj2)
}

func TestProject_FailingMarshalBinary(t *testing.T) {
	obj := createMinimalSampleProject()
	var err error

	for i := 0; i < 41; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
	// do it again with aliases
	obj._aliases = make(map[string]any)
	for i := 0; i < 42; i++ {
		enc := &test.GobEncoder{Count: i}
		err = obj.encodeTo(enc)
		assert.Error(t, err)
	}
}

func TestProject_FailingUnmarshalBinary(t *testing.T) {
	obj := createMinimalSampleProject()
	b, err := obj.MarshalBinary()
	assert.NoError(t, err)
	obj2 := NewProject()
	for i := 0; i < 41; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}

	// do it again with aliases
	obj = createMinimalSampleProject()
	obj._aliases = map[string]any{"a": 1}
	b, err = obj.MarshalBinary()
	assert.NoError(t, err)

	obj2 = NewProject()
	for i := 0; i < 42; i++ {
		buf := bytes.NewReader(b)
		dec := &test.GobDecoder{Decoder: gob.NewDecoder(buf), Count: i}
		err = obj2.decodeFrom(dec)
		assert.Error(t, err)
	}
}

func TestProject_Indexes(t *testing.T) {
	ctx := context.Background()
	obj := createMaximalSampleProject(ctx)
	err := obj.Save(ctx)
	assert.NoError(t, err)
	defer deleteSampleProject(ctx, obj)

	var obj2 *Project
	obj2, _ = LoadProjectByNum(ctx, obj.Num())
	assert.Equal(t, obj.PrimaryKey(), obj2.PrimaryKey())
	assert.True(t, func() bool { h, _ := HasProjectByNum(ctx, obj.Num()); return h }())

}
