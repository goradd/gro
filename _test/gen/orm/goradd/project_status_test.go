// Code generated by goradd-orm. DO NOT EDIT.

package goradd

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	strings2 "github.com/goradd/strings"
	"github.com/goradd/orm/pkg/test"
	"testing"
)

func TestProjectStatus_String(t *testing.T) {
    assert.Equal(t, ProjectStatusOpen.String(), "ProjectStatusOpen")
    assert.Equal(t, ProjectStatusCancelled.String(), "ProjectStatusCancelled")
    assert.Equal(t, ProjectStatusCompleted.String(), "ProjectStatusCompleted")
    assert.Equal(t, ProjectStatusPlanned.String(), "ProjectStatusPlanned")
}

func TestProjectStatus_(t *testing.T) {
    assert.Equal(t, ProjectStatusOpen.(), "The project is currently active")
    assert.Equal(t, ProjectStatusCancelled.(), "The project has been canned")
    assert.Equal(t, ProjectStatusCompleted.(), "The project has been completed successfully")
    assert.Equal(t, ProjectStatusPlanned.(), "Project is in the planning stages and has not been assigned a manager")
    assert.Zero(t, ProjectStatus(0).())
    assert.Panics(t, func() {
        ProjectStatus(-1).()
    })
}

func TestProjectStatus_Slice(t *testing.T) {
    a := ProjectStatus()
    assert.Equal(t, ProjectStatusOpen.(), a[0])
    assert.Equal(t, ProjectStatusCancelled.(), a[1])
    assert.Equal(t, ProjectStatusCompleted.(), a[2])
    assert.Equal(t, ProjectStatusPlanned.(), a[3])
}

func TestProjectStatus_(t *testing.T) {
    assert.Equal(t, ProjectStatusOpen.(), "All projects that we are working on should be in this state")
    assert.Equal(t, ProjectStatusCancelled.(), "")
    assert.Equal(t, ProjectStatusCompleted.(), "Celebrate successes!")
    assert.Equal(t, ProjectStatusPlanned.(), "Get ready")
    assert.Zero(t, ProjectStatus(0).())
    assert.Panics(t, func() {
        ProjectStatus(-1).()
    })
}

func TestProjectStatus_Slice(t *testing.T) {
    a := ProjectStatus()
    assert.Equal(t, ProjectStatusOpen.(), a[0])
    assert.Equal(t, ProjectStatusCancelled.(), a[1])
    assert.Equal(t, ProjectStatusCompleted.(), a[2])
    assert.Equal(t, ProjectStatusPlanned.(), a[3])
}

func TestProjectStatus_(t *testing.T) {
    assert.Equal(t, ProjectStatusOpen.(), true)
    assert.Equal(t, ProjectStatusCancelled.(), true)
    assert.Equal(t, ProjectStatusCompleted.(), true)
    assert.Equal(t, ProjectStatusPlanned.(), false)
    assert.Zero(t, ProjectStatus(0).())
    assert.Panics(t, func() {
        ProjectStatus(-1).()
    })
}

func TestProjectStatus_Slice(t *testing.T) {
    a := ProjectStatus()
    assert.Equal(t, ProjectStatusOpen.(), a[0])
    assert.Equal(t, ProjectStatusCancelled.(), a[1])
    assert.Equal(t, ProjectStatusCompleted.(), a[2])
    assert.Equal(t, ProjectStatusPlanned.(), a[3])
}

func TestProjectStatus_Key(t *testing.T) {
    assert.Equal(t, ProjectStatusOpen.Key(), <nil>)
    assert.Equal(t, ProjectStatusCancelled.Key(), <nil>)
    assert.Equal(t, ProjectStatusCompleted.Key(), <nil>)
    assert.Equal(t, ProjectStatusPlanned.Key(), <nil>)
    assert.Zero(t, ProjectStatus(0).Key())
    assert.Panics(t, func() {
        ProjectStatus(-1).Key()
    })
}

func TestProjectStatus_KeySlice(t *testing.T) {
    a := ProjectStatusKeys()
    assert.Equal(t, ProjectStatusOpen.Key(), a[0])
    assert.Equal(t, ProjectStatusCancelled.Key(), a[1])
    assert.Equal(t, ProjectStatusCompleted.Key(), a[2])
    assert.Equal(t, ProjectStatusPlanned.Key(), a[3])
}


func TestProjectStatus_Keys(t *testing.T) {
    var keys []string

    keys = append(keys, ProjectStatusOpen.Key())
    keys = append(keys, ProjectStatusCancelled.Key())
    keys = append(keys, ProjectStatusCompleted.Key())
    keys = append(keys, ProjectStatusPlanned.Key())
    v := ProjectStatusesFromKeys(keys)
    assert.Equal(t, ProjectStatuses(), v)

    assert.Equal(t, ProjectStatus(0), ProjectStatusFromKey(""))
}

func TestProjectStatus_Values(t *testing.T) {
    a1 := ProjectStatuses()
    a2 := ProjectStatusesI()
    for i,v1 := range a1 {
        assert.Equal(t, v1, a2[i].(ProjectStatus))
        assert.True(t, IsValidProjectStatus(int(v1)))
    }
    assert.False(t, IsValidProjectStatus(0))
}

func TestProjectStatus_FromIdentifier(t *testing.T) {
    var v ProjectStatus
    var err error

    v,err = ProjectStatusFromIdentifier(ProjectStatus(1).Identifier())
    assert.NoError(t, err)
    assert.Equal(t, ProjectStatus(1), v)
    v,err = ProjectStatusFromIdentifier(ProjectStatus(2).Identifier())
    assert.NoError(t, err)
    assert.Equal(t, ProjectStatus(2), v)
    v,err = ProjectStatusFromIdentifier(ProjectStatus(3).Identifier())
    assert.NoError(t, err)
    assert.Equal(t, ProjectStatus(3), v)
    v,err = ProjectStatusFromIdentifier(ProjectStatus(4).Identifier())
    assert.NoError(t, err)
    assert.Equal(t, ProjectStatus(4), v)
}

func TestProjectStatus_FromInterface(t *testing.T) {
    v := ProjectStatusOpen

    v2,err := ProjectStatusFromInterface(int(v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = ProjectStatusFromInterface(float64(v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = ProjectStatusFromInterface(json.Number(fmt.Sprintf("%d", v)))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = ProjectStatusFromInterface(fmt.Sprintf("%d", v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = ProjectStatusFromInterface(0)
    assert.Error(t, err)
    assert.Equal(t, ProjectStatus(0), v2)

    var t1 time.Time
    v2,err = ProjectStatusFromInterface(t1)
    assert.Error(t, err)
    assert.Equal(t, ProjectStatus(0), v2)
}

func TestProjectStatus_UnmarshalJSON(t *testing.T) {
	tests := []struct {
		input    string
		expected ProjectStatus
		wantErr  bool
	}{
		// Integer JSON
		{input: `1`, expected: ProjectStatusOpen, wantErr: false},
		// Float JSON
		{input: `1.0`, expected: ProjectStatusOpen, wantErr: false},
		// Stringified numbers
		{input: `"1"`, expected: ProjectStatusOpen, wantErr: false},
		// Invalid values
		{input: `"1.1.1"`, expected: ProjectStatus(0), wantErr: true},
	}

	for _, tt := range tests {
		var s ProjectStatus
		err := json.Unmarshal([]byte(tt.input), &s)
		if (err != nil) != tt.wantErr {
			t.Errorf("UnmarshalJSON(%s) error = %v, wantErr %v", tt.input, err, tt.wantErr)
			continue
		}
		if err == nil && s != tt.expected {
			t.Errorf("UnmarshalJSON(%s) = %v, want %v", tt.input, s, tt.expected)
		}
	}
}

