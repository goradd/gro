package model

import (
	"fmt"
	"github.com/gedex/inflector"
	"github.com/goradd/goradd/pkg/strings"
	. "github.com/goradd/orm/pkg/query"
	"github.com/goradd/orm/pkg/schema"
	strings2 "github.com/goradd/strings"
	"time"
)

const (
	currentTime = "now"
)

// Column describes a database column. Most of the information is either
// gleaned from the structure of the database, or is taken from a file that describes the relationships between
// different record types. Some information is filled in after analysis. Some information can be
// provided through information embedded in database comments.
type Column struct {
	// QueryName is the name of the column in the database.
	QueryName string
	// Table is a pointer back to the table that this column is part of
	Table *Table
	// Identifier is the name of the column in go code.
	Identifier string
	// DecapIdentifier is a cache for the lower case identifier for the column.
	DecapIdentifier string
	//  Type indicates the Go type that matches the column.
	Type ReceiverType
	// Size is the maximum length of runes to allow in the column if a string type column.
	// If a byte array, it is the number of bytes permitted.
	// If an attempt at entering more than this amount occurs, it is considered a programming bug
	// and we will panic.
	// If an integer or float type, it is the number of bits in the data type.
	Size uint64
	// DefaultValue is the default value as specified by the database. We will initialize new ORM objects
	// with this value.
	DefaultValue interface{}
	// IsAutoId is true if this column represents a unique identifier automatically generated by the database or database driver.
	IsAutoId bool
	// IsPk is true if this is the single primary key column.
	// Multi-column primary keys are handled by multi-column indexes.
	IsPk bool
	// IsNullable is true if the column can be given a NULL value.
	IsNullable bool
	// IsUnique is true if the column's table has a single unique index on the column.
	IsUnique bool
	// Reference is additional information describing a foreign key relationship
	Reference *Reference
	// Options are the options extracted from the comments string
	Options map[string]interface{}
}

// DefaultConstantName returns the name of the default value constant that will be used to refer to the default value
func (cd *Column) DefaultConstantName() string {
	title := cd.Table.Identifier + cd.Identifier + "Default"
	return title
}

func (cd *Column) VariableIdentifier() string {
	return cd.DecapIdentifier
}

func (cd *Column) VariableIdentifierPlural() string {
	return inflector.Pluralize(cd.DecapIdentifier)
}

// DefaultValueAsValue returns the default value of the column as a GO value
func (cd *Column) DefaultValueAsValue() string {
	if cd.DefaultValue == nil {
		if cd.IsAutoId || cd.IsReference() {
			return `""`
		}
		return cd.Type.DefaultValueString()
	} else {
		if cd.Type == ColTypeTime {
			if cd.DefaultValue == currentTime {
				return "time.Now().UTC()"
			} else {
				t := cd.DefaultValue.(time.Time)
				if t.IsZero() {
					return "time.Time{}"
				}
				return fmt.Sprintf("time2.NewDateTime(%d, %d, %d, %d, %d, %d, %d)", t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond())
			}
		}
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

// DefaultValueAsConstant returns the default value of the column as a Go constant
func (cd *Column) DefaultValueAsConstant() string {
	if cd.Type == ColTypeTime {
		if cd.DefaultValue == currentTime {
			return `time2.Current`
		} else if cd.DefaultValue == nil {
			return `time2.Zero`
		} else {
			d := cd.DefaultValue.(time.Time)
			if b, _ := d.MarshalText(); b == nil {
				return `time2.Zero`
			} else {
				s := string(b[:])
				return fmt.Sprintf("%#v", s)
			}
		}
	} else if cd.DefaultValue == nil || cd.IsAutoId {
		v := cd.Type.DefaultValueString()
		if v == "nil" {
			return ""
		}
		return cd.Type.DefaultValueString()
	} else {
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

// JsonKey returns the key used for the column when outputting JSON.
func (cd *Column) JsonKey() string {
	return cd.DecapIdentifier
}

// IsReference returns true if the column is a reference to an object in another table.
func (cd *Column) IsReference() bool {
	return cd.Reference != nil && cd.Reference.Table != nil
}

// IsEnumReference returns true if the column contains a type defined by a enum table.
func (cd *Column) IsEnumReference() bool {
	return cd.Reference != nil && cd.Reference.EnumTable != nil
}

// ReferenceIdentifier returns the capitalizde name that should be used to refer to the object
// in a forward reference. This is not the object's type.
func (cd *Column) ReferenceIdentifier() string {
	return strings.If(cd.Reference == nil, "", cd.Reference.Identifier)
}

// ReferenceType returns the name of the Go struct type in a forward reference.
func (cd *Column) ReferenceType() string {
	return strings.If(cd.Reference == nil, "", cd.Reference.Table.Identifier)
}

// ReferenceVariableIdentifier returns the name of the local variable that will
// hold the object loaded in the reference.
func (cd *Column) ReferenceVariableIdentifier() string {
	if cd.Reference == nil {
		return ""
	} else {
		return "obj" + cd.Reference.Identifier
	}
}

// ReverseIdentifier returns the function name that should be used to refer to the object
// that is referred to by the reverse reference.
func (cd *Column) ReverseIdentifier() string {
	if cd.Reference == nil {
		return ""
	} else if cd.IsUnique {
		return cd.Reference.ReverseIdentifier
	} else {
		return cd.Reference.ReverseIdentifierPlural
	}
}

// ReverseVariableIdentifier returns the name of the local variable that will
// hold the object(s) loaded in the reverse reference.
func (cd *Column) ReverseVariableIdentifier() string {
	if cd.Reference == nil {
		return ""
	} else {
		if cd.IsUnique {
			return "rev" + cd.Reference.ReverseIdentifier
		} else {
			return "rev" + cd.Reference.ReverseIdentifierPlural
		}
	}
}

// ReversePkIdentifier is the identifier to use for the local primary key storage of a reference.
func (cd *Column) ReversePkIdentifier() string {
	if cd.Reference == nil {
		return ""
	}
	if cd.IsUnique {
		return "rev" + cd.Reference.ReverseIdentifier + "Pk"
	} else {
		return "rev" + cd.Reference.ReverseIdentifierPlural + "Pks"
	}
}

// ReferenceJsonKey returns the key that will be used for the referenced object in JSON.
func (cd *Column) ReferenceJsonKey() string {
	if cd.Reference == nil {
		return ""
	}
	return cd.Reference.DecapIdentifier
}

// ReverseJsonKey returns the key that will be used for the reverse referenced object in JSON.
func (cd *Column) ReverseJsonKey() string {
	if cd.Reference == nil {
		return ""
	}
	if cd.IsUnique {
		return LowerCaseIdentifier(cd.Reference.ReverseIdentifier)
	} else {
		return LowerCaseIdentifier(cd.Reference.ReverseIdentifierPlural)
	}
}

// GoType returns the Go variable type corresponding to the column.
func (cd *Column) GoType() string {
	if cd.Reference != nil && cd.Reference.Table.PrimaryKeyColumn().IsAutoId {
		return "string" // auto id keys are always strings
	}
	return cd.Type.GoType()
}

func newColumn(schemaCol *schema.Column) *Column {
	col := &Column{
		QueryName:       schemaCol.Name,
		Identifier:      schemaCol.Identifier,
		DecapIdentifier: strings2.Decap(schemaCol.Identifier),
		Type:            ReceiverTypeFromSchema(schemaCol.Type, schemaCol.Size),
		Size:            schemaCol.Size,
		DefaultValue:    schemaCol.DefaultValue,
		IsAutoId:        schemaCol.Type == schema.ColTypeAutoPrimaryKey,
		IsPk:            schemaCol.Type == schema.ColTypeAutoPrimaryKey || schemaCol.IndexLevel == schema.IndexLevelManualPrimaryKey,
		IsNullable:      schemaCol.IsOptional,
		IsUnique: schemaCol.Type == schema.ColTypeAutoPrimaryKey ||
			schemaCol.IndexLevel == schema.IndexLevelManualPrimaryKey ||
			schemaCol.IndexLevel == schema.IndexLevelUnique,
	}

	if col.IsAutoId {
		col.Type = ColTypeString // We treat auto-generated ids as strings for cross database compatibility.
	}

	return col
}
