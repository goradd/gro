package model

import (
	"fmt"
	strings2 "github.com/goradd/strings"
	. "spekary/goradd/orm/pkg/query"
	"spekary/goradd/orm/pkg/schema"
	"strings"
	"time"
)

const (
	currentTime = "now"
)

// Column describes a database column. Most of the information is either
// gleaned from the structure of the database, or is taken from a file that describes the relationships between
// different record types. Some information is filled in after analysis. Some information can be
// provided through information embedded in database comments.
type Column struct {
	// QueryName is the name of the column in the database.
	QueryName string
	// Table is a pointer back to the table that this column is part of
	Table *Table
	// Identifier is the name of the column in go code.
	Identifier string
	// DecapIdentifier is a cache for the lower case identifier for the column.
	DecapIdentifier string
	//  Type indicates the Go type that matches the column.
	Type ReceiverType
	// MaxLength is the maximum length of runes to allow in the column if a string type column.
	// If an attempt at entering more than this amount occurs, we will panic.
	// If an integer or float type, its the number of bits in the data type.
	// If a byte array, its the number of bytes permitted.
	MaxLength uint64
	// DefaultValue is the default value as specified by the database. We will initialize new ORM objects
	// with this value. Call DefaultValueAsValue
	DefaultValue interface{}
	// IsAutoId is true if this column represents a unique identifier automatically generated by the database or database driver.
	IsAutoId bool
	// IsPk is true if this is the single primary key column.
	// Multi-column primary keys are handled by multi-column indexes.
	IsPk bool
	// IsNullable is true if the column can be given a NULL value.
	IsNullable bool
	// IsUnique is true if the column's table has a single unique index on the column.
	IsUnique bool
	// Reference is additional information describing a foreign key relationship
	Reference *Reference
	// ReverseReferences are the columns from other tables, or even this table,
	// that point to this column.
	ReverseReferences []*Column
	// Options are the options extracted from the comments string
	Options map[string]interface{}
}

// ModelName returns the name of the column
func (cd *Column) ModelName() string {
	return cd.DecapIdentifier
}

// DefaultConstantName returns the name of the default value constant that will be used to refer to the default value
func (cd *Column) DefaultConstantName(tableName string) string {
	title := tableName + cd.Identifier + "Default"
	return title
}

// DefaultValueAsValue returns the default value of the column as a GO value
func (cd *Column) DefaultValueAsValue() string {
	if cd.DefaultValue == nil || cd.IsAutoId {
		v := cd.Type.DefaultValue()
		if v == "" {
			return "nil"
		} else {
			return v
		}
	} else if cd.Type == ColTypeTime {
		if cd.DefaultValue == currentTime {
			return "time.Now().UTC()"
		} else {
			t := cd.DefaultValue.(time.Time)
			return fmt.Sprintf("time2.NewDateTime(%d, %d, %d, %d, %d, %d, %d)", t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond())
		}
	} else {
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

// DefaultValueAsConstant returns the default value of the column as a Go constant
func (cd *Column) DefaultValueAsConstant() string {
	if cd.Type == ColTypeTime {
		if cd.DefaultValue == currentTime {
			return `time2.Current`
		} else if cd.DefaultValue == nil {
			return `time2.Zero`
		} else {
			d := cd.DefaultValue.(time.Time)
			if b, _ := d.MarshalText(); b == nil {
				return `time2.Zero`
			} else {
				s := string(b[:])
				return fmt.Sprintf("%#v", s)
			}
		}
	} else if cd.DefaultValue == nil || cd.IsAutoId {
		return cd.Type.DefaultValue()
	} else {
		return fmt.Sprintf("%#v", cd.DefaultValue)
	}
}

// JsonKey returns the key used for the column when outputting JSON.
func (cd *Column) JsonKey() string {
	return cd.DecapIdentifier
}

// IsReference returns true if the column is a reference to an object in another table.
func (cd *Column) IsReference() bool {
	return cd.Reference != nil && cd.Reference.Table != nil
}

// IsEnum returns true if the column contains a type defined by a enum table.
func (cd *Column) IsEnum() bool {
	return cd.Reference != nil && cd.Reference.EnumTable != nil
}

// ReferenceFunction returns the function name that should be used to refer to the object
// that is referred to by a forward reference.
func (cd *Column) ReferenceFunction() string {
	return cd.Reference.ReverseIdentifier
}

// ReferenceJsonKey returns the key that will be used for the referenced object in JSON.
func (cd *Column) ReferenceJsonKey(dd *Database) string {
	return LowerCaseIdentifier(strings.TrimSuffix(cd.QueryName, dd.ReferenceSuffix))
}

// GoType returns the Go variable type corresponding to the column.
func (cd *Column) GoType() string {
	return cd.Type.GoType()
}

func newColumn(schemaCol *schema.Column) *Column {
	col := &Column{
		QueryName:    schemaCol.Name,
		Identifier:   schemaCol.Identifier,
		Type:         ReceiverTypeFromSchema(schemaCol.Type, schemaCol.Size),
		MaxLength:    schemaCol.Size,
		DefaultValue: schemaCol.DefaultValue,
		IsAutoId:     schemaCol.Type == schema.ColTypeAutoPrimaryKey,
		IsPk:         schemaCol.Type == schema.ColTypeAutoPrimaryKey || schemaCol.IndexLevel == schema.IndexLevelManualPrimaryKey,
		IsNullable:   schemaCol.IsOptional,
		IsUnique: schemaCol.Type == schema.ColTypeAutoPrimaryKey ||
			schemaCol.IndexLevel == schema.IndexLevelManualPrimaryKey ||
			schemaCol.IndexLevel == schema.IndexLevelUnique,
	}

	if col.IsAutoId {
		col.Type = ColTypeString // We treat auto-generated ids as strings for cross database compatibility.
	}

	col.DecapIdentifier = strings2.Decap(col.Identifier)

	return col
}
