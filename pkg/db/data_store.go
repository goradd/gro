package db

import (
	"context"
	"errors"
	"iter"

	. "github.com/goradd/gro/pkg/query"
	"github.com/goradd/gro/pkg/schema"
	"github.com/goradd/maps"
)

// List of supported database drivers
const (
	DriverTypeMysql    = "mysql"
	DriverTypePostgres = "postgres"
	DriverTypeSQLite   = "sqlite"
)

// The dataStore is the central database collection used in code generation and the orm.
var datastore maps.SliceMap[string, DatabaseI]

type SchemaExtractor interface {
	ExtractSchema(options map[string]any) schema.Database
}

type SchemaRebuilder interface {
	DestroySchema(ctx context.Context, s schema.Database) error
	CreateSchema(ctx context.Context, s schema.Database) error
}

// DatabaseI is the interface that describes the behaviors required for a database implementation.
//
// Time values are converted to whatever time format the database prefers.
//
// JSON values must already be encoded as strings or []byte values.
//
// If where is not nil, it specifies fields and values that will limit the search.
// Multiple field-value combinations will be Or'd together.
// If a value is a map[string]any type, its key is ignored, and the keys and values of the enclosed type will be
// And'd together. This Or-And pattern is recursive.
// If a value is a slice of int or strings, those values will be put in an "IN" test.
// For example, {"vals":[]int{1,2,3}} will result in SQL of "vals IN (1,2,3)".
type DatabaseI interface {
	// Update sets specific fields of a single record that exists in the database.
	// optLockFieldName is the name of a version field that will implement an optimistic locking check while doing the update.
	// If optLockFieldName is provided:
	//   - That field will be used to limit the update,
	//   - That field will be updated with a new version and returned in changes.
	//   - If the record was previously deleted or updated, an OptimisticLockError will be returned.
	//     You will need to query further to determine if the record still exists.
	//
	// Otherwise, if optLockFieldName is blank, and the record we are attempting to change does not exist, the database
	// will not be altered, and no error will be returned.
	Update(ctx context.Context, table string, primaryKey map[string]any, changes map[string]any, optLockFieldName string, optLockFieldValue int64) error
	// Insert will insert a new record into the database with the given values.
	// If autoPkKey is specified and it is not present in fields, it will be generated by the database or
	// the driver, and returned in fields.
	// All references to auto primary keys should be marked as references.
	// Make sure fields has all the required values for the record.
	Insert(ctx context.Context, table string, fields map[string]any, autoPkKey string) error
	// Delete will delete a single record from the database.
	// If optLockFieldName is provided, the optLockFieldValue will also constrain Delete, and if no
	// records are found, it will return an OptimisticLockError. If optLockFieldName is empty, and
	// no record is found, a NoRecordFound error will be returned.
	// Care should be exercised when calling this directly, since linked records are not modified in any way.
	// If this record has linked records, the database structure may be corrupted.
	Delete(ctx context.Context, table string, primaryKey map[string]any, optLockFieldName string, optLockFieldValue int64) error
	// DeleteWhere will delete records from table with the criteria where.
	// If where is empty, all records in the table will be deleted.
	// The values in where are initially AND'd. Maps in where will be OR'd, and maps inside OR'd values will be
	// AND'd etc.
	DeleteWhere(ctx context.Context, table string, where map[string]any) error
	// Query executes a simple query on a single table using fields, where the keys of fields are the names of database fields to select,
	// and the values are the types of data to return for each field.
	// If orderBy is not nil, it specifies field names to sort the data on, in ascending order.
	// If the database supports transactions and row locking, and a transaction is active, it will lock the rows read, and
	// depending on the setting in the transaction, it will be either a read or a write lock.
	Query(ctx context.Context, table string, fields map[string]ReceiverType, where map[string]any, orderBy []string) (CursorI, error)
	// BuilderQuery performs a complex query using a query builder.
	// The data returned will depend on the command inside the builder.
	BuilderQuery(ctx context.Context, builder *Builder) (any, error)
}

// AddDatabase adds a database to the global database store. Only call this during app startup.
func AddDatabase(d DatabaseI, key string) {
	datastore.Set(key, d)
}

// GetDatabase returns the database given the database's key.
func GetDatabase(key string) DatabaseI {
	return datastore.Get(key)
}

// DatabaseIter returns an iterator over the databases in key order.
func DatabaseIter() iter.Seq2[string, DatabaseI] {
	return datastore.All()
}

type transactioner interface {
	WithTransaction(ctx context.Context, f func(ctx context.Context) error) error
}

// WithTransaction wraps the function f in a database transaction if the driver supports transactions.
// Otherwise, just executes f with ctx.
//
// While the ORM by default will wrap individual database calls with a timeout,
// it will not apply this timeout to a transaction. It is up to you to pass a context that
// has a timeout to prevent the overall transaction from hanging.
func WithTransaction(ctx context.Context, d DatabaseI, f func(ctx context.Context) error) error {
	if t, ok := d.(transactioner); ok {
		return t.WithTransaction(ctx, f)
	}
	return f(ctx) // pass through without transaction
}

type constrainter interface {
	WithConstraintsOff(ctx context.Context, f func(ctx context.Context) error) error
}

// WithConstraintsOff turns off constraints for databases that support foreign key constraints.
// Otherwise, will just call f with ctx.
func WithConstraintsOff(ctx context.Context, d DatabaseI, f func(ctx context.Context) error) error {
	if c, ok := d.(constrainter); ok {
		return c.WithConstraintsOff(ctx, f)
	}
	return f(ctx) // pass through without constraint change
}

// AssociateOnly resets a many-many relationship in the database.
// The assnTable is the name of the association table that contains the many-many relationships.
// The srcColumnName is the name of the column that points to the primary key in the source table.
// The value of that column is pk.
// The relatedColumnName is the name of the column in the association table that points to the destination table's primary key.
// with relatedPks having all the primary keys of objects that should be associated with the object with
// primary key pk.
// All previous associations with the source object are deleted.
func AssociateOnly[J, K any](ctx context.Context,
	d DatabaseI,
	assnTable string,
	srcColumnName string,
	pk J,
	relatedColumnName string,
	relatedPks []K) error {
	err := WithTransaction(ctx, d, func(ctx context.Context) error {
		if err := d.DeleteWhere(ctx, assnTable, map[string]any{srcColumnName: pk}); err != nil {
			var rErr *RecordNotFoundError
			if !errors.As(err, &rErr) { // ignore record not found errors
				return err
			}
		}
		for _, relatedPk := range relatedPks {
			if err := Associate(ctx, d, assnTable, srcColumnName, pk, relatedColumnName, relatedPk); err != nil {
				return err
			}
		}
		return nil
	})
	return err
}

// Associate adds a record to the assnTable table.
func Associate[J, K any](ctx context.Context,
	d DatabaseI,
	assnTable string,
	srcColumnName string,
	pk J,
	relatedColumnName string,
	relatedPk K) error {
	err := d.Insert(ctx, assnTable, map[string]any{srcColumnName: pk, relatedColumnName: relatedPk}, "")
	return err
}
