//** This file was code generated by GoT. DO NOT EDIT. ***

package template

import (
	"io"

	"github.com/goradd/orm/pkg/codegen"
	"github.com/goradd/orm/pkg/model"
)

func init() {
	t := TableTemplate{}
	codegen.RegisterTemplate(&t)
}

// TableTemplate generates the code for tables.
// This is one-time generated and allows the programmer to edit it to override the base table code.
type TableTemplate struct {
	Package string
}

func (tmpl *TableTemplate) FileName(table *model.Table) string {
	return table.FileName() + ".go"
}

func (tmpl *TableTemplate) GenerateTable(table *model.Table, _w io.Writer, importPath string) (err error) {
	tmpl.Package = table.DbKey
	//*** table.tmpl

	// The master template for the table classes

	if _, err = io.WriteString(_w, `package `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, tmpl.Package); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `

// This is the implementation file for the `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` ORM object.
// This is where you build the api to your data model for your web application and potentially mobile apps.
// Your edits to this file will be preserved.

import (
    "fmt"
    "context"
)

// `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` represents an item in the `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.QueryName); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` table in the database.
type `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` struct {
	`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.DecapIdentifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Base
}

// New`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` creates a new `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` object and initializes it to default values.
func New`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `() *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` {
	o := new(`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `)
	o.Initialize()
	return o
}

// Initialize will initialize or re-initialize a `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` database object to default values.
func (o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `) Initialize() {
	o.`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.DecapIdentifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Base.Initialize()
    // Add your own initializations here
}

// String implements the Stringer interface and returns a description of the record, primarily for debugging.
func (o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `) String() string  {
    if o == nil {
        return ""
    }
    var pk string
    `); err != nil {
		return
	}

	for _, col := range table.PrimaryKeyColumns() {

		if _, err = io.WriteString(_w, `
    pk += fmt.Sprintf(" %v", o.`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, col.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `())
    `); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `
    return "`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `" + pk
}

// Key returns a unique key for the object, among a list of similar objects.
func (o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `) Key() string  {
    if o == nil {
        return ""
    }
    return fmt.Sprintf("%v", o.PrimaryKey())
}

// Label returns a human-readable label of the object.
// This would be what a user would see as a description of the object if choosing from a list.
func (o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `) Label() string  {
    if o == nil {
        return ""
    }
`); err != nil {
		return
	}

	if col := table.ColumnByName("name"); col != nil {

		if _, err = io.WriteString(_w, `    return o.`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, col.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `()
`); err != nil {
			return
		}

	} else {

		if _, err = io.WriteString(_w, `    return fmt.Sprintf("`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Label); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` %v", o.PrimaryKey())
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `}

// Save will update or insert the object, depending on the state of the object.
//
// If it has an auto-generated primary key, it will be updated after an insert.
// Database errors generally will be handled by a panic and not returned here,
// since those indicate a problem with a database driver or configuration.
//
// Save will return a db.OptimisticLockError if it detects a collision when two users
// are attempting to change the same database record.
//
// It will return a db.UniqueValueError if it detects a collision when an attempt
// is made to add a record with a unique column that is given a value that is already in the database.
//
// Updating a record that has not changed will have no effect on the database.
// Updating a record that has linked records will also update any linked records that are MODIFIED,
// and if optimistic locking is in effect, will also check whether those records have been altered or deleted,
// returning an OptimisticLockError if so.
func (o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `) Save(ctx context.Context) error {
    return o.save(ctx)
}


// Query`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.IdentifierPlural); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` returns a new query builder.
// See `); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Builder for doc on how to use the builder.
`); err != nil {
		return
	}

	if table.ReadTimeout == 0 {

		if _, err = io.WriteString(_w, `// You should pass a context that has a timeout with it to protect against a long delay from
// the database possibly hanging your application. You can set a ReadTimeout value on the schema
// to do this by default during code generation.
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `func Query`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.IdentifierPlural); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `(ctx context.Context) *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Builder {
	return query`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.IdentifierPlural); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `(ctx)
}

// query`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.IdentifierPlural); err != nil {
		return
	}

	if _, err = io.WriteString(_w, ` creates a new builder and is the central spot where all queries are directed.
// You can modify this function to enforce restrictions on queries, for example to make sure the user is authorized to
// access the data.
func query`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.IdentifierPlural); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `(ctx context.Context) *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Builder {
    // Note: the context is provided here so that you can use it to enforce credentials if needed.
    // It is stored in the builder and later used in the terminating functions, like Load(), Get(), etc.
    // A QueryBuilder is meant to be a short-lived structure.
	return new`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Builder(ctx)
}

// get`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `InsertFields returns fields and values that will be used for a new record in the database.
// You can add or modify the fields here before they are sent to the database. If you set a primary key, it will be
// used instead of a generated primary key.
func get`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `InsertFields(o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.DecapIdentifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Base) (fields map[string]interface{}) {
    return o.getInsertFields()
}

// get`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `UpdateFields returns fields and values that will be used to update a current record in
// the database.
// You can add or modify the fields here before they are sent to the database.
func get`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `UpdateFields(o *`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.DecapIdentifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `Base) (fields map[string]interface{}) {
    return o.getUpdateFields()
}


`); err != nil {
		return
	}

	if table.PrimaryKeyColumn() != nil {

		if _, err = io.WriteString(_w, `// Delete`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` deletes the `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.QueryName); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` record with primary key pk from the database.
// Note that you can also delete loaded `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, ` objects by calling Delete on them.
// Returns an error only if there was a problem with the database during the delete.
// If the record was not found, no error will be returned.
// doc: type=`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `
func Delete`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `(ctx context.Context, pk `); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.PrimaryKeyColumn().Type); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `) error {
	return delete`); err != nil {
			return
		}

		if _, err = io.WriteString(_w, table.Identifier); err != nil {
			return
		}

		if _, err = io.WriteString(_w, `(ctx, pk)
}
`); err != nil {
			return
		}

	}

	if _, err = io.WriteString(_w, `
func init() {
    gob.RegisterName("`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.DbKey); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `", new(`); err != nil {
		return
	}

	if _, err = io.WriteString(_w, table.Identifier); err != nil {
		return
	}

	if _, err = io.WriteString(_w, `))
}

`); err != nil {
		return
	}

	return
}

func (tmpl *TableTemplate) Overwrite() bool {
	return false
}
