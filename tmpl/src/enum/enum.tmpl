
{{g
//*** {{includeName}}
}}
func (tmpl *EnumTemplate)gen(table *model.Enum, _w io.Writer) (err error) {
    if err = tmpl.genHeader(table, _w); err != nil { return }
    if err = tmpl.genConstants(table, _w); err != nil { return }
    if err = tmpl.genUtil(table, _w); err != nil { return }
    if err = tmpl.genKey(table, _w); err != nil { return }
    if err = tmpl.genPlurals(table, _w); err != nil { return }
    if err = tmpl.genInterfaces(table, _w); err != nil { return }
    if err = tmpl.genFields(table, _w); err != nil { return }
    if err = tmpl.genMarshal(table, _w); err != nil { return }
    if err = tmpl.genSet(table, _w); err != nil { return }
    return
}

func (tmpl *EnumTemplate)genHeader(table *model.Enum, _w io.Writer) (err error) {
{{
// Code generated by goradd-orm. DO NOT EDIT.

package {{= tmpl.Package }}

import (
	"strconv"
	"github.com/goradd/maps"
    "sort"
	"encoding/gob"
)
}}
    return
}

func (tmpl *EnumTemplate)genConstants(table *model.Enum, _w io.Writer) (err error) {
{{
type {{= table.Identifier }} int

const (
}}

    maxKey := 0
    for _,con := range table.Constants {
        if con.Value > maxKey {
            maxKey = con.Value
        }
{{
	{{= table.Identifier }}{{= con.Name }} {{= table.Identifier }} = {{i con.Value }}
}}
    }

{{
)

// {{= table.Identifier }}MaxValue is the maximum enumerated value of {{= table.Identifier }}
// doc: type={{= table.Identifier }}
const {{= table.Identifier }}MaxValue = {{i maxKey }}

}}

    return
}


func (tmpl *EnumTemplate)genUtil(table *model.Enum, _w io.Writer) (err error) {
{{
// String returns the name value of the type and satisfies the fmt.Stringer interface
// This is used primarily for debugging
func (e {{= table.Identifier }}) String() string {
    switch e {
{{for _,c := range table.Constants }}
        case {{i c.Value }}: return "{{= table.Identifier }}{{= c.Name }}"
{{for}}
        default: return ""
    }
}

// IsValid{{= table.Identifier }} returns true if i can validly be converted to a {{= table.Identifier }}.
func IsValid{{= table.Identifier }}(i int) bool {
    switch i {
{{for _, con := range table.Constants}}
    case {{i con.Value}}: return true
{{for}}
    default: return false
    }
}

}}
    return
}

func (tmpl *EnumTemplate)genKey(table *model.Enum, _w io.Writer) (err error) {

{{
// Key returns a string representation of the primary key and satisfies KeyLabeler interface.
func (e {{= table.Identifier }}) Key() string {
    // We use string keys so that if the number values change, keys will still relate to to the same conceptual item.
    switch (e) {
{{for _,con := range table.Constants }}
    case {{= table.Identifier}}{{= con.Name }}: return "{{= con.Key }}"
{{for}}
    }
	return ""
}

// Keys returns all of the items in the enumerated type as string keys.
func (e {{= table.Identifier }}) Keys() []string {
    return []string {
{{for _,con := range table.Constants }}
        "{{= con.Key }}",
{{for}}
    }
}


// {{= table.Identifier }}FromKey converts a {{= table.Identifier }} Key to a {{= table.Identifier }}
func {{= table.Identifier }}FromKey (key string) {{= table.Identifier }} {
	switch key {
{{for _,con := range table.Constants }}
    case "{{= con.Key }}": return {{= table.Identifier}}{{= con.Name }}
{{for}}
	}
	return {{= table.Identifier }}(0)
}

// {{= table.IdentifierPlural }}FromKeys converts a slice of {{= table.Identifier }} Keys to a slice of {{= table.Identifier }}
func {{= table.IdentifierPlural }}FromKeys (keys []string) (values []{{= table.Identifier }}) {
    values = make([]{{= table.Identifier }}, 0, len(keys))
    for _,key := range keys {
        values = append(values, {{= table.Identifier }}FromKey(key))
    }
    return
}

}}

    return
}

func (tmpl *EnumTemplate)genPlurals(table *model.Enum, _w io.Writer) (err error) {
{{
// {{= table.IdentifierPlural }} returns a slice of all the {{= table.Identifier }} values
// in key order.
func {{= table.IdentifierPlural }}() ([]{{= table.Identifier }}) {
    return []{{= table.Identifier }}{ 
{{for _,con := range table.Constants }}
        {{= table.Identifier}}{{= con.Name }},
{{for}}
    }
}

// {{= table.IdentifierPlural }}I returns a slice of all the {{= table.Identifier }} values as generic interfaces.
// doc: type={{= table.Identifier }}
func {{= table.IdentifierPlural }}I() (values []any) {
    return []any{ 
{{for _,con := range table.Constants }}
        {{= table.Identifier}}{{= con.Name }},
{{for}}
    }
}

}}
    return
}

func (tmpl *EnumTemplate)genInterfaces(table *model.Enum, _w io.Writer) (err error) {
{{

}}
    return
}

func (tmpl *EnumTemplate)genFields(table *model.Enum, _w io.Writer) (err error) {
{{
{{for _, field := range table.Fields }}
// {{= table.Identifier }}{{= field.Identifier }} returns the {{= field.Identifier }} value associated with {{= table.Identifier }}.
func (e {{= table.Identifier }}) {{= field.Identifier }}() {{= field.GoType()}} {
	switch e {
	case 0: return {{= field.Type.DefaultValueString() }}
{{for _,con := range table.Constants }}
	case {{= table.Identifier }}{{= con.Name }}: return {{L con.FieldValues[field.QueryName] }}
{{for}}
	default: panic("index out of range")
	}
}

// {{= table.Identifier }}{{= field.IdentifierPlural }} returns a slice of all the {{= field.Identifier }} values associated with {{= table.Identifier }}.
// doc: type={{= table.Identifier }}
func {{= table.Identifier }}{{= field.IdentifierPlural }}() []{{= field.GoType()}} {
	return []{{= field.GoType()

 }} {
{{for _,con := range table.Constants }}
	    {{L con.FieldValues[field.QueryName] }},
{{for}}
    }
}
{{for}}
}}
    return
}

func (tmpl *EnumTemplate)genMarshal(table *model.Enum, _w io.Writer) (err error) {
{{
// MarshalJSON converts the type to its identifier for JSON output.
func (e {{= table.Identifier }}) MarshalJSON() (data []byte, err error) {
	return json.Marshal(e.Key()) // wraps it in quotes like "active"
}

// UnmarshalJSON converts a variety of possible JSON inputs to the enum type.
func (e *{{= table.Identifier }}) UnmarshalJSON(data []byte) error {
	var i any
	var err error

	// Use Decoder or json.Unmarshal directly
	if err = json.Unmarshal(data, &i); err != nil {
		return fmt.Errorf("error unmarshaling {{= table.Identifier }}: %w", err)
	}
	*e, err = {{= table.Identifier }}FromInterface(i)
	return err
}

// {{= table.Identifier }}FromInterface converts a variety of data types to a {{= table.Identifier }}.
func {{= table.Identifier }}FromInterface(i any) ({{= table.Identifier }}, error) {
	switch v := i.(type) {
	case float64:
	    if IsValid{{= table.Identifier }}(int(v)) {
	        return {{= table.Identifier }}(int(v)), nil
	    }
	case int:
	    if IsValid{{= table.Identifier }}(v) {
	        return {{= table.Identifier }}(v), nil
	    }
	case string:
		// Try to parse as int
		if v2, err := strconv.Atoi(v); err == nil {
	        if IsValid{{= table.Identifier }}(v2) {
    		    return {{= table.Identifier }}(v2), nil
    		}
		}
		// Otherwise convert from the identifier
		v3 := {{= table.Identifier }}FromKey(v)
		if v3 != 0 {
		    return v3, nil
		}
	case json.Number:
		if v2, err := v.Int64(); err == nil {
	        if IsValid{{= table.Identifier }}(int(v2)) {
			    return {{= table.Identifier }}(int(v2)), nil
			}
		}
	default:
		return {{= table.Identifier }}(0), fmt.Errorf("unsupported type for {{= table.Identifier }}: %T", v)
	}
	return {{= table.Identifier }}(0), errors.New("invalid value for {{= table.Identifier }}")
}

}}

    return
}

func (tmpl *EnumTemplate)genSet(table *model.Enum, _w io.Writer) (err error) {
{{

// {{= table.Identifier }}Set is a pointer to a group of {{= table.Identifier }} values.
type {{= table.Identifier }}Set = *maps.OrderedSet[{{= table.Identifier }}]

func New{{= table.Identifier }}Set(values ...{{= table.Identifier }}) {{= table.Identifier }}Set {
	return maps.NewOrderedSet[{{= table.Identifier }}](values...)
}

func init() {
    gob.Register(new({{= table.Identifier }}Set))
}

}}
    return
}



