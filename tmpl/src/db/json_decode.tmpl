{{g
//*** {{includeName}}

{
    orderedTables := database.MarshalOrder()
    assnTables := database.UniqueManyManyReferences()

}}

{{

// JsonDecodeAll imports the entire database from JSON that was created using JsonEncodeAll.
// This is done within a transaction and with constraints off in case there are circular references.
func JsonDecodeAll(ctx context.Context,  reader io.Reader) error {
    database := Database()
    return db.WithConstraintsOff(ctx, database, func(ctx context.Context) error {
        return jsonDecodeAll(ctx, reader)
    })
}


func jsonDecodeAll(ctx context.Context,  reader io.Reader) error {
	decoder := json.NewDecoder(reader)

	token, err := decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading opening token: %w", err)
	}
	// Ensure the first token is a start of an array
	if delim, ok := token.(json.Delim); !ok || delim != '[' {
		return fmt.Errorf("expected the JSON to start with an array in jsonDecodeAll")
	}

	for decoder.More() {
		if err := jsonDecodeTable(ctx, decoder); err != nil {
			return err
		}
	}

	// Check if the last token is the end of the array
	token, err = decoder.Token()
	if err != nil {
		return fmt.Errorf("Error reading the last token: %w", err)
	}

	if delim, ok := token.(json.Delim); !ok || delim != ']' {
		fmt.Errorf("expected the JSON to end with a closing array token in jsonDecodeAll")
		return err
	}

	return nil
}

func jsonDecodeTable(ctx context.Context,  decoder *json.Decoder) error {
	token, err := decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading opening token: %w", err)
	}
	// Ensure the first token is a start of an array
	if delim, ok := token.(json.Delim); !ok || delim != '[' {
		fmt.Errorf("error: Expected the duple to start with an array in jsonDecodeTable")
	}

	token, err = decoder.Token()
	if err != nil {
		return fmt.Errorf("Error reading name of table: %w", err)
	}

	var tableName string
	var ok bool

	if tableName, ok = token.(string); !ok {
		return fmt.Errorf("expected a name of a table.")
	} else {
		switch tableName {
{{for _,table := range orderedTables}}
		case {{L table.QueryName }}:
			err = jsonDecode{{= table.IdentifierPlural }}(ctx, decoder)
{{for}}
{{for _,mm := range assnTables}}
		case {{L mm.TableQueryName }}:
			err = jsonDecode{{= mm.TableIdentifier() }}(ctx, decoder)
{{for}}
        default:
		    return fmt.Errorf("unknown table: %s", tableName)
		}
		if err != nil {
			return err
		}
	}

	// Check if the last token is the end of the array
	token, err = decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading the last token: %w", err)
	}

	if delim, ok := token.(json.Delim); !ok || delim != ']' {
		return fmt.Errorf("expected the JSON to end with a closing array token in jsonDecodeTable for table %s", tableName)
	}

	return nil
}

{{for _,table := range orderedTables}}
func jsonDecode{{= table.IdentifierPlural}}(ctx context.Context,  decoder *json.Decoder) error {
	token, err := decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading opening token: %w", err)
	}
	// Ensure the first token is a start of an array
	if delim, ok := token.(json.Delim); !ok || delim != '[' {
		return fmt.Errorf("expected the {{= table.Identifier }} list to start with an array")
	}

	for decoder.More() {
		obj := New{{= table.Identifier}}()
		if err = decoder.Decode(&obj); err != nil {
			return err
		}
		if err = obj.Save(ctx); err != nil {
		    return err
		}
	}

	// Check if the last token is the end of the array
	token, err = decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading the last token: %w", err)
	}

	if delim, ok := token.(json.Delim); !ok || delim != ']' {
		return fmt.Errorf("expected the JSON to end with a closing array token in jsonDecode{{= table.IdentifierPlural}}")
	}

	return nil
}
{{for}}

{{for _,mm := range assnTables}}
func jsonDecode{{= mm.TableIdentifier() }}(ctx context.Context,  decoder *json.Decoder) error {
	token, err := decoder.Token()
	if err != nil {
		return fmt.Errorf("Error reading opening token: %w", err)
	}
	// Ensure the first token is a start of an array
	if delim, ok := token.(json.Delim); !ok || delim != '[' {
		return fmt.Errorf("Error: Expected the {{= mm.TableIdentifier() }} list to start with an array")
	}

    database := Database()
	for decoder.More() {
	    var imp struct {
            Src {{= mm.SourceColumnReceiverType().GoType() }} `json:"{{= mm.SourceColumnName() }}"`
            Dest {{= mm.ForeignKeyReceiverType.GoType() }} `json:"{{= mm.ForeignKeyName }}"`
        }

		if err = decoder.Decode(&imp); err != nil {
			return err
		}
		db.Associate(ctx, database, {{L mm.TableQueryName }}, {{L mm.SourceColumnName() }}, imp.Src, {{L mm.ForeignKeyName }}, imp.Dest)
	}

	// Check if the last token is the end of the array
	token, err = decoder.Token()
	if err != nil {
		return fmt.Errorf("error reading the last token: %w", err)
	}

	if delim, ok := token.(json.Delim); !ok || delim != ']' {
		return fmt.Errorf ("expected the JSON to end with a closing array token in jsonDecode{{= mm.TableIdentifier() }}")
	}

	return nil
}
{{for}}


}}

{{g
}
}}
