{{g
//*** {{includeName}}
}}
{{
// {{= rev.Reference.ReverseIdentifier }} returns a single {{= rev.Table.Identifier }} object by primary key, if one was loaded.
// Otherwise, it will return nil. It will not return {{= rev.Table.Identifier }} objects that are not saved.
func (o *{{= table.DecapIdentifier }}Base) {{= rev.Reference.ReverseIdentifier }}(pk {{= rev.Table.PrimaryKeyGoType() }}) *{{= rev.Table.Identifier }} {
	v := o.{{= rev.ReverseVariableIdentifier() }}.Get(pk)
	return v
}

// {{= rev.ReverseIdentifier() }} returns a slice of {{= rev.Table.Identifier }} objects if loaded.
func (o *{{= table.DecapIdentifier}}Base) {{= rev.ReverseIdentifier() }}() []*{{= rev.Table.Identifier }} {
	return o.{{= rev.ReverseVariableIdentifier() }}.Values()
}

// Load{{= rev.ReverseIdentifier() }} loads a new slice of {{= rev.Table.Identifier }} objects and returns it.
func (o *{{= table.DecapIdentifier}}Base) Load{{= rev.ReverseIdentifier() }}(ctx context.Context, conditions ...interface{}) []*{{= rev.Table.Identifier }} {
	if o.IsNew() {
		return nil
	}
	for obj := range o.{{= rev.ReverseVariableIdentifier() }}.ValuesIter() {
        if obj.IsDirty() {
            panic("You cannot load over items that have changed but have not been saved.")
        }
    }

	qb := query{{= rev.Table.IdentifierPlural }}(ctx)
	var cond *query.OperationNode
	if o.{{= rev.ReversePkIdentifier() }} != nil {
	    cond = op.In(node.{{= rev.Table.Identifier }}().PrimaryKey(), o.{{= rev.ReversePkIdentifier() }}...)
	} else {
        cond = op.Equal(node.{{= rev.Table.Identifier }}().{{= rev.Identifier }}(), o.PrimaryKey())
    }
    if conditions != nil {
        conditions = append(conditions, cond)
        cond = op.And(conditions...)
    }

    objs := qb.Where(cond).Load()
    o.{{= rev.ReverseVariableIdentifier() }}.Clear()

    for _,obj := range objs {
        pk := obj.{{= rev.Table.PrimaryKeyColumn().Identifier }}()
        o.{{= rev.ReverseVariableIdentifier() }}.Set(pk, obj)
    }
	o.{{= rev.ReversePkIdentifier() }} = nil

    if o.{{= rev.ReverseVariableIdentifier() }}.Len() == 0 {
        return nil
    }
	return o.{{= rev.ReverseVariableIdentifier() }}.Values()
}

// Count{{= rev.ReverseIdentifier() }} returns the number of {{= rev.Table.Identifier }} objects in the database connected to this object.
func (o *{{= table.DecapIdentifier}}Base) Count{{= rev.ReverseIdentifier() }}(ctx context.Context) int {
    return Count{{= rev.Table.Identifier }}By{{= rev.Identifier }}(ctx, o.PrimaryKey())
}

// Set{{= rev.ReverseIdentifier() }} associates the objects in objs with the {{= table.Identifier }}.
{{if rev.IsNullable }}
// If it has items already associated with it that will not be associated after a save,
// the foreign keys for those items will be set to null.
// If you did not use a join to query the items in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be changing items
// that are not currently attached to this {{= table.Identifier }}.
{{else}}
// WARNING! If it has items already associated with it that will not be associated after a save,
// Save will panic. Be sure to delete those items or otherwise fix those pointers before calling save.
{{if}}
func (o *{{= table.DecapIdentifier}}Base) Set{{= rev.ReverseIdentifier() }}(objs []*{{= rev.Table.Identifier }}) {
    for obj := range o.{{= rev.ReverseVariableIdentifier() }}.ValuesIter() {
        if obj.IsDirty() {
            panic("You cannot overwrite items that have changed but have not been saved.")
        }
    }

    o.{{= rev.ReverseVariableIdentifier() }}.Clear()
    for _,obj := range objs {
        pk := obj.{{= rev.Table.PrimaryKeyColumn().Identifier }}()
        o.{{= rev.ReverseVariableIdentifier() }}.Set(pk, obj)
    }
    o.{{= rev.ReversePkIdentifier() }} = nil
	o.{{= rev.ReverseVariableIdentifier() }}IsDirty = true
}


// Set{{= rev.ReverseIdentifier() }}By{{= rev.Table.PrimaryKeyColumn().Identifier }} associates this {{= table.Identifier }} with the {{= rev.Table.IdentifierPlural }} that have primary keys in {{= rev.Table.PrimaryKeyColumn().VariableIdentifierPlural() }}.
// The association is done through the {{= rev.Table.Identifier }}.{{= rev.Identifier }} reverse relationship.
//
// The association is temporary until you call Save().
//
{{if rev.IsNullable }}
// If there are {{= rev.Table.Identifier }} objects currently associated with this {{= table.Identifier }} that are not included
// in {{= rev.Table.PrimaryKeyColumn().VariableIdentifierPlural() }}, those objects will have their {{= rev.Identifier }} value set to null when Save is called.
// If you did not use a join to query the items in the first place, used a conditional join,
// or joined with an expansion, be particularly careful, since you may be inadvertently changing items
// that are not currently loaded in this {{= table.Identifier }} object.
{{else}}
// WARNING! If it has items already associated with it that will not be associated after a save,
// Save will panic. You should delete those items first.
{{if}}
func (o *{{= table.DecapIdentifier }}Base) Set{{= rev.ReverseIdentifier() }}By{{= rev.Table.PrimaryKeyColumn().Identifier }}({{= rev.Table.PrimaryKeyColumn().VariableIdentifierPlural() }} []{{= rev.Table.PrimaryKeyGoType() }}) {
    for obj := range o.{{= rev.ReverseVariableIdentifier() }}.ValuesIter() {
        if obj.IsDirty() {
            panic("You cannot overwrite items that have changed but have not been saved.")
        }
    }

    o.{{= rev.ReverseVariableIdentifier() }}.Clear()
	o.{{= rev.ReversePkIdentifier() }} = {{= rev.Table.PrimaryKeyColumn().VariableIdentifierPlural() }}
	o.{{= rev.ReverseVariableIdentifier() }}IsDirty = true
}

}}
