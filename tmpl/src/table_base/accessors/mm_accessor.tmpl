
{{g
//*** {{includeName}}
}}
{{

// {{= mm.Identifier}} returns a single {{= mm.Type() }} object by primary key pk, if one was loaded.
// Otherwise, it will return nil.
func (o *{{= table.DecapIdentifier}}Base) {{= mm.Identifier }}(pk {{= mm.PrimaryKeyType() }}) *{{= mm.Type() }} {
	return o.{{= mm.Field }}.Get(pk)
}

// {{= mm.IdentifierPlural }} returns a slice of {{= mm.Type() }} objects if loaded. If not loaded, will return nil.
// The values will be ordered by the latest query or in the order they were assigned.
func (o *{{= table.DecapIdentifier}}Base) {{= mm.IdentifierPlural }}() []*{{= mm.Type() }} {
	return o.{{= mm.Field }}.Values()
}

// Set{{= mm.IdentifierPlural }} sets the associated objects to the given slice of {{= mm.Type() }} objects
// in preparation for saving. The associations will not be updated until Save() is called.
// Objects that are modified or are new will be saved before completing the association.
func (o *{{= table.DecapIdentifier}}Base) Set{{= mm.IdentifierPlural }}(objs ...*{{= mm.Type() }}) {
    o.{{= mm.Field }}.Clear()
	o.{{= mm.Field }}IsDirty = true
	o.{{= mm.PkField() }} = nil
    for _,obj := range objs {
        o.{{= mm.Field }}.Set(obj.PrimaryKey(), obj)
    }
}

// Set{{= mm.IdentifierPlural }}By{{= mm.ReferencedTable.PrimaryKeyColumn().Identifier }} prepares to associate {{= mm.Type() }} objects by
// the primary keys in {{= mm.ReferencedTable.PrimaryKeyColumn().FieldPlural }}.
// If objects are currently loaded, they will be unloaded.
// The association does not take place until Save() is called. Calling Load before calling
// Save will load the items that will be associated in the database after the Save call.
// After calling Save, the objects will be unloaded, and you must call Load again if you want
// them loaded.
func (o *{{= table.DecapIdentifier}}Base) Set{{= mm.IdentifierPlural }}By{{= mm.ReferencedTable.PrimaryKeyColumn().Identifier }}({{= mm.ReferencedTable.PrimaryKeyColumn().FieldPlural }} ...{{= mm.ReferencedTable.PrimaryKeyType() }}) {
	o.{{= mm.Field }}.Clear()
	o.{{= mm.PkField() }} = {{= mm.ReferencedTable.PrimaryKeyColumn().FieldPlural }}
	o.{{= mm.Field }}IsDirty = true
}

// Load{{= mm.IdentifierPlural }} loads the {{= mm.Type() }} objects associated through the {{= mm.Identifier }}-{{= mm.MM.Identifier }} relationship.
func (o *{{= table.DecapIdentifier}}Base) Load{{= mm.IdentifierPlural }}(ctx context.Context) ([]*{{= mm.Type() }}, error) {
    if o.{{= mm.Field }}IsDirty && o.{{= mm.PkField() }} == nil {
        panic("dirty many-many relationships cannot be loaded; call Save() first")
    }
    
    var objs []*{{= mm.Type() }}
    var err error

    if o.{{= mm.PkField() }} != nil {
        // Load the objects that will be associated after a Save
        objs, err = Query{{= mm.TypePlural() }}(ctx).
            Where(op.In(node.{{= mm.Type() }}().PrimaryKeys()[0], o.{{= mm.PkField() }}...)).
            Load()
    } else {
        objs, err = Query{{= mm.TypePlural() }}(ctx).
            Where(op.Equal(node.{{= mm.Type() }}().{{= mm.MM.IdentifierPlural}}(), o.PrimaryKey())).
            Load()
    }
    if err != nil {
        return nil, err
    }

    o.{{= mm.Field }}.Clear()
	for _,obj := range objs {
	    o.{{= mm.Field }}.Set(obj.PrimaryKey(), obj)
	}
	return o.{{= mm.Field }}.Values(), err
}

// Count{{= mm.IdentifierPlural }} counts the number of associated {{= mm.Field }} objects in the database.
// Note that this returns what is reflected by the database at that instant, and not what
// is the count of the loaded objects.
func (o *{{= table.DecapIdentifier }}Base) Count{{= mm.IdentifierPlural }}(ctx context.Context) (int, error) {
	return Query{{= mm.TypePlural() }}(ctx).
		Where(op.Equal(node.{{= mm.Type() }}().{{= mm.MM.IdentifierPlural }}(), o.PrimaryKey())).
		Count()

}

}}
