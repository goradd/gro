
{{g
//*** {{includeName}}
}}
{{
// Delete deletes the record from the database.
{{if len(table.ReverseReferences) > 0 }}
//
{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
{{if rev.IsNullable}}
// An associated {{= rev.ReverseIdentifier }} will have its {{= rev.Identifier }} field set to NULL.
{{else}}
// An associated {{{= rev.ReverseIdentifier }} will also be deleted since its {{= rev.Identifier }} field is not nullable.
{{if}}
{{else}}
{{if rev.IsNullable}}
// Associated {{= rev.ReverseIdentifier }} will have their {{= rev.Identifier }} field set to NULL.
{{else}}
// Associated {{= rev.ReverseIdentifier }} will also be deleted since their {{= rev.Identifier }} fields are not nullable.
{{if}}
{{if}}
{{for}}
{{if}}
func (o *{{= table.DecapIdentifier}}Base) Delete(ctx context.Context) (err error) {
    if o == nil {
        return // allow deleting of a nil object to be a noop
    }
	if !o._restored {
		panic ("Cannot delete a record that has no primary key value.")
	}
	d := Database()
{{if len(table.ReverseReferences) == 0 && len(table.ManyManyReferences) == 0}}
    err = d.Delete(ctx, "{{table.QueryName}}",
        map[string]any {
{{for _,col := range table.PrimaryKeyColumns() }}
            "{{= col.QueryName }}": o._originalPK{{if len(table.PrimaryKeyColumns()) > 1}}.{{= col.Identifier}}{{if}},
{{for}}
        },
        "{{= table.LockColumnQueryName() }}",
        {{if s:= table.LockColumnIdentifier(); s == "" }}0{{else}}o.{{= s }}(){{if}},
    )
{{else}}
{{# Note: for now we are not supporting references to tables with composite keys, so o._originalPK below should work }}
{{if table.WriteTimeout != 0 }}

    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, {{= table.WriteTimeoutConst() }})
    defer cancel()

{{if}}
    err = db.WithTransaction(ctx, d, func(ctx context.Context) error {
	{{for _,rev := range table.ReverseReferences }}
        {{if rev.IsUnique }}
            {{if rev.IsNullable}}
            {
                // Set the related objects pointer to us to NULL in the database
                obj, err := Query{{= rev.Table.IdentifierPlural }}(ctx).
                          Where(op.Equal(node.{{= rev.Table.Identifier }}().{{= rev.Identifier }}(), o._originalPK)).
                          Select(node.{{= rev.Table.Identifier}}().{{= rev.Identifier }}()).
{{if rev.Table.LockColumn != nil }}
                          Select(node.{{= rev.Table.Identifier }}().{{= rev.Table.LockColumnIdentifier() }}()).
{{if}}
                          Get()
                if err != nil {
                    return err
                }
                if obj != nil {
                    obj.Set{{= rev.Identifier }}(nil)
                    if err = obj.Save(ctx); err != nil {
                        return err
                    }
                }
                // Set this object's pointer to the reverse object to nil to mark that we broke the link
                o.{{= rev.ReverseField }} = nil
            }
            {{else}}
            {
                 obj, err := Query{{= rev.Table.IdentifierPlural }}(ctx).
                         Where(op.Equal(node.{{= rev.Table.Identifier}}().{{= rev.Identifier }}(), o._originalPK)).
                         Get()
                 if err != nil {
                     return err
                 }
                 if obj != nil {
                     if err = obj.Delete(ctx); err != nil {
                         return err
                     }
                 }
                 // Set this object's pointer to the reverse object to nil to mark that we broke the link
                 o.{{= rev.ReverseField }} = nil
            }
            {{if}}
        {{else}} {{# one-to-many}}
            {{if rev.IsNullable}}
            {
                objs, err := Query{{= rev.Table.IdentifierPlural }}(ctx).
                          Where(op.Equal(node.{{= rev.Table.Identifier }}().{{= rev.Identifier }}(), o._originalPK)).
                          Select(node.{{= rev.Table.Identifier }}().{{= rev.Identifier }}()).
{{if rev.Table.LockColumn != nil }}
                          Select(node.{{= rev.Table.Identifier }}().{{= rev.Table.LockColumn.Identifier }}()).
{{if}}
                          Load()
                if err != nil {
                    return err
                }
                for _,obj := range objs {
                    obj.Set{{= rev.Identifier }}(nil)
                    if err = obj.Save(ctx); err != nil {
                        return err
                    }
                }
                o.{{= rev.ReverseField }}.Clear()
            }
            {{else}}
            {
                objs, err := Query{{= rev.Table.IdentifierPlural }}(ctx).
                          Where(op.Equal(node.{{= rev.Table.Identifier}}().{{= rev.Identifier}}(), o._originalPK)).
                          Load()
                if err != nil {
                    return err
                }
                for _,obj := range objs {
                    if err = obj.Delete(ctx); err != nil {
                        return err
                    }
                }
                o.{{= rev.ReverseField }}.Clear()
            }
            {{if}}
        {{if}}
    {{for}}

    {{for _,mm := range table.ManyManyReferences}}
        if err := db.AssociateOnly(ctx,
            d,
            "{{= mm.TableQueryName }}",
            "{{= mm.SourceColumnName() }}",
            o._originalPK,
            "{{= mm.PrimaryKeyColumnName() }}",
            []{{= mm.ReferencedTable.Identifier }}(nil)); err != nil {
                return err
            }

    {{for}}
	    return d.Delete(ctx, "{{table.QueryName}}",
	        map[string]any{"{{= table.PrimaryKeyColumn().QueryName }}": o._originalPK},
            "{{= table.LockColumnQueryName() }}",
            {{if s:= table.LockColumnIdentifier(); s == "" }}0{{else}}o.{{= s }}(){{if}},
        )
	})

{{if}}
	if err != nil {
	    return err
	}
	broadcast.Delete(ctx, "{{= table.DbKey }}", "{{= table.QueryName }}", o._originalPK)
	return
}

// delete{{= table.Identifier }} deletes the {{= table.Identifier }} with primary key pk from the database
// and handles associated records.
func delete{{= table.Identifier }}(ctx context.Context, pk {{= table.PrimaryKeyType() }}) error {
	d := db.GetDatabase("{{= table.DbKey }}")
{{if len(table.ReverseReferences) == 0 && len(table.ManyManyReferences) == 0 }}
    err := d.Delete(ctx, "{{table.QueryName}}",
        map[string]any {
{{for _,col := range table.PrimaryKeyColumns() }}
            "{{= col.QueryName }}": pk{{if len(table.PrimaryKeyColumns()) > 1}}.{{= col.Identifier}}{{if}},
{{for}}
        },
        "",0)

	if err != nil {
	    return err
	}
	broadcast.Delete(ctx, "{{= table.DbKey }}", "{{= table.QueryName }}", pk)
{{else}}
{{if table.WriteTimeout != 0 }}

    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, {{= table.WriteTimeoutConst() }})
    defer cancel()

{{if}}
    err := db.WithTransaction(ctx, d, func(ctx context.Context) error {
        if obj, err := Load{{= table.Identifier }}(ctx,
                pk,
{{for _,col := range table.PrimaryKeyColumns() }}
                node.{{= table.Identifier}}().{{= col.Identifier }}(),
{{for}}
{{if table.LockColumn != nil }}
                node.{{= table.Identifier }}().{{= table.LockColumn.Identifier }}(),
{{if}}
                ); err != nil {
            return err
        } else if obj == nil {
            return db.NewRecordNotFoundError("{{= table.QueryName }}", pk)
        } else {
            if err := obj.Delete(ctx); err != nil {
                return err
            }
        }
        return nil
    })
{{if}}
    return err
}
}}