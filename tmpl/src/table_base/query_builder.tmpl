
{{g
//*** {{includeName}}
}}
builderInterface := table.Identifier + "Builder"
builderStruct := table.DecapIdentifier + "QueryBuilder"
{{

// The {{= builderInterface}} uses the query.BuilderI interface to build a query.
// All query operations go through this query builder.
// End a query by calling either Load, LoadCursor, Get, Count, or Delete
type {{= builderInterface }} interface {
	// Join(alias string, joinedTable query.Node, condition query.Node) {{= builderInterface }}

    // Expand turns a Reverse or ManyMany node into individual rows.
	Expand(n query.Expander) {{= builderInterface }}

	// Where adds a condition to filter what gets selected.
    // Calling Where multiple times will AND the conditions together.
	Where(c query.Node) {{= builderInterface }}

	// OrderBy specifies how the resulting data should be sorted.
    // By default, the given nodes are sorted in ascending order.
    // Add Descending() to the node to specify that it should be sorted in descending order.
	OrderBy(nodes... query.Sorter) {{= builderInterface }}

	// Limit will return a subset of the data, limited to the offset and number of rows specified.
    // For large data sets and specific types of queries, this can be slow, because it will perform
    // the entire query before computing the limit.
    // You cannot limit a query that has embedded arrays.
	Limit(maxRowCount int, offset int) {{= builderInterface }}

	// Select optimizes the query to only return the specified fields.
    // Once you put a Select in your query, you must specify all the fields that you will eventually read out.
    // Some fields, like primary keys, are always selected.
    // If you are using a GroupBy, most database drivers will only allow selecting on fields in the GroupBy, and
    // doing otherwise will result in an error.
	Select(nodes... query.Node) {{= builderInterface }}

	// Calculation adds a calculation node with an aliased name.
    // After the query, you can read the data using GetAlias() on a returned object.
	Calculation(name string, n query.Aliaser) {{= builderInterface }}

	// Distinct removes duplicates from the results of the query.
    // Adding a Select() is usually required.
	Distinct() {{= builderInterface }}

	// GroupBy controls how results are grouped when using aggregate functions with Calculation.
	GroupBy(nodes... query.Node) {{= builderInterface }}

	// Having does additional filtering on the results of the query after the query is performed.
	Having(node query.Node)  {{= builderInterface }}

    // Load terminates the query builder, performs the query, and returns a slice of {{= table.Identifier }} objects.
    // If there are any errors, nil is returned and the specific error is stored in the context.
    // If no results come back from the query, it will return a non-nil empty slice.
	Load() []*{{= table.Identifier }}
    // Load terminates the query builder, performs the query, and returns a slice of interfaces.
    // This can then satisfy a general interface that loads arrays of objects.
    // If there are any errors, nil is returned and the specific error is stored in the context.
    // If no results come back from the query, it will return a non-nil empty slice.
	LoadI() []any

    // LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
    //
    // A query cursor is useful for dealing with large amounts of query results. However, there are some
    // limitations to its use. When working with SQL databases, you cannot use a cursor while querying
    // many-to-many or reverse relationships that will create an array of values.
    //
    // Call Next() on the returned cursor object to step through the results. Make sure you call Close
    // on the cursor object when you are done. You should use
    //   defer cursor.Close()
    // to make sure the cursor gets closed.
	LoadCursor() {{= table.VariableNamePlural() }}Cursor

	// Get is a convenience method to return only the first item found in a query.
    // The entire query is performed, so you should generally use this only if you know
    // you are selecting on one or very few items.
    //
    // If an error occurs, or no results are found, a nil is returned.
    // In the case of an error, the error is returned in the context.
	Get() *{{= table.Identifier }}

	// Count terminates a query and returns just the number of items selected.
    // distinct wll count the number of distinct items, ignoring duplicates.
    // nodes will select individual fields, and should be accompanied by a GroupBy.
	Count(distinct bool, nodes... query.Node) int

	// Delete uses the query builder to delete a group of records that match the criteria
	Delete()

	// Subquery terminates the query builder and tags it as a subquery within a larger query.
    // You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
    // Generally you would use this as a node to a Calculation function on the surrounding query builder.
   // Subquery() *query.SubqueryNode

}

type {{= builderStruct }} struct {
	builder *query.Builder
}


func new{{= table.Identifier }}Builder(ctx context.Context) {{= builderInterface }} {
	b := {{= builderStruct }}{
		builder: query.NewBuilder(ctx, node.{{= table.Identifier }}()),
	}
	return &b
}

// Load terminates the query builder, performs the query, and returns a slice of {{= table.Identifier }} objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *{{= builderStruct }}) Load() ({{= table.VariableNamePlural() }} []*{{= table.Identifier }}) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("{{= table.DbKey }}")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
	if results == nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new({{= table.Identifier }})
		o.load(item, o, nil, "")
		{{= table.VariableNamePlural() }} = append({{= table.VariableNamePlural() }}, o)
	}
	return
}

// Load terminates the query builder, performs the query, and returns a slice of interfaces.
// This can then satisfy a general interface that loads arrays of objects.
// If there are any errors, nil is returned and the specific error is stored in the context.
// If no results come back from the query, it will return a non-nil empty slice.
func (b *{{= builderStruct }}) LoadI() ({{= table.VariableNamePlural() }} []any) {
	b.builder.Command = query.BuilderCommandLoad
	database := db.GetDatabase("{{= table.DbKey }}")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
	if results == nil {
		return
	}
	for _,item := range results.([]map[string]any) {
		o := new({{= table.Identifier }})
		o.load(item, o, nil, "")
		{{= table.VariableNamePlural() }} = append({{= table.VariableNamePlural() }}, o)
	}
	return
}


// LoadCursor terminates the query builder, performs the query, and returns a cursor to the query.
//
// A query cursor is useful for dealing with large amounts of query results. However, there are some
// limitations to its use. When working with SQL databases, you cannot use a cursor while querying
// many-to-many or reverse relationships that will create an array of values.
//
// Call Next() on the returned cursor object to step through the results. Make sure you call Close
// on the cursor object when you are done. You should use
//   defer cursor.Close()
// to make sure the cursor gets closed.
func (b *{{= builderStruct }}) LoadCursor() {{= table.VariableNamePlural() }}Cursor {
	b.builder.Command = query.BuilderCommandLoadCursor
	database := db.GetDatabase("{{= table.DbKey }}")
	result := database.BuilderQuery(b.builder.Ctx, b.builder)
	if (result == nil) {
	    return {{= table.VariableNamePlural() }}Cursor{}
	}
	cursor := result.(query.CursorI)

	return {{= table.VariableNamePlural() }}Cursor{cursor}
}

type {{= table.VariableNamePlural() }}Cursor struct {
	query.CursorI
}

// Next returns the current {{= table.Identifier }} object and moves the cursor to the next one.
//
// If there are no more records, it returns nil.
func (c {{= table.VariableNamePlural() }}Cursor) Next() *{{= table.Identifier }} {
    if c.CursorI == nil {
        return nil
    }

	row := c.CursorI.Next()
	if row == nil {
		return nil
	}
	o := new({{= table.Identifier }})
	o.load(row, o, nil, "")
	return o
}

// Get is a convenience method to return only the first item found in a query.
// The entire query is performed, so you should generally use this only if you know
// you are selecting on one or very few items.
//
// If an error occurs, or no results are found, a nil is returned.
// In the case of an error, the error is returned in the context.
func (b *{{= builderStruct }}) Get() *{{= table.Identifier }} {
	results := b.Load()
	if results != nil && len(results) > 0 {
	    obj := results[0]
		return obj
	} else {
		return nil
	}
}

// Expand expands an array type node so that it will produce individual rows instead of an array of items
func (b *{{= builderStruct }}) Expand(n query.Expander) {{= builderInterface }} {
	b.builder.Expand(n)
	return b
}

/*
// Join attaches the table referred to by joinedTable, filtering the join process using the operation node specified
// by condition.
// The joinedTable node will be modified by this process so that you can use it in subsequent builder operations.
// Call GetAlias to return the resulting object from the query result.
func (b *{{= builderStruct }}) Join(alias string, joinedTable query.Node, condition query.Node) {{= builderInterface }} {
    if query.RootNode(n).TableName_() != {{L table.QueryName }} {
        panic("you can only join a node that is rooted at node.{{= table.Identifier }}()")
    }
    // TODO: make sure joinedTable is a table node
	b.builder.Join(alias, joinedTable, condition)
	return b
}
*/

// Where adds a condition to filter what gets selected.
// Calling Where multiple times will AND the conditions together.
func (b *{{= builderStruct }})  Where(c query.Node) {{= builderInterface }} {
	b.builder.Where(c)
	return b
}

// OrderBy specifies how the resulting data should be sorted.
// By default, the given nodes are sorted in ascending order.
// Add Descending() to the node to specify that it should be sorted in descending order.
func (b *{{= builderStruct }})  OrderBy(nodes... query.Sorter) {{= builderInterface }} {
	b.builder.OrderBy(nodes...)
	return b
}

// Limit will return a subset of the data, limited to the offset and number of rows specified.
// For large data sets and specific types of queries, this can be slow, because it will perform
// the entire query before computing the limit.
// You cannot limit a query that has embedded arrays.
func (b *{{= builderStruct }})  Limit(maxRowCount int, offset int) {{= builderInterface }} {
	b.builder.Limit(maxRowCount, offset)
	return b
}

// Select specifies what specific columns will be loaded with data.
// By default, all the columns of the {{= table.QueryName }} table will be queried and loaded.
// If nodes contains columns from the {{= table.QueryName }} table, that will limit the columns queried and loaded to only those columns.
// If related tables are specified, then all the columns from those tables are queried, selected and joined to the result.
// If columns in related tables are specified, then only those columns will be queried and loaded.
// Depending on the query, additional columns may automatically be added to the query. In particular, primary key columns
// will be added in most situations. The exception to this would be in distinct queries, group by queries, or subqueries.
func (b *{{= builderStruct }})  Select(nodes... query.Node) {{= builderInterface }} {
	b.builder.Select(nodes...)
	return b
}

// Calculation adds a calculation node with an aliased name.
// After the query, you can read the data using GetAlias() on the returned object.
func (b *{{= builderStruct }})  Calculation(name string, n query.Aliaser) {{= builderInterface }} {
	b.builder.Calculation(name, n)
	return b
}

// Distinct removes duplicates from the results of the query.
// Adding a Select() is usually required.
func (b *{{= builderStruct }})  Distinct() {{= builderInterface }} {
	b.builder.Distinct()
	return b
}

// GroupBy controls how results are grouped when using aggregate functions with Calculation.
func (b *{{= builderStruct }})  GroupBy(nodes... query.Node) {{= builderInterface }} {
	b.builder.GroupBy(nodes...)
	return b
}

// Having does additional filtering on the results of the query after the query is performed.
func (b *{{= builderStruct }})  Having(node query.Node)  {{= builderInterface }} {
	 b.builder.Having(node)
	 return b
}

// Count terminates a query and returns just the number of items selected.
// distinct wll count the number of distinct items, ignoring duplicates.
// nodes will select individual fields, and should be accompanied by a GroupBy.
func (b *{{= builderStruct }})  Count(distinct bool, nodes... query.Node) int {
	b.builder.Command = query.BuilderCommandCount
	if distinct {
	    b.builder.Distinct()
	}
	database := db.GetDatabase("{{= table.DbKey }}")
	results := database.BuilderQuery(b.builder.Ctx, b.builder)
    if results == nil {
        return 0
    }
	return results.(int)
}

// Delete uses the query builder to delete a group of records that match the criteria.
func (b *{{= builderStruct }})  Delete() {
	b.builder.Command = query.BuilderCommandDelete
	database := db.GetDatabase("{{= table.DbKey }}")
	database.BuilderQuery(b.builder.Ctx, b.builder)
	broadcast.BulkChange(b.builder.Context(), "{{= table.DbKey}}", "{{= table.QueryName}}")
}

/*
// Subquery terminates the query builder and tags it as a subquery within a larger query.
// You MUST include what you are selecting by adding Calculation or Select functions on the subquery builder.
// Generally you would use this as a node to a Calculation function on the surrounding query builder.
func (b *{{= builderStruct }})  Subquery() *query.SubqueryNode {
	 return b.builder.Subquery()
}
*/

}}

