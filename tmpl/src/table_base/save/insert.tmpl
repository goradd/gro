
{{g
//*** {{includeName}}
}}
{{
// insert will insert the object into the database. Related items will be saved.
func (o *{{= table.DecapIdentifier}}Base) insert(ctx context.Context) (err error) {
    var insertFields map[string]interface{}
    d := Database()
	err = db.ExecuteTransaction(ctx, d, func() error {

{{for _,col := range table.SettableColumns()}}
{{if col.IsReference() }}
{{# Here we save forward references, get the new pk, and then set the corresponding foreign key.}}
    if o.{{= col.ReferenceVariableIdentifier() }} != nil {
        if err = o.{{= col.ReferenceVariableIdentifier() }}.Save(ctx); err != nil {
            return err
        }
        o.{{= col.VariableIdentifier() }} = o.{{= col.ReferenceVariableIdentifier() }}.PrimaryKey()
    }
{{if}}
{{for}}

{{for _,col := range table.SettableColumns() }}
{{if !col.IsAutoPK && !col.IsNullable}}
{{# Note: Most likely the user is inserting a new record, but forgot to set a required value, but there is the
              possibility that this is a retrieved record with missing fields (through the Select statement) and those
              missing fields are required, and the user is forcing an insert. }}
    if !o.{{= col.VariableIdentifier() }}IsLoaded {
        panic("a value for {{= col.Identifier }} is required, and there is no default value. Call Set{{= col.Identifier }}() before inserting the record.")
    }
{{if}}
{{for}}

{{# Since not all databases natively enforce uniqueness, we will attempt to do it manually here.
    However, unless the database has its own built-in mechanism to support uniqueness, this can
    still fail in a race condition. In such situations, the developer would have to implement a service that operates like
    a channel that will lock a unique value during the update process and prevent another process from
    obtaining a lock on that value. That could be placed in the Save() function in the wrapper to the base.
    Note that even in a database that supports uniqueness, the following check could still get passed, but the
    database driver will generate the NewDuplicateValueError if there is a collision. The check here is still
    needed to allow for a locking service used with a database that does not support uniqueness.
 }}
{{for _,col := range table.SettableColumns()}}
{{if col.IsUnique && !col.IsAutoPK }}
    if o.{{= col.VariableIdentifier() }}IsDirty &&
{{if col.IsNullable}}
            !o.{{= col.VariableIdentifier() }}IsNull &&
{{if}}
            Load{{= table.Identifier }}By{{= col.Identifier}}(ctx, o.{{= col.VariableIdentifier() }}) != nil {
        return db.NewDuplicateValueError(fmt.Sprintf("error: duplicate value found for {{= col.Identifier }}: %v", o.{{= col.VariableIdentifier() }}))
    }
{{if}}
{{for}}

{{for _,idx := range table.Indexes}}
{{if idx.IsUnique && len(idx.Columns) > 1 }}
    if ({{join idx.Columns, " || "}}o.{{= _j.VariableIdentifier() }}IsDirty{{join}}) &&
{{for _,col := range idx.Columns}}
{{if col.IsNullable}}
            !o.{{= col.VariableIdentifier() }}IsNull &&
{{if}}
{{for}}
            Load{{= table.Identifier }}By{{join idx.Columns, ""}}{{= _j.Identifier }}{{join}}(ctx, {{join idx.Columns, ", "}}o.{{= _j.VariableIdentifier() }}{{join}}) != nil {
        return db.NewDuplicateValueError(fmt.Sprintf("error: duplicate value {{join idx.Columns, " & "}}{{= _j.Identifier }}=%v{{join}}", {{join idx.Columns, ", "}}o.{{= _j.VariableIdentifier() }}{{join}}))
    }
{{if}}
{{for}}

    insertFields = o.getInsertFields()
    var newPk {{= table.PrimaryKeyGoType() }}

{{if table.HasAutoPK() }}
	newPk, err = d.Insert(ctx, "{{= table.QueryName }}", "{{= table.PrimaryKeyColumn().QueryName }}", insertFields)
    if err != nil {
        return err
    }
	o.{{= table.PrimaryKeyColumn().VariableIdentifier() }} = newPk
	o._originalPK = newPk
    o.{{= table.PrimaryKeyColumn().VariableIdentifier() }}IsLoaded = true
{{else}}
	_, err = d.Insert(ctx, "{{= table.QueryName }}", "{{= table.PrimaryKeyColumn().QueryName }}", insertFields)
    if err != nil {
        return err
    }
	newPk = o.PrimaryKey()
	o._originalPK = newPk
{{if}}

{{g

{{: "insert_rev.tmpl"  }}
{{: "insert_mm.tmpl"  }}

}}

        return nil

    }) // transaction

    if err != nil {
        return
    }
{{# Update local copies of auto generated fields }}
{{for _,col := range table.Columns}}
{{if col.ReceiverType == query.ColTypeTime && (col.DefaultValue == model.CreatedTime || col.DefaultValue == model.ModifiedTime) ||
        col.SchemaSubType == schema.ColSubTypeTimestamp ||
        col.SchemaSubType == schema.ColSubTypeLock }}
    o.{{= col.VariableIdentifier() }} = insertFields["{{= col.QueryName }}"].({{= col.GoType() }})
    o.{{= col.VariableIdentifier() }}IsLoaded = true
{{if}}
{{for}}

	o.resetDirtyStatus()
	o._restored = true
	broadcast.Insert(ctx, "{{= table.DbKey }}", "{{= table.QueryName }}", o.PrimaryKey())
	return
}

}}

