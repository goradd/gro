
{{g
//*** {{includeName}}
}}
{{
// update will update the values in the database, saving any changed values.
// If the table has auto-generated values, those will be updated automatically.
func (o *{{= table.DecapIdentifier}}Base) update(ctx context.Context) error {
    if !o._restored {
        panic ("cannot update a record that was not originally read from the database.")
    }
    if !o.IsDirty() {
        return nil // nothing to save
    }

    var modifiedFields map[string]interface{}
{{if c := table.LockColumn; c != nil }}
    var newLock int64
{{if}}

    d := Database()
{{if table.WriteTimeout != 0 }}
    var cancel context.CancelFunc
    ctx, cancel = context.WithTimeout(ctx, {{= table.WriteTimeoutConst() }})
    defer cancel()
{{if}}
    err := db.WithTransaction(ctx, d, func(ctx context.Context) error {
{{: "update_ref.tmpl" }}

{{: unique_check.tmpl }}

        modifiedFields = get{{= table.Identifier }}UpdateFields(o)
        if len(modifiedFields) != 0 {
            err2 := d.Update(ctx, "{{= table.QueryName }}",
                map[string]any{
{{for _,col := range table.PrimaryKeyColumns()}}
                    "{{= col.QueryName }}": o._originalPK{{if len(table.PrimaryKeyColumns()) > 1}}.{{= col.Field}}{{if}},
{{for}}
                },
                modifiedFields,
                "{{= table.LockColumnQueryName() }}",
                {{if s:= table.LockColumnIdentifer(); s == "" }}0{{else}}o.{{= s }}(){{if}},
            )
            if err2 != nil {
                return err2
            }
        }

{{: "update_rev.tmpl" }}
{{: "update_mm.tmpl" }}

        return nil
    }) // transaction
    if err != nil {
        return err
    }
{{# update auto-generated fields after we are sure transaction was successful }}
{{for _,col := range table.Columns }}
{{if col.SchemaSubType == schema.ColSubTypeTimestamp ||
        col.ReceiverType == query.ColTypeTime && col.DefaultValue == model.ModifiedTime }}
    // update generated time value
    if t, ok := modifiedFields["{{= col.QueryName }}"]; ok {
        o.{{= col.Field }} = t.({{= col.Type }})
        o.{{= col.Field }}IsLoaded = true
    }
{{elseif col.SchemaSubType == schema.ColSubTypeLock}}
    // update generated lock value
    if l, ok := modifiedFields["{{= col.QueryName }}"]; ok {
        o.{{= col.Field }} = l
        o.{{= col.Field }}IsLoaded = true
    }
{{if}}
{{for}}

	o.resetDirtyStatus()
	if len(modifiedFields) != 0 {
        broadcast.Update(ctx, "{{= table.DbKey}}", "{{= table.QueryName}}", o._originalPK, anyutil.SortedKeys(modifiedFields)...)
	}

	return nil
}

}}
