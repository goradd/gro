//*** {{includeName}}

{{
func Test{{= table.Identifier }}_BasicInsert(t *testing.T) {
    obj := createMinimalSample{{= table.Identifier }}()
    ctx := context.Background()
	assert.NoError(t, obj.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj)

    // Test retrieval
    obj2,err := Load{{= table.Identifier }}(ctx, obj.PrimaryKey())
    require.NotNil(t, obj2)
    assert.NoError(t, err)

    assert.Equal(t, obj2.PrimaryKey(), obj2.OriginalPrimaryKey())

{{for _,col := range table.Columns}}
{{g
    if col.ReceiverType == query.ColTypeUnknown {continue} // cannot know what the set of valid input characters are.
    if col.IsReference() {continue} // forward references will be tested in the References test.
}}

    assert.True(t, obj2.{{= col.Identifier }}IsLoaded())
{{if col.IsNullable}}
    assert.False(t, obj2.{{= col.Identifier }}IsNull())
{{if}}
{{if col.HasSetter()}}
{{if col.IsDecimal() }}
    assert.True(t, test.EqualDecimals(obj.{{= col.Identifier }}(), obj2.{{= col.Identifier }}()))
{{if}}
{{if col.IsAPrimaryKey() }}
    assert.Panics(t, func() {
        obj2.Set{{= col.Identifier }}(obj2.{{= col.Identifier }}())
    })
{{else}}
    // test that setting it to the same value will not change the dirty bit
    assert.False(t, obj2.{{= col.Field }}IsDirty)
    obj2.Set{{= col.Identifier }}(obj2.{{= col.Identifier }}())
    assert.False(t, obj2.{{= col.Field }}IsDirty)
{{if}}
{{if}}{{# HasSetter }}
{{for}}

}

func Test{{= table.Identifier }}_InsertPanics(t *testing.T) {
    obj := createMinimalSample{{= table.Identifier }}()
    _ = obj
    ctx := context.Background()
    _ = ctx

{{for _,ref := range table.References }}
    obj.{{= ref.Field }} = nil
{{for}}

{{for _, col := range table.SettableColumns() }}
{{if !col.IsAutoPK() && !col.IsNullable }}
    obj.{{= col.Field }}IsLoaded = false
    assert.Panics(t, func() {obj.Save(ctx)})
    obj.{{= col.Field }}IsLoaded = true

{{if}}
{{for}}
}

func Test{{= table.Identifier }}_BasicUpdate(t *testing.T) {
    obj := createMinimalSample{{= table.Identifier }}()
    ctx := context.Background()
    assert.NoError(t, obj.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj)
    updateMinimalSample{{= table.Identifier }}(obj)
    assert.NoError(t, obj.Save(ctx))
    obj2, err := Load{{= table.Identifier }}(ctx, obj.PrimaryKey())
    assert.NoError(t, err)

{{for _,col := range table.Columns}}
{{if col.ReceiverType == query.ColTypeTime}} {{# In some situations, fractional times may be truncated by the database }}
    assert.WithinDuration(t, obj2.{{= col.Identifier }}(), obj.{{= col.Identifier }}(), time.Second, "{{= col.Identifier }} not within one second")
{{elseif col.SchemaSubType != schema.ColSubTypeNumeric &&
        !col.IsReference() }}
    assert.Equal(t, obj2.{{= col.Identifier }}(), obj.{{= col.Identifier }}(), "{{= col.Identifier }} did not update")
{{if}}
{{for}}
}



func Test{{= table.Identifier }}_ReferenceLoad(t *testing.T) {
    ctx := context.Background()
    obj := createMaximalSample{{= table.Identifier }}(ctx)
    assert.NoError(t, obj.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj)

    // Test that referenced objects were saved and assigned ids
{{for _,ref := range table.References }}
    assert.NotNil(t, obj.{{= ref.Identifier }}())
{{if ref.ReferencedTable.PrimaryKeyColumn().IsAutoPK() }}
    assert.False(t, obj.{{= ref.Identifier }}().PrimaryKey().IsTemp())
    assert.False(t, obj.{{= ref.Identifier }}().PrimaryKey().IsZero())
{{if}}

{{for}}

    // Test lazy loading
    obj2, err := Load{{= table.Identifier }}(ctx, obj.PrimaryKey())
    assert.NoError(t, err)
    assert.NotNil(t, obj2)
    objPkOnly, err2 := Load{{= table.Identifier }}(ctx, obj.PrimaryKey(),
    {{join table.PrimaryKeyColumns(), ", "}}node.{{= table.Identifier }}().{{= _j.Identifier }}(){{join}})
    assert.NoError(t, err2)
    _ = objPkOnly


{{for _,ref := range table.References }}
    assert.Nil(t, obj2.{{= ref.Identifier }}(), "{{= ref.Identifier }} is not loaded initially")
    v_{{= ref.Identifier }}, _ := obj2.Load{{= ref.Identifier }}(ctx)
    assert.NotNil(t, v_{{= ref.Identifier }})
    assert.Equal(t, v_{{= ref.Identifier }}.PrimaryKey(), obj2.{{= ref.Identifier }}().PrimaryKey())
    assert.Equal(t, obj.{{= ref.Identifier }}().PrimaryKey(), obj2.{{= ref.Identifier }}().PrimaryKey())
    assert.True(t, obj2.{{= ref.ForeignKey.Identifier }}IsLoaded())

    assert.False(t, objPkOnly.{{= ref.ForeignKey.Identifier }}IsLoaded())
    assert.Panics(t, func() {_,_ = objPkOnly.Load{{= ref.Identifier }}(ctx)} )

{{if !ref.IsNullable }}
    assert.Panics(t, func() {
        objPkOnly.Set{{= ref.Identifier }}(nil)
    })
{{if}}

{{for}}

{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    assert.Nil(t, obj2.{{= rev.ReverseIdentifier }}(), "{{= rev.ReverseIdentifier }} is not loaded initially")
    v_{{= rev.ReverseIdentifier }}, _ := obj2.Load{{= rev.ReverseIdentifier }}(ctx)
    assert.NotNil(t, v_{{= rev.ReverseIdentifier }})
    assert.Equal(t, v_{{= rev.ReverseIdentifier }}.PrimaryKey(), obj2.{{= rev.ReverseIdentifier }}().PrimaryKey())
    assert.Equal(t, obj.{{= rev.ReverseIdentifier }}().PrimaryKey(), obj2.{{= rev.ReverseIdentifier }}().PrimaryKey())
{{else}}
    assert.Nil(t, obj2.{{= rev.ReverseIdentifierPlural }}(), "{{= rev.ReverseIdentifier }} is not loaded initially")
    v_{{= rev.ReverseIdentifierPlural }}, _ := obj2.Load{{= rev.ReverseIdentifierPlural }}(ctx)
    assert.NotNil(t, v_{{= rev.ReverseIdentifierPlural }})
    assert.Len(t, v_{{= rev.ReverseIdentifierPlural }}, 1)
{{if}}
{{for}}

{{for _,mm := range table.ManyManyReferences }}
    assert.Nil(t, obj2.{{= mm.IdentifierPlural }}(), "{{= mm.IdentifierPlural }} is not loaded initially")
    v_{{= mm.IdentifierPlural }}, _ := obj2.Load{{= mm.IdentifierPlural }}(ctx)
    assert.NotNil(t, v_{{= mm.IdentifierPlural }})
    assert.Len(t, v_{{= mm.IdentifierPlural }}, 1)
{{for}}

    // test eager loading
    obj3, err3 := Load{{= table.Identifier }}(ctx, obj.PrimaryKey(), {{join table.References, ""}}node.{{= table.Identifier }}().{{= _j.Identifier }}(),
{{join}}
{{for _,rev := range table.ReverseReferences}}
{{if rev.IsUnique }}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifier }}(),
{{else}}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifierPlural }}(),
{{if}}
{{for}}
{{join table.ManyManyReferences, ""}}node.{{= table.Identifier }}().{{= _j.IdentifierPlural }}(),
{{join}}
    )
    assert.NoError(t, err3)
    _ = obj3 // avoid error if there are no references

{{for _,ref := range table.References }}
    assert.Equal(t, obj2.{{= ref.Identifier }}().PrimaryKey(), obj3.{{= ref.Identifier }}().PrimaryKey())
{{for}}
{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    assert.Equal(t, obj2.{{= rev.ReverseIdentifier }}().PrimaryKey(), obj3.{{= rev.ReverseIdentifier }}().PrimaryKey())
{{else}}
    assert.Equal(t, len(obj2.{{= rev.ReverseIdentifierPlural }}()), len(obj3.{{= rev.ReverseIdentifierPlural }}()))
{{if}}
{{for}}
{{for _,mm := range table.ManyManyReferences }}
    assert.Equal(t, len(obj2.{{= mm.IdentifierPlural }}()), len(obj3.{{= mm.IdentifierPlural }}()))
{{for}}

}

func Test{{= table.Identifier }}_ReferenceUpdateNewObjects(t *testing.T) {
    ctx := context.Background()
    obj := createMaximalSample{{= table.Identifier }}(ctx)
    assert.NoError(t, obj.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj)

    obj2, err := Load{{= table.Identifier }}(ctx, obj.PrimaryKey())
    assert.NoError(t, err)
    updateMaximalSample{{= table.Identifier }}(ctx, obj2)
    assert.NoError(t, obj2.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj2)

    obj3, err2 := Load{{= table.Identifier }}(ctx, obj2.PrimaryKey(), {{join table.References, ""}}node.{{= table.Identifier }}().{{= _j.Identifier }}(),
{{join}}
{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifier }}(),
{{else}}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifierPlural }}(),
{{if}}
{{for}}
{{join table.ManyManyReferences, ""}}node.{{= table.Identifier }}().{{= _j.IdentifierPlural }}(),
{{join}}
    )
    assert.NoError(t, err2)
    _ = obj3 // avoid error if there are no references

{{for _,ref := range table.References }}
    assert.Equal(t, obj2.{{= ref.Identifier }}().PrimaryKey(), obj3.{{= ref.Identifier }}().PrimaryKey())
{{for}}

{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    assert.Equal(t, obj2.{{= rev.ReverseIdentifier }}().PrimaryKey(), obj3.{{= rev.ReverseIdentifier }}().PrimaryKey())
{{else}}
    assert.Equal(t, len(obj2.{{= rev.ReverseIdentifierPlural }}()), len(obj3.{{= rev.ReverseIdentifierPlural }}()))
{{if}}
{{for}}

{{for _,mm := range table.ManyManyReferences }}
    assert.Equal(t, len(obj2.{{= mm.IdentifierPlural }}()), len(obj3.{{= mm.IdentifierPlural }}()))
{{for}}

}

func Test{{= table.Identifier }}_ReferenceUpdateOldObjects(t *testing.T) {
    ctx := context.Background()
    obj := createMaximalSample{{= table.Identifier }}(ctx)
    assert.NoError(t, obj.Save(ctx))
    defer deleteSample{{= table.Identifier }}(ctx, obj)

{{for _,ref := range table.References }}
    updateMinimalSample{{= ref.ReferencedTable.Identifier }}(obj.{{= ref.Identifier }}())
{{for}}
{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    updateMinimalSample{{= rev.Table.Identifier }}(obj.{{= rev.ReverseIdentifier }}())
{{else}}
    updateMinimalSample{{= rev.Table.Identifier }}(obj.{{= rev.ReverseIdentifierPlural }}()[0])
{{if}}
{{for}}
{{for _,mm := range table.ManyManyReferences }}
    updateMinimalSample{{= mm.ReferencedTable.Identifier }}(obj.{{= mm.IdentifierPlural }}()[0])
{{for}}

    assert.NoError(t, obj.Save(ctx))

    obj2, err := Load{{= table.Identifier }}(ctx, obj.PrimaryKey(), {{join table.References, ""}}node.{{= table.Identifier }}().{{= _j.Identifier }}(),
{{join}}
{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifier }}(),
{{else}}
    node.{{= table.Identifier }}().{{= rev.ReverseIdentifierPlural }}(),
{{if}}
{{for}}
{{join table.ManyManyReferences, ""}}node.{{= table.Identifier }}().{{= _j.IdentifierPlural }}(),
{{join}}
    )
    assert.NoError(t, err)
    _ = obj2 // avoid error if there are no references

{{for _,ref := range table.References }}
    assertEqualFields{{= ref.ReferencedTable.Identifier }}(t, obj2.{{= ref.Identifier }}(), obj.{{= ref.Identifier }}())
{{for}}

{{for _,rev := range table.ReverseReferences }}
{{if rev.IsUnique}}
    assertEqualFields{{= rev.Table.Identifier }}(t, obj2.{{= rev.ReverseIdentifier }}(), obj.{{= rev.ReverseIdentifier }}())
{{else}}
    assertEqualFields{{= rev.Table.Identifier }}(t, obj2.{{= rev.ReverseIdentifierPlural }}()[0], obj.{{= rev.ReverseIdentifierPlural }}()[0])
{{if}}
{{for}}

{{for _,mm := range table.ManyManyReferences }}
    assertEqualFields{{= mm.ReferencedTable.Identifier }}(t, obj2.{{= mm.IdentifierPlural }}()[0], obj.{{= mm.IdentifierPlural }}()[0])
{{for}}
}
}}

