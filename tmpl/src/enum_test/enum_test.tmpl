{{g
//*** {{includeName}}
}}

{{
// Code generated by goradd-orm. DO NOT EDIT.

package {{= tmpl.Package }}

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	strings2 "github.com/goradd/strings"
	"github.com/goradd/orm/pkg/test"
	"testing"
)

func Test{{= table.Identifier }}_String(t *testing.T) {
{{for _,con := range table.Constants }}
    assert.Equal(t, {{= table.Identifier }}{{= con.Name }}.String(), "{{= table.Identifier }}{{= con.Name }}")
{{for}}
}

}}

for _,field := range table.Fields[1:] {
{{
func Test{{= table.Identifier }}_{{= field.Identifier }}(t *testing.T) {
{{for _,con := range table.Constants }}
    assert.Equal(t, {{= table.Identifier }}{{= con.Name }}.{{= field.Identifier }}(), {{L con.FieldValues[field.QueryName] }})
{{for}}
    assert.Zero(t, {{= table.Identifier }}(0).{{= field.Identifier }}())
    assert.Panics(t, func() {
        {{= table.Identifier }}(-1).{{= field.Identifier }}()
    })
}

func Test{{= table.Identifier }}_{{= field.Identifier }}Slice(t *testing.T) {
    a := {{= table.Identifier }}{{= field.IdentifierPlural }}()
{{for i,con := range table.Constants }}
    assert.Equal(t, {{= table.Identifier }}{{= con.Name }}.{{= field.Identifier }}(), a[{{i i}}])
{{for}}
}

}}
}

{{

func Test{{= table.Identifier }}_Keys(t *testing.T) {
    var keys []string

{{for _,con := range table.Constants }}
    keys = append(keys, {{= table.Identifier }}{{= con.Name }}.Key())
{{for}}
    v := {{= table.IdentifierPlural }}FromKeys(keys)
    assert.Equal(t, {{= table.IdentifierPlural }}(), v)

    assert.Equal(t, {{= table.Identifier }}(0), {{= table.Identifier }}FromKey(""))
}

func Test{{= table.Identifier }}_Values(t *testing.T) {
    a1 := {{= table.IdentifierPlural }}()
    a2 := {{= table.IdentifierPlural }}I()
    for i,v1 := range a1 {
        assert.Equal(t, v1, a2[i].({{= table.Identifier }}))
        assert.True(t, IsValid{{= table.Identifier }}(int(v1)))
    }
    assert.False(t, IsValid{{= table.Identifier }}(0))
}

func Test{{= table.Identifier }}_FromKey(t *testing.T) {
    var v {{= table.Identifier }}

{{for _,con := range table.Constants }}
    v = {{= table.Identifier }}FromKey({{= table.Identifier }}({{i con.Value}}).Key())
    assert.Equal(t, {{= table.Identifier }}({{i con.Value}}), v)
{{for}}
}

func Test{{= table.Identifier }}_FromInterface(t *testing.T) {
    v := {{= table.Identifier}}{{= table.Constants[0].Name }}

    v2,err := {{= table.Identifier }}FromInterface(int(v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = {{= table.Identifier }}FromInterface(float64(v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = {{= table.Identifier }}FromInterface(json.Number(fmt.Sprintf("%d", v)))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = {{= table.Identifier }}FromInterface(fmt.Sprintf("%d", v))
    assert.NoError(t, err)
    assert.Equal(t, v, v2)

    v2,err = {{= table.Identifier }}FromInterface(0)
    assert.Error(t, err)
    assert.Equal(t, {{= table.Identifier }}(0), v2)

    var t1 time.Time
    v2,err = {{= table.Identifier }}FromInterface(t1)
    assert.Error(t, err)
    assert.Equal(t, {{= table.Identifier }}(0), v2)
}

func Test{{= table.Identifier }}_UnmarshalJSON(t *testing.T) {
	tests := []struct {
		input    string
		expected {{= table.Identifier }}
		wantErr  bool
	}{
		// Integer JSON
		{input: `{{i table.Constants[0].Value }}`, expected: {{= table.Identifier}}{{= table.Constants[0].Name }}, wantErr: false},
		// Float JSON
		{input: `{{i table.Constants[0].Value }}.0`, expected: {{= table.Identifier}}{{= table.Constants[0].Name }}, wantErr: false},
		// Stringified numbers
		{input: `"{{i table.Constants[0].Value }}"`, expected: {{= table.Identifier}}{{= table.Constants[0].Name }}, wantErr: false},
		// Invalid values
		{input: `"1.1.1"`, expected: {{= table.Identifier }}(0), wantErr: true},
	}

	for _, tt := range tests {
		var s {{= table.Identifier }}
		err := json.Unmarshal([]byte(tt.input), &s)
		if (err != nil) != tt.wantErr {
			t.Errorf("UnmarshalJSON(%s) error = %v, wantErr %v", tt.input, err, tt.wantErr)
			continue
		}
		if err == nil && s != tt.expected {
			t.Errorf("UnmarshalJSON(%s) = %v, want %v", tt.input, s, tt.expected)
		}
	}
}

}}

